/*!
 * Quasar Framework v1.19.5
 * (c) 2015-present Razvan Stoenescu
 * Released under the MIT License.
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('vue')) :
  typeof define === 'function' && define.amd ? define(['vue'], factory) :
  (global = global || self, global.Quasar = factory(global.Vue));
}(this, (function (Vue) { 'use strict';

  Vue = Vue && Object.prototype.hasOwnProperty.call(Vue, 'default') ? Vue['default'] : Vue;

  var version = "1.19.5";

  /* eslint-disable no-useless-escape */

  const isSSR = typeof window === 'undefined';
  let fromSSR = false;
  let onSSR = isSSR;

  let iosEmulated = false;
  let iosCorrection;

  function getMatch (userAgent, platformMatch) {
    const match = /(edge|edga|edgios)\/([\w.]+)/.exec(userAgent) ||
      /(opr)[\/]([\w.]+)/.exec(userAgent) ||
      /(vivaldi)[\/]([\w.]+)/.exec(userAgent) ||
      /(chrome|crios)[\/]([\w.]+)/.exec(userAgent) ||
      /(iemobile)[\/]([\w.]+)/.exec(userAgent) ||
      /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent) ||
      /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent) ||
      /(firefox|fxios)[\/]([\w.]+)/.exec(userAgent) ||
      /(webkit)[\/]([\w.]+)/.exec(userAgent) ||
      /(opera)(?:.*version|)[\/]([\w.]+)/.exec(userAgent) ||
      /(msie) ([\w.]+)/.exec(userAgent) ||
      (userAgent.indexOf('trident') >= 0 && /(rv)(?::| )([\w.]+)/.exec(userAgent)) ||
      (userAgent.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(userAgent)) ||
      [];

    return {
      browser: match[5] || match[3] || match[1] || '',
      version: match[2] || match[4] || '0',
      versionNumber: match[4] || match[2] || '0',
      platform: platformMatch[0] || ''
    }
  }

  function getPlatformMatch (userAgent) {
    return /(ipad)/.exec(userAgent) ||
      /(ipod)/.exec(userAgent) ||
      /(windows phone)/.exec(userAgent) ||
      /(iphone)/.exec(userAgent) ||
      /(kindle)/.exec(userAgent) ||
      /(silk)/.exec(userAgent) ||
      /(android)/.exec(userAgent) ||
      /(win)/.exec(userAgent) ||
      /(mac)/.exec(userAgent) ||
      /(linux)/.exec(userAgent) ||
      /(cros)/.exec(userAgent) ||
      /(playbook)/.exec(userAgent) ||
      /(bb)/.exec(userAgent) ||
      /(blackberry)/.exec(userAgent) ||
      []
  }

  const hasTouch = isSSR === false
    ? 'ontouchstart' in window || window.navigator.maxTouchPoints > 0
    : false;

  function applyIosCorrection (is) {
    iosCorrection = { is: { ...is } };

    delete is.mac;
    delete is.desktop;

    const platform = Math.min(window.innerHeight, window.innerWidth) > 414
      ? 'ipad'
      : 'iphone';

    Object.assign(is, {
      mobile: true,
      ios: true,
      platform,
      [ platform ]: true
    });
  }

  function getPlatform (UA) {
    const
      userAgent = UA.toLowerCase(),
      platformMatch = getPlatformMatch(userAgent),
      matched = getMatch(userAgent, platformMatch),
      browser = {};

    if (matched.browser) {
      browser[matched.browser] = true;
      browser.version = matched.version;
      browser.versionNumber = parseInt(matched.versionNumber, 10);
    }

    if (matched.platform) {
      browser[matched.platform] = true;
    }

    const knownMobiles = browser.android ||
      browser.ios ||
      browser.bb ||
      browser.blackberry ||
      browser.ipad ||
      browser.iphone ||
      browser.ipod ||
      browser.kindle ||
      browser.playbook ||
      browser.silk ||
      browser['windows phone'];

    // These are all considered mobile platforms, meaning they run a mobile browser
    if (knownMobiles === true || userAgent.indexOf('mobile') > -1) {
      browser.mobile = true;

      if (browser.edga || browser.edgios) {
        browser.edge = true;
        matched.browser = 'edge';
      }
      else if (browser.crios) {
        browser.chrome = true;
        matched.browser = 'chrome';
      }
      else if (browser.fxios) {
        browser.firefox = true;
        matched.browser = 'firefox';
      }
    }
    // If it's not mobile we should consider it's desktop platform, meaning it runs a desktop browser
    // It's a workaround for anonymized user agents
    // (browser.cros || browser.mac || browser.linux || browser.win)
    else {
      browser.desktop = true;
    }

    // Set iOS if on iPod, iPad or iPhone
    if (browser.ipod || browser.ipad || browser.iphone) {
      browser.ios = true;
    }

    if (browser['windows phone']) {
      browser.winphone = true;
      delete browser['windows phone'];
    }

    // Chrome, Opera 15+, Vivaldi and Safari are webkit based browsers
    if (
      browser.chrome ||
      browser.opr ||
      browser.safari ||
      browser.vivaldi ||
      // we expect unknown, non iOS mobile browsers to be webkit based
      (
        browser.mobile === true &&
        browser.ios !== true &&
        knownMobiles !== true
      )
    ) {
      browser.webkit = true;
    }

    // IE11 has a new token so we will assign it msie to avoid breaking changes
    if (browser.rv || browser.iemobile) {
      matched.browser = 'ie';
      browser.ie = true;
    }

    // Blackberry browsers are marked as Safari on BlackBerry
    if (browser.safari && browser.blackberry || browser.bb) {
      matched.browser = 'blackberry';
      browser.blackberry = true;
    }

    // Playbook browsers are marked as Safari on Playbook
    if (browser.safari && browser.playbook) {
      matched.browser = 'playbook';
      browser.playbook = true;
    }

    // Opera 15+ are identified as opr
    if (browser.opr) {
      matched.browser = 'opera';
      browser.opera = true;
    }

    // Stock Android browsers are marked as Safari on Android.
    if (browser.safari && browser.android) {
      matched.browser = 'android';
      browser.android = true;
    }

    // Kindle browsers are marked as Safari on Kindle
    if (browser.safari && browser.kindle) {
      matched.browser = 'kindle';
      browser.kindle = true;
    }

    // Kindle Silk browsers are marked as Safari on Kindle
    if (browser.safari && browser.silk) {
      matched.browser = 'silk';
      browser.silk = true;
    }

    if (browser.vivaldi) {
      matched.browser = 'vivaldi';
      browser.vivaldi = true;
    }

    // Assign the name and platform variable
    browser.name = matched.browser;
    browser.platform = matched.platform;

    if (isSSR === false) {
      if (userAgent.indexOf('electron') > -1) {
        browser.electron = true;
      }
      else if (document.location.href.indexOf('-extension://') > -1) {
        browser.bex = true;
      }
      else {
        if (window.Capacitor !== void 0) {
          browser.capacitor = true;
          browser.nativeMobile = true;
          browser.nativeMobileWrapper = 'capacitor';
        }
        else if (window._cordovaNative !== void 0 || window.cordova !== void 0) {
          browser.cordova = true;
          browser.nativeMobile = true;
          browser.nativeMobileWrapper = 'cordova';
        }

        if (
          hasTouch === true &&
          browser.mac === true &&
          (
            (browser.desktop === true && browser.safari === true) ||
            (
              browser.nativeMobile === true &&
              browser.android !== true &&
              browser.ios !== true &&
              browser.ipad !== true
            )
          )
        ) {
          /*
          * Correction needed for iOS since the default
          * setting on iPad is to request desktop view; if we have
          * touch support and the user agent says it's a
          * desktop, we infer that it's an iPhone/iPad with desktop view
          * so we must fix the false positives
          */
          applyIosCorrection(browser);
        }
      }

      fromSSR = browser.nativeMobile === void 0 &&
        browser.electron === void 0 &&
        document.querySelector('[data-server-rendered]') !== null;

      if (fromSSR === true) {
        onSSR = true;
      }
    }

    return browser
  }

  const userAgent = isSSR !== true
    ? navigator.userAgent || navigator.vendor || window.opera
    : '';

  const ssrClient = {
    has: {
      touch: false,
      webStorage: false
    },
    within: { iframe: false }
  };

  // We export "client" for hydration error-free parts,
  // like touch directives who do not (and must NOT) wait
  // for the client takeover;
  // Do NOT import this directly in your app, unless you really know
  // what you are doing.
  const client = isSSR === false
    ? {
      userAgent,
      is: getPlatform(userAgent),
      has: {
        touch: hasTouch,
        webStorage: (() => {
          try {
            if (window.localStorage) {
              return true
            }
          }
          catch (e) {}
          return false
        })()
      },
      within: {
        iframe: window.self !== window.top
      }
    }
    : ssrClient;

  const Platform = {
    install ($q, queues) {
      if (isSSR === true) {
        // we're on server-side, so we push
        // to the server queue instead of
        // applying directly
        queues.server.push((q, ctx) => {
          q.platform = this.parseSSR(ctx.ssr);
        });
      }
      else if (fromSSR === true) {
        // must match with server-side before
        // client taking over in order to prevent
        // hydration errors
        Object.assign(this, client, iosCorrection, ssrClient);

        // takeover should increase accuracy for
        // the rest of the props; we also avoid
        // hydration errors
        queues.takeover.push(q => {
          onSSR = fromSSR = false;
          Object.assign(q.platform, client);
          iosCorrection = void 0;
        });

        // we need to make platform reactive
        // for the takeover phase
        Vue.util.defineReactive($q, 'platform', this);
      }
      else {
        // we don't have any business with SSR, so
        // directly applying...
        Object.assign(this, client);
        $q.platform = this;
      }
    }
  };

  if (isSSR === true) {
    Platform.parseSSR = (/* ssrContext */ ssr) => {
      const userAgent = ssr.req.headers['user-agent'] || ssr.req.headers['User-Agent'] || '';
      return {
        ...client,
        userAgent,
        is: getPlatform(userAgent)
      }
    };
  }
  else {
    iosEmulated = client.is.ios === true &&
      window.navigator.vendor.toLowerCase().indexOf('apple') === -1;
  }

  const listenOpts = {
    hasPassive: false,
    passiveCapture: true,
    notPassiveCapture: true
  };

  try {
    var opts = Object.defineProperty({}, 'passive', {
      get () {
        Object.assign(listenOpts, {
          hasPassive: true,
          passive: { passive: true },
          notPassive: { passive: false },
          passiveCapture: { passive: true, capture: true },
          notPassiveCapture: { passive: false, capture: true }
        });
      }
    });
    window.addEventListener('qtest', null, opts);
    window.removeEventListener('qtest', null, opts);
  }
  catch (e) {}

  function noop () {}

  function leftClick (e) {
    return e.button === 0
  }

  function middleClick (e) {
    return e.button === 1
  }

  function rightClick (e) {
    return e.button === 2
  }

  function position (e) {
    if (e.touches && e.touches[0]) {
      e = e.touches[0];
    }
    else if (e.changedTouches && e.changedTouches[0]) {
      e = e.changedTouches[0];
    }
    else if (e.targetTouches && e.targetTouches[0]) {
      e = e.targetTouches[0];
    }

    return {
      top: e.clientY,
      left: e.clientX
    }
  }

  function getEventPath (e) {
    if (e.path) {
      return e.path
    }
    if (e.composedPath) {
      return e.composedPath()
    }

    const path = [];
    let el = e.target;

    while (el) {
      path.push(el);

      if (el.tagName === 'HTML') {
        path.push(document);
        path.push(window);
        return path
      }

      el = el.parentElement;
    }
  }

  // Reasonable defaults
  const
    LINE_HEIGHT = 40,
    PAGE_HEIGHT = 800;

  function getMouseWheelDistance (e) {
    let x = e.deltaX, y = e.deltaY;

    if ((x || y) && e.deltaMode) {
      const multiplier = e.deltaMode === 1 ? LINE_HEIGHT : PAGE_HEIGHT;
      x *= multiplier;
      y *= multiplier;
    }

    if (e.shiftKey && !x) {
      [y, x] = [x, y];
    }

    return { x, y }
  }

  function stop (e) {
    e.stopPropagation();
  }

  function prevent (e) {
    e.cancelable !== false && e.preventDefault();
  }

  function stopAndPrevent (e) {
    e.cancelable !== false && e.preventDefault();
    e.stopPropagation();
  }

  function stopAndPreventClick (evt) {
    stopAndPrevent(evt);

    if (evt.type === 'mousedown') {
      const handler = e => {
        e.target === evt.target && stopAndPrevent(e);
        document.removeEventListener('click', handler, listenOpts.notPassiveCapture);
      };

      document.addEventListener('click', handler, listenOpts.notPassiveCapture);
    }
  }

  function preventDraggable (el, status) {
    if (el === void 0 || (status === true && el.__dragPrevented === true)) {
      return
    }

    const fn = status === true
      ? el => {
        el.__dragPrevented = true;
        el.addEventListener('dragstart', prevent, listenOpts.notPassiveCapture);
      }
      : el => {
        delete el.__dragPrevented;
        el.removeEventListener('dragstart', prevent, listenOpts.notPassiveCapture);
      };

    el.querySelectorAll('a, img').forEach(fn);
  }

  function create (name, { bubbles = false, cancelable = false } = {}) {
    try {
      return new CustomEvent(name, { bubbles, cancelable })
    }
    catch (e) {
      // IE doesn't support `new Event()`, so...
      const evt = document.createEvent('Event');
      evt.initEvent(name, bubbles, cancelable);
      return evt
    }
  }

  function addEvt (ctx, targetName, events) {
    const name = `__q_${targetName}_evt`;

    ctx[name] = ctx[name] !== void 0
      ? ctx[name].concat(events)
      : events;

    events.forEach(evt => {
      evt[0].addEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
    });
  }

  function cleanEvt (ctx, targetName) {
    const name = `__q_${targetName}_evt`;

    if (ctx[name] !== void 0) {
      ctx[name].forEach(evt => {
        evt[0].removeEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
      });
      ctx[name] = void 0;
    }
  }

  /*
   * also update /types/utils/event.d.ts
   */

  var event = {
    listenOpts,
    leftClick,
    middleClick,
    rightClick,
    position,
    getEventPath,
    getMouseWheelDistance,
    stop,
    prevent,
    stopAndPrevent,
    preventDraggable,
    create
  };

  function debounce (fn, wait = 250, immediate) {
    let timeout;

    function debounced (/* ...args */) {
      const args = arguments;

      const later = () => {
        timeout = void 0;
        if (immediate !== true) {
          fn.apply(this, args);
        }
      };

      clearTimeout(timeout);
      if (immediate === true && timeout === void 0) {
        fn.apply(this, args);
      }
      timeout = setTimeout(later, wait);
    }

    debounced.cancel = () => {
      clearTimeout(timeout);
    };

    return debounced
  }

  const SIZE_LIST = ['sm', 'md', 'lg', 'xl'];
  const { passive } = listenOpts;

  var Screen = {
    width: 0,
    height: 0,

    name: 'xs',

    sizes: {
      sm: 600,
      md: 1024,
      lg: 1440,
      xl: 1920
    },

    lt: {
      sm: true,
      md: true,
      lg: true,
      xl: true
    },
    gt: {
      xs: false,
      sm: false,
      md: false,
      lg: false
    },
    xs: true,
    sm: false,
    md: false,
    lg: false,
    xl: false,

    setSizes: noop,
    setDebounce: noop,

    install ($q, queues, cfg) {
      if (isSSR === true) {
        $q.screen = this;
        return
      }

      const { visualViewport } = window;
      const target = visualViewport || window;
      const scrollingElement = document.scrollingElement || document.documentElement;
      const getSize = visualViewport === void 0 || client.is.mobile === true
        ? () => [
          Math.max(window.innerWidth, scrollingElement.clientWidth),
          Math.max(window.innerHeight, scrollingElement.clientHeight)
        ]
        : () => [
          visualViewport.width * visualViewport.scale + window.innerWidth - scrollingElement.clientWidth,
          visualViewport.height * visualViewport.scale + window.innerHeight - scrollingElement.clientHeight
        ];

      const classes = cfg.screen !== void 0 && cfg.screen.bodyClasses === true;

      const update = force => {
        const [ w, h ] = getSize();

        if (h !== this.height) {
          this.height = h;
        }

        if (w !== this.width) {
          this.width = w;
        }
        else if (force !== true) {
          return
        }

        let s = this.sizes;

        this.gt.xs = w >= s.sm;
        this.gt.sm = w >= s.md;
        this.gt.md = w >= s.lg;
        this.gt.lg = w >= s.xl;
        this.lt.sm = w < s.sm;
        this.lt.md = w < s.md;
        this.lt.lg = w < s.lg;
        this.lt.xl = w < s.xl;
        this.xs = this.lt.sm;
        this.sm = this.gt.xs === true && this.lt.md === true;
        this.md = this.gt.sm === true && this.lt.lg === true;
        this.lg = this.gt.md === true && this.lt.xl === true;
        this.xl = this.gt.lg;

        s = (this.xs === true && 'xs') ||
          (this.sm === true && 'sm') ||
          (this.md === true && 'md') ||
          (this.lg === true && 'lg') ||
          'xl';

        if (s !== this.name) {
          if (classes === true) {
            document.body.classList.remove(`screen--${this.name}`);
            document.body.classList.add(`screen--${s}`);
          }
          this.name = s;
        }
      };

      let updateEvt, updateSizes = {}, updateDebounce = 16;

      this.setSizes = sizes => {
        SIZE_LIST.forEach(name => {
          if (sizes[name] !== void 0) {
            updateSizes[name] = sizes[name];
          }
        });
      };
      this.setDebounce = deb => {
        updateDebounce = deb;
      };

      const start = () => {
        const style = getComputedStyle(document.body);

        // if css props available
        if (style.getPropertyValue('--q-size-sm')) {
          SIZE_LIST.forEach(name => {
            this.sizes[name] = parseInt(style.getPropertyValue(`--q-size-${name}`), 10);
          });
        }

        this.setSizes = sizes => {
          SIZE_LIST.forEach(name => {
            if (sizes[name]) {
              this.sizes[name] = sizes[name];
            }
          });
          update(true);
        };

        this.setDebounce = delay => {
          updateEvt !== void 0 && target.removeEventListener('resize', updateEvt, passive);
          updateEvt = delay > 0
            ? debounce(update, delay)
            : update;
          target.addEventListener('resize', updateEvt, passive);
        };

        this.setDebounce(updateDebounce);

        if (Object.keys(updateSizes).length > 0) {
          this.setSizes(updateSizes);
          updateSizes = void 0; // free up memory
        }
        else {
          update();
        }

        // due to optimizations, this would be left out otherwise
        classes === true && this.name === 'xs' &&
          document.body.classList.add('screen--xs');
      };

      if (fromSSR === true) {
        queues.takeover.push(start);
      }
      else {
        start();
      }

      Vue.util.defineReactive($q, 'screen', this);
    }
  };

  const Dark = {
    isActive: false,
    mode: false,

    install ($q, queues, { dark }) {
      this.isActive = dark === true;

      if (isSSR === true) {
        queues.server.push((q, ctx) => {
          q.dark = {
            isActive: false,
            mode: false,
            set: val => {
              ctx.ssr.Q_BODY_CLASSES = ctx.ssr.Q_BODY_CLASSES
                .replace(' body--light', '')
                .replace(' body--dark', '') + ` body--${val === true ? 'dark' : 'light'}`;

              q.dark.isActive = val === true;
              q.dark.mode = val;
            },
            toggle: () => {
              q.dark.set(q.dark.isActive === false);
            }
          };

          q.dark.set(dark);
        });

        this.set = noop;
        return
      }

      const initialVal = dark !== void 0
        ? dark
        : false;

      if (fromSSR === true) {
        const ssrSet = val => {
          this.__fromSSR = val;
        };

        const originalSet = this.set;

        this.set = ssrSet;
        ssrSet(initialVal);

        queues.takeover.push(() => {
          this.set = originalSet;
          this.set(this.__fromSSR);
        });
      }
      else {
        this.set(initialVal);
      }

      Vue.util.defineReactive(this, 'isActive', this.isActive);
      Vue.util.defineReactive($q, 'dark', this);
    },

    set (val) {
      this.mode = val;

      if (val === 'auto') {
        if (this.__media === void 0) {
          this.__media = window.matchMedia('(prefers-color-scheme: dark)');
          this.__updateMedia = () => { this.set('auto'); };
          this.__media.addListener(this.__updateMedia);
        }

        val = this.__media.matches;
      }
      else if (this.__media !== void 0) {
        this.__media.removeListener(this.__updateMedia);
        this.__media = void 0;
      }

      this.isActive = val === true;

      document.body.classList.remove(`body--${val === true ? 'light' : 'dark'}`);
      document.body.classList.add(`body--${val === true ? 'dark' : 'light'}`);
    },

    toggle () {
      Dark.set(Dark.isActive === false);
    },

    __media: void 0
  };

  const getTrue = () => true;

  function filterInvalidPath (path) {
    return typeof path === 'string' &&
      path !== '' &&
      path !== '/' &&
      path !== '#/'
  }

  function normalizeExitPath (path) {
    path.startsWith('#') === true && (path = path.substr(1));
    path.startsWith('/') === false && (path = '/' + path);
    path.endsWith('/') === true && (path = path.substr(0, path.length - 1));
    return '#' + path
  }

  function getShouldExitFn (cfg) {
    if (cfg.backButtonExit === false) {
      return () => false
    }

    if (cfg.backButtonExit === '*') {
      return getTrue
    }

    // Add default root path
    const exitPaths = [ '#/' ];

    // Add custom exit paths
    Array.isArray(cfg.backButtonExit) === true && exitPaths.push(
      ...cfg.backButtonExit.filter(filterInvalidPath).map(normalizeExitPath)
    );

    return () => exitPaths.includes(window.location.hash)
  }

  var History = {
    __history: [],
    add: noop,
    remove: noop,

    install (cfg) {
      if (isSSR === true) {
        return
      }

      const { cordova, capacitor } = client.is;

      if (cordova !== true && capacitor !== true) {
        return
      }

      const qConf = cfg[cordova === true ? 'cordova' : 'capacitor'];

      if (qConf !== void 0 && qConf.backButton === false) {
        return
      }

      // if the '@capacitor/app' plugin is not installed
      // then we got nothing to do
      if (
        // if we're on Capacitor mode
        capacitor === true &&
        // and it's also not in Capacitor's main instance
        (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0)
      ) {
        return
      }

      this.add = entry => {
        if (entry.condition === void 0) {
          entry.condition = getTrue;
        }
        this.__history.push(entry);
      };

      this.remove = entry => {
        const index = this.__history.indexOf(entry);
        if (index >= 0) {
          this.__history.splice(index, 1);
        }
      };

      const shouldExit = getShouldExitFn(
        Object.assign(
          { backButtonExit: true },
          qConf
        )
      );

      const backHandler = () => {
        if (this.__history.length) {
          const entry = this.__history[this.__history.length - 1];

          if (entry.condition() === true) {
            this.__history.pop();
            entry.handler();
          }
        }
        else if (shouldExit() === true) {
          navigator.app.exitApp();
        }
        else {
          window.history.back();
        }
      };

      if (cordova === true) {
        document.addEventListener('deviceready', () => {
          document.addEventListener('backbutton', backHandler, false);
        });
      }
      else {
        window.Capacitor.Plugins.App.addListener('backButton', backHandler);
      }
    }
  };

  var defaultLang = {
    isoName: 'en-us',
    nativeName: 'English (US)',
    label: {
      clear: 'Clear',
      ok: 'OK',
      cancel: 'Cancel',
      close: 'Close',
      set: 'Set',
      select: 'Select',
      reset: 'Reset',
      remove: 'Remove',
      update: 'Update',
      create: 'Create',
      search: 'Search',
      filter: 'Filter',
      refresh: 'Refresh'
    },
    date: {
      days: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
      daysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      firstDayOfWeek: 0, // 0-6, 0 - Sunday, 1 Monday, ...
      format24h: false,
      pluralDay: 'days'
    },
    table: {
      noData: 'No data available',
      noResults: 'No matching records found',
      loading: 'Loading...',
      selectedRecords: function (rows) {
        return rows === 1
          ? '1 record selected.'
          : (rows === 0 ? 'No' : rows) + ' records selected.'
      },
      recordsPerPage: 'Records per page:',
      allRows: 'All',
      pagination: function (start, end, total) {
        return start + '-' + end + ' of ' + total
      },
      columns: 'Columns'
    },
    editor: {
      url: 'URL',
      bold: 'Bold',
      italic: 'Italic',
      strikethrough: 'Strikethrough',
      underline: 'Underline',
      unorderedList: 'Unordered List',
      orderedList: 'Ordered List',
      subscript: 'Subscript',
      superscript: 'Superscript',
      hyperlink: 'Hyperlink',
      toggleFullscreen: 'Toggle Fullscreen',
      quote: 'Quote',
      left: 'Left align',
      center: 'Center align',
      right: 'Right align',
      justify: 'Justify align',
      print: 'Print',
      outdent: 'Decrease indentation',
      indent: 'Increase indentation',
      removeFormat: 'Remove formatting',
      formatting: 'Formatting',
      fontSize: 'Font Size',
      align: 'Align',
      hr: 'Insert Horizontal Rule',
      undo: 'Undo',
      redo: 'Redo',
      heading1: 'Heading 1',
      heading2: 'Heading 2',
      heading3: 'Heading 3',
      heading4: 'Heading 4',
      heading5: 'Heading 5',
      heading6: 'Heading 6',
      paragraph: 'Paragraph',
      code: 'Code',
      size1: 'Very small',
      size2: 'A bit small',
      size3: 'Normal',
      size4: 'Medium-large',
      size5: 'Big',
      size6: 'Very big',
      size7: 'Maximum',
      defaultFont: 'Default Font',
      viewSource: 'View Source'
    },
    tree: {
      noNodes: 'No nodes available',
      noResults: 'No matching nodes found'
    }
  };

  function getLocale () {
    if (isSSR === true) { return }

    const val =
      navigator.language ||
      navigator.languages[0] ||
      navigator.browserLanguage ||
      navigator.userLanguage ||
      navigator.systemLanguage;

    if (val) {
      return val.toLowerCase()
    }
  }

  const Plugin = {
    getLocale,

    install ($q, queues, lang) {
      const initialLang = lang || defaultLang;

      this.set = (langObject = defaultLang, ssrContext) => {
        const lang = {
          ...langObject,
          rtl: langObject.rtl === true,
          getLocale
        };

        if (isSSR === true) {
          if (ssrContext === void 0) {
            console.error('SSR ERROR: second param required: Quasar.lang.set(lang, ssrContext)');
            return
          }

          const dir = lang.rtl === true ? 'rtl' : 'ltr';
          const attrs = `lang=${lang.isoName} dir=${dir}`;

          lang.set = ssrContext.$q.lang.set;

          ssrContext.Q_HTML_ATTRS = ssrContext.Q_PREV_LANG !== void 0
            ? ssrContext.Q_HTML_ATTRS.replace(ssrContext.Q_PREV_LANG, attrs)
            : attrs;

          ssrContext.Q_PREV_LANG = attrs;
          ssrContext.$q.lang = lang;
        }
        else {
          if (fromSSR === false) {
            const el = document.documentElement;
            el.setAttribute('dir', lang.rtl === true ? 'rtl' : 'ltr');
            el.setAttribute('lang', lang.isoName);
          }

          lang.set = this.set;
          $q.lang = this.props = lang;
          this.isoName = lang.isoName;
          this.nativeName = lang.nativeName;
        }
      };

      if (isSSR === true) {
        queues.server.push((q, ctx) => {
          q.lang = {};
          q.lang.set = langObject => {
            this.set(langObject, ctx.ssr);
          };

          q.lang.set(initialLang);
        });

        this.isoName = initialLang.isoName;
        this.nativeName = initialLang.nativeName;
        this.props = initialLang;
      }
      else {
        Vue.util.defineReactive($q, 'lang', {});
        this.set(initialLang);
      }
    }
  };

  const reRGBA = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;

  function rgbToHex ({ r, g, b, a }) {
    const alpha = a !== void 0;

    r = Math.round(r);
    g = Math.round(g);
    b = Math.round(b);

    if (
      r > 255 ||
      g > 255 ||
      b > 255 ||
      (alpha && a > 100)
    ) {
      throw new TypeError('Expected 3 numbers below 256 (and optionally one below 100)')
    }

    a = alpha
      ? (Math.round(255 * a / 100) | 1 << 8).toString(16).slice(1)
      : '';

    return '#' + ((b | g << 8 | r << 16) | 1 << 24).toString(16).slice(1) + a
  }

  function rgbToString ({ r, g, b, a }) {
    return `rgb${a !== void 0 ? 'a' : ''}(${r},${g},${b}${a !== void 0 ? ',' + (a / 100) : ''})`
  }

  function hexToRgb (hex) {
    if (typeof hex !== 'string') {
      throw new TypeError('Expected a string')
    }

    hex = hex.replace(/^#/, '');

    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    else if (hex.length === 4) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
    }

    const num = parseInt(hex, 16);

    return hex.length > 6
      ? { r: num >> 24 & 255, g: num >> 16 & 255, b: num >> 8 & 255, a: Math.round((num & 255) / 2.55) }
      : { r: num >> 16, g: num >> 8 & 255, b: num & 255 }
  }

  function hsvToRgb ({ h, s, v, a }) {
    let r, g, b;
    s = s / 100;
    v = v / 100;

    h = h / 360;
    const
      i = Math.floor(h * 6),
      f = h * 6 - i,
      p = v * (1 - s),
      q = v * (1 - f * s),
      t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v;
        g = t;
        b = p;
        break
      case 1:
        r = q;
        g = v;
        b = p;
        break
      case 2:
        r = p;
        g = v;
        b = t;
        break
      case 3:
        r = p;
        g = q;
        b = v;
        break
      case 4:
        r = t;
        g = p;
        b = v;
        break
      case 5:
        r = v;
        g = p;
        b = q;
        break
    }

    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255),
      a
    }
  }

  function rgbToHsv ({ r, g, b, a }) {
    const
      max = Math.max(r, g, b),
      min = Math.min(r, g, b),
      d = max - min,
      s = (max === 0 ? 0 : d / max),
      v = max / 255;
    let h;

    switch (max) {
      case min:
        h = 0;
        break
      case r:
        h = (g - b) + d * (g < b ? 6 : 0);
        h /= 6 * d;
        break
      case g:
        h = (b - r) + d * 2;
        h /= 6 * d;
        break
      case b:
        h = (r - g) + d * 4;
        h /= 6 * d;
        break
    }

    return {
      h: Math.round(h * 360),
      s: Math.round(s * 100),
      v: Math.round(v * 100),
      a
    }
  }

  function textToRgb (str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string')
    }

    const color = str.replace(/ /g, '');

    const m = reRGBA.exec(color);

    if (m === null) {
      return hexToRgb(color)
    }

    const rgb = {
      r: Math.min(255, parseInt(m[2], 10)),
      g: Math.min(255, parseInt(m[3], 10)),
      b: Math.min(255, parseInt(m[4], 10))
    };

    if (m[1]) {
      const alpha = parseFloat(m[5]);
      rgb.a = Math.min(1, isNaN(alpha) === true ? 1 : alpha) * 100;
    }

    return rgb
  }

  /* works as darken if percent < 0 */
  function lighten (color, percent) {
    if (typeof color !== 'string') {
      throw new TypeError('Expected a string as color')
    }
    if (typeof percent !== 'number') {
      throw new TypeError('Expected a numeric percent')
    }

    const rgb = textToRgb(color),
      t = percent < 0 ? 0 : 255,
      p = Math.abs(percent) / 100,
      R = rgb.r,
      G = rgb.g,
      B = rgb.b;

    return '#' + (
      0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 +
      (Math.round((t - G) * p) + G) * 0x100 +
      (Math.round((t - B) * p) + B)
    ).toString(16).slice(1)
  }

  function luminosity (color) {
    if (typeof color !== 'string' && (!color || color.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b} object as color')
    }

    const
      rgb = typeof color === 'string' ? textToRgb(color) : color,
      r = rgb.r / 255,
      g = rgb.g / 255,
      b = rgb.b / 255,
      R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4),
      G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4),
      B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B
  }

  function brightness (color) {
    if (typeof color !== 'string' && (!color || color.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b} object as color')
    }

    const rgb = typeof color === 'string'
      ? textToRgb(color)
      : color;

    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000
  }

  function blend (fgColor, bgColor) {
    if (typeof fgColor !== 'string' && (!fgColor || fgColor.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b[, a]} object as fgColor')
    }

    if (typeof bgColor !== 'string' && (!bgColor || bgColor.r === void 0)) {
      throw new TypeError('Expected a string or a {r, g, b[, a]} object as bgColor')
    }

    const
      rgb1 = typeof fgColor === 'string' ? textToRgb(fgColor) : fgColor,
      r1 = rgb1.r / 255,
      g1 = rgb1.g / 255,
      b1 = rgb1.b / 255,
      a1 = rgb1.a !== void 0 ? rgb1.a / 100 : 1,
      rgb2 = typeof bgColor === 'string' ? textToRgb(bgColor) : bgColor,
      r2 = rgb2.r / 255,
      g2 = rgb2.g / 255,
      b2 = rgb2.b / 255,
      a2 = rgb2.a !== void 0 ? rgb2.a / 100 : 1,
      a = a1 + a2 * (1 - a1),
      r = Math.round(((r1 * a1 + r2 * a2 * (1 - a1)) / a) * 255),
      g = Math.round(((g1 * a1 + g2 * a2 * (1 - a1)) / a) * 255),
      b = Math.round(((b1 * a1 + b2 * a2 * (1 - a1)) / a) * 255);

    const ret = { r, g, b, a: Math.round(a * 100) };
    return typeof fgColor === 'string'
      ? rgbToHex(ret)
      : ret
  }

  function changeAlpha (color, offset) {
    if (typeof color !== 'string') {
      throw new TypeError('Expected a string as color')
    }

    if (offset === void 0 || offset < -1 || offset > 1) {
      throw new TypeError('Expected offset to be between -1 and 1')
    }

    const { r, g, b, a } = textToRgb(color);
    const alpha = a !== void 0 ? a / 100 : 0;

    return rgbToHex({
      r, g, b, a: Math.round(Math.min(1, Math.max(0, alpha + offset)) * 100)
    })
  }

  function setBrand (color, value, element = document.body) {
    if (typeof color !== 'string') {
      throw new TypeError('Expected a string as color')
    }
    if (typeof value !== 'string') {
      throw new TypeError('Expected a string as value')
    }
    if (!(element instanceof Element)) {
      throw new TypeError('Expected a DOM element')
    }

    element.style.setProperty(`--q-color-${color}`, value);
  }

  function getBrand (color, element = document.body) {
    if (typeof color !== 'string') {
      throw new TypeError('Expected a string as color')
    }
    if (!(element instanceof Element)) {
      throw new TypeError('Expected a DOM element')
    }

    return getComputedStyle(element).getPropertyValue(`--q-color-${color}`).trim() || null
  }

  function getPaletteColor (colorName) {
    if (typeof colorName !== 'string') {
      throw new TypeError('Expected a string as color')
    }

    const el = document.createElement('div');

    el.className = `text-${colorName} invisible fixed no-pointer-events`;
    document.body.appendChild(el);

    const result = getComputedStyle(el).getPropertyValue('color');

    el.remove();

    return rgbToHex(textToRgb(result))
  }

  var colors = {
    rgbToHex,
    hexToRgb,
    hsvToRgb,
    rgbToHsv,
    textToRgb,
    lighten,
    luminosity,
    brightness,
    blend,
    changeAlpha,
    setBrand,
    getBrand,
    getPaletteColor
  };

  let lastKeyCompositionStatus = false;

  function onKeyDownComposition (evt) {
    lastKeyCompositionStatus = evt.isComposing === true;
  }

  function shouldIgnoreKey (evt) {
    return lastKeyCompositionStatus === true ||
      evt !== Object(evt) ||
      evt.isComposing === true ||
      evt.qKeyEvent === true
  }

  function isKeyCode (evt, keyCodes) {
    return shouldIgnoreKey(evt) === true
      ? false
      : [].concat(keyCodes).includes(evt.keyCode)
  }

  function getMobilePlatform (is) {
    if (is.ios === true) return 'ios'
    if (is.android === true) return 'android'
  }

  function getBodyClasses ({ is, has, within }, cfg) {
    const cls = [
      is.desktop === true ? 'desktop' : 'mobile',
      `${has.touch === false ? 'no-' : ''}touch`
    ];

    if (is.mobile === true) {
      const mobile = getMobilePlatform(is);
      mobile !== void 0 && cls.push('platform-' + mobile);
    }

    if (is.nativeMobile === true) {
      const type = is.nativeMobileWrapper;

      cls.push(type);
      cls.push('native-mobile');

      if (
        is.ios === true &&
        (cfg[type] === void 0 || cfg[type].iosStatusBarPadding !== false)
      ) {
        cls.push('q-ios-padding');
      }
    }
    else if (is.electron === true) {
      cls.push('electron');
    }
    else if (is.bex === true) {
      cls.push('bex');
    }

    within.iframe === true && cls.push('within-iframe');

    return cls
  }

  // SSR takeover corrections
  function clientUpdate () {
    const classes = document.body.className;
    let newCls = classes;

    if (iosCorrection !== void 0) {
      newCls = newCls.replace('desktop', 'platform-ios mobile');
    }

    if (client.has.touch === true) {
      newCls = newCls.replace('no-touch', 'touch');
    }

    if (client.within.iframe === true) {
      newCls += ' within-iframe';
    }

    if (classes !== newCls) {
      document.body.className = newCls;
    }
  }

  function setColors (brand) {
    for (const color in brand) {
      setBrand(color, brand[color]);
    }
  }

  var Body = {
    install (queues, cfg) {
      if (isSSR === true) {
        queues.server.push((q, ctx) => {
          const
            cls = getBodyClasses(q.platform, cfg),
            fn = ctx.ssr.setBodyClasses;

          if (cfg.screen !== void 0 && cfg.screen.bodyClass === true) {
            cls.push('screen--xs');
          }

          if (typeof fn === 'function') {
            fn(cls);
          }
          else {
            ctx.ssr.Q_BODY_CLASSES = cls.join(' ');
          }
        });

        return
      }

      if (fromSSR === true) {
        clientUpdate();
      }
      else {
        const cls = getBodyClasses(client, cfg);

        if (client.is.ie === true && client.is.versionNumber === 11) {
          cls.forEach(c => document.body.classList.add(c));
        }
        else {
          document.body.classList.add.apply(document.body.classList, cls);
        }
      }

      cfg.brand !== void 0 && setColors(cfg.brand);

      if (client.is.ios === true) {
        // needed for iOS button active state
        document.body.addEventListener('touchstart', noop);
      }

      window.addEventListener('keydown', onKeyDownComposition, true);
    }
  };

  var materialIcons = {
    name: 'material-icons',
    type: {
      positive: 'check_circle',
      negative: 'warning',
      info: 'info',
      warning: 'priority_high'
    },
    arrow: {
      up: 'arrow_upward',
      right: 'arrow_forward',
      down: 'arrow_downward',
      left: 'arrow_back',
      dropdown: 'arrow_drop_down'
    },
    chevron: {
      left: 'chevron_left',
      right: 'chevron_right'
    },
    colorPicker: {
      spectrum: 'gradient',
      tune: 'tune',
      palette: 'style'
    },
    pullToRefresh: {
      icon: 'refresh'
    },
    carousel: {
      left: 'chevron_left',
      right: 'chevron_right',
      up: 'keyboard_arrow_up',
      down: 'keyboard_arrow_down',
      navigationIcon: 'lens'
    },
    chip: {
      remove: 'cancel',
      selected: 'check'
    },
    datetime: {
      arrowLeft: 'chevron_left',
      arrowRight: 'chevron_right',
      now: 'access_time',
      today: 'today'
    },
    editor: {
      bold: 'format_bold',
      italic: 'format_italic',
      strikethrough: 'strikethrough_s',
      underline: 'format_underlined',
      unorderedList: 'format_list_bulleted',
      orderedList: 'format_list_numbered',
      subscript: 'vertical_align_bottom',
      superscript: 'vertical_align_top',
      hyperlink: 'link',
      toggleFullscreen: 'fullscreen',
      quote: 'format_quote',
      left: 'format_align_left',
      center: 'format_align_center',
      right: 'format_align_right',
      justify: 'format_align_justify',
      print: 'print',
      outdent: 'format_indent_decrease',
      indent: 'format_indent_increase',
      removeFormat: 'format_clear',
      formatting: 'text_format',
      fontSize: 'format_size',
      align: 'format_align_left',
      hr: 'remove',
      undo: 'undo',
      redo: 'redo',
      heading: 'format_size',
      code: 'code',
      size: 'format_size',
      font: 'font_download',
      viewSource: 'code'
    },
    expansionItem: {
      icon: 'keyboard_arrow_down',
      denseIcon: 'arrow_drop_down'
    },
    fab: {
      icon: 'add',
      activeIcon: 'close'
    },
    field: {
      clear: 'cancel',
      error: 'error'
    },
    pagination: {
      first: 'first_page',
      prev: 'keyboard_arrow_left',
      next: 'keyboard_arrow_right',
      last: 'last_page'
    },
    rating: {
      icon: 'grade'
    },
    stepper: {
      done: 'check',
      active: 'edit',
      error: 'warning'
    },
    tabs: {
      left: 'chevron_left',
      right: 'chevron_right',
      up: 'keyboard_arrow_up',
      down: 'keyboard_arrow_down'
    },
    table: {
      arrowUp: 'arrow_upward',
      warning: 'warning',
      firstPage: 'first_page',
      prevPage: 'chevron_left',
      nextPage: 'chevron_right',
      lastPage: 'last_page'
    },
    tree: {
      icon: 'play_arrow'
    },
    uploader: {
      done: 'done',
      clear: 'clear',
      add: 'add_box',
      upload: 'cloud_upload',
      removeQueue: 'clear_all',
      removeUploaded: 'done_all'
    }
  };

  var iconSet = {
    install ($q, queues, iconSet) {
      const initialSet = iconSet || materialIcons;

      this.set = (setObject, ssrContext) => {
        const def = { ...setObject };

        if (isSSR === true) {
          if (ssrContext === void 0) {
            console.error('SSR ERROR: second param required: Quasar.iconSet.set(iconSet, ssrContext)');
            return
          }

          def.set = ssrContext.$q.iconSet.set;
          ssrContext.$q.iconSet = def;
        }
        else {
          def.set = this.set;
          $q.iconSet = def;
        }
      };

      if (isSSR === true) {
        queues.server.push((q, ctx) => {
          q.iconSet = {};
          q.iconSet.set = setObject => {
            this.set(setObject, ctx.ssr);
          };

          q.iconSet.set(initialSet);
        });
      }
      else {
        Vue.util.defineReactive($q, 'iconMapFn', void 0);
        Vue.util.defineReactive($q, 'iconSet', {});

        this.set(initialSet);
      }
    }
  };

  const autoInstalled = [
    Platform, Screen, Dark
  ];

  const queues = {
    server: [], // on SSR update
    takeover: [] // on client takeover
  };

  const $q = {
    version,
    config: {}
  };

  function install (Vue, opts = {}) {
    if (this.__qInstalled === true) { return }
    this.__qInstalled = true;

    const cfg = $q.config = Object.freeze(opts.config || {});

    // required plugins
    Platform.install($q, queues);
    Body.install(queues, cfg);
    Dark.install($q, queues, cfg);
    Screen.install($q, queues, cfg);
    History.install(cfg);
    Plugin.install($q, queues, opts.lang);
    iconSet.install($q, queues, opts.iconSet);

    if (isSSR === true) {
      Vue.mixin({
        beforeCreate () {
          this.$q = this.$root.$options.$q;
        }
      });
    }
    else {
      Vue.prototype.$q = $q;
    }

    opts.components && Object.keys(opts.components).forEach(key => {
      const c = opts.components[key];
      if (typeof c === 'function') {
        Vue.component(c.options.name, c);
      }
    });

    opts.directives && Object.keys(opts.directives).forEach(key => {
      const d = opts.directives[key];
      if (d.name !== void 0 && d.unbind !== void 0) {
        Vue.directive(d.name, d);
      }
    });

    if (opts.plugins) {
      const param = { $q, queues, cfg };
      Object.keys(opts.plugins).forEach(key => {
        const p = opts.plugins[key];
        if (typeof p.install === 'function' && autoInstalled.includes(p) === false) {
          p.install(param);
        }
      });
    }
  }

  const units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];

  function humanStorageSize (bytes) {
    let u = 0;

    while (parseInt(bytes, 10) >= 1024 && u < units.length - 1) {
      bytes /= 1024;
      ++u;
    }

    return `${bytes.toFixed(1)}${units[u]}`
  }

  function capitalize (str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }

  function between (v, min, max) {
    return max <= min
      ? min
      : Math.min(max, Math.max(min, v))
  }

  function normalizeToInterval (v, min, max) {
    if (max <= min) {
      return min
    }

    const size = (max - min + 1);

    let index = min + (v - min) % size;
    if (index < min) {
      index = size + index;
    }

    return index === 0 ? 0 : index // fix for (-a % a) => -0
  }

  function pad (v, length = 2, char = '0') {
    if (v === void 0 || v === null) {
      return v
    }

    const val = '' + v;
    return val.length >= length
      ? val
      : new Array(length - val.length + 1).join(char) + val
  }

  var format = {
    humanStorageSize,
    capitalize,
    between,
    normalizeToInterval,
    pad
  };

  function cache (vm, key, obj) {
    if (isSSR === true) return obj

    const k = `__qcache_${key}`;
    return vm[k] === void 0
      ? (vm[k] = obj)
      : vm[k]
  }

  function cacheWithFn (vm, key, fn) {
    if (isSSR === true) return fn()

    const k = `__qcache_${key}`;
    return vm[k] === void 0
      ? (vm[k] = fn())
      : vm[k]
  }

  function getPropCacheMixin (propName, proxyPropName) {
    return {
      data () {
        const target = {};
        const source = this[propName];

        for (const prop in source) {
          target[prop] = source[prop];
        }

        return { [proxyPropName]: target }
      },

      watch: {
        [propName] (newObj, oldObj) {
          const target = this[proxyPropName];

          if (oldObj !== void 0) {
            // we first delete obsolete events
            for (const prop in oldObj) {
              if (newObj[prop] === void 0) {
                this.$delete(target, prop);
              }
            }
          }

          for (const prop in newObj) {
            // we then update changed events
            if (target[prop] !== newObj[prop]) {
              this.$set(target, prop, newObj[prop]);
            }
          }
        }
      }
    }
  }

  const ariaHidden = { 'aria-hidden': 'true' };

  const iconAsButton = { tabindex: 0, type: 'button', 'aria-hidden': false, role: null };

  var AttrsMixin = getPropCacheMixin('$attrs', 'qAttrs');

  const
    xhr = isSSR ? null : XMLHttpRequest,
    open = isSSR ? null : xhr.prototype.open,
    positionValues = [ 'top', 'right', 'bottom', 'left' ];

  let stack = [];
  let highjackCount = 0;

  function translate ({ p, pos, active, horiz, reverse, dir }) {
    let x = 1, y = 1;

    if (horiz === true) {
      if (reverse === true) { x = -1; }
      if (pos === 'bottom') { y = -1; }
      return { transform: `translate3d(${x * (p - 100)}%,${active ? 0 : y * -200}%,0)` }
    }

    if (reverse === true) { y = -1; }
    if (pos === 'right') { x = -1; }
    return { transform: `translate3d(${active ? 0 : dir * x * -200}%,${y * (p - 100)}%,0)` }
  }

  function inc (p, amount) {
    if (typeof amount !== 'number') {
      if (p < 25) {
        amount = Math.random() * 3 + 3;
      }
      else if (p < 65) {
        amount = Math.random() * 3;
      }
      else if (p < 85) {
        amount = Math.random() * 2;
      }
      else if (p < 99) {
        amount = 0.6;
      }
      else {
        amount = 0;
      }
    }
    return between(p + amount, 0, 100)
  }

  function highjackAjax (stackEntry) {
    highjackCount++;

    stack.push(stackEntry);

    if (highjackCount > 1) { return }

    xhr.prototype.open = function (_, url) {
      const stopStack = [];

      const loadStart = () => {
        stack.forEach(entry => {
          const hijackFilter = entry.getHijackFilter();
          if (
            hijackFilter === null ||
            hijackFilter(url) === true
          ) {
            entry.start();
            stopStack.push(entry.stop);
          }
        });
      };

      const loadEnd = () => {
        stopStack.forEach(stop => { stop(); });
      };

      this.addEventListener('loadstart', loadStart, { once: true });
      this.addEventListener('loadend', loadEnd, { once: true });

      open.apply(this, arguments);
    };
  }

  function restoreAjax (start) {
    stack = stack.filter(entry => entry.start !== start);

    highjackCount = Math.max(0, highjackCount - 1);
    if (!highjackCount) {
      xhr.prototype.open = open;
    }
  }

  var QAjaxBar = Vue.extend({
    name: 'QAjaxBar',

    props: {
      position: {
        type: String,
        default: 'top',
        validator: val => positionValues.includes(val)
      },

      size: {
        type: String,
        default: '2px'
      },

      color: String,
      reverse: Boolean,

      skipHijack: Boolean,
      hijackFilter: Function
    },

    data () {
      return {
        calls: 0,
        progress: 0,
        onScreen: false,
        animate: true
      }
    },

    computed: {
      classes () {
        return `q-loading-bar q-loading-bar--${this.position}` +
          (this.color !== void 0 ? ` bg-${this.color}` : '') +
          (this.animate === true ? '' : ' no-transition')
      },

      style () {
        const active = this.onScreen;

        const o = translate({
          p: this.progress,
          pos: this.position,
          active,
          horiz: this.horizontal,
          reverse: this.$q.lang.rtl === true && ['top', 'bottom'].includes(this.position)
            ? this.reverse === false
            : this.reverse,
          dir: this.$q.lang.rtl === true ? -1 : 1
        });

        o[this.sizeProp] = this.size;
        o.opacity = active ? 1 : 0;

        return o
      },

      horizontal () {
        return this.position === 'top' || this.position === 'bottom'
      },

      sizeProp () {
        return this.horizontal ? 'height' : 'width'
      },

      attrs () {
        return this.onScreen === true
          ? {
            role: 'progressbar',
            'aria-valuemin': 0,
            'aria-valuemax': 100,
            'aria-valuenow': this.progress
          }
          : ariaHidden
      }
    },

    methods: {
      start (speed = 300) {
        const oldSpeed = this.speed;
        const newSpeed = this.speed = Math.max(0, speed) || 0;

        this.calls++;

        if (this.calls > 1) {
          if (oldSpeed === 0 && newSpeed > 0) {
            this.__work();
          }
          else if (oldSpeed > 0 && newSpeed <= 0) {
            clearTimeout(this.timer);
          }

          return this.calls
        }

        clearTimeout(this.timer);
        this.$emit('start');

        this.progress = 0;

        this.timer = setTimeout(() => {
          this.animate = true;
          newSpeed > 0 && this.__work();
        }, this.onScreen === true ? 500 : 1);

        if (this.onScreen !== true) {
          this.onScreen = true;
          this.animate = false;
        }

        return this.calls
      },

      increment (amount) {
        if (this.calls > 0) {
          this.progress = inc(this.progress, amount);
        }

        return this.calls
      },

      stop () {
        this.calls = Math.max(0, this.calls - 1);

        if (this.calls > 0) {
          return this.calls
        }

        clearTimeout(this.timer);
        this.$emit('stop');

        const end = () => {
          this.animate = true;
          this.progress = 100;
          this.timer = setTimeout(() => {
            this.onScreen = false;
          }, 1000);
        };

        if (this.progress === 0) {
          this.timer = setTimeout(end, 1);
        }
        else {
          end();
        }

        return this.calls
      },

      __work () {
        if (this.progress < 100) {
          this.timer = setTimeout(() => {
            this.increment();
            this.__work();
          }, this.speed);
        }
      }
    },

    mounted () {
      if (this.skipHijack !== true) {
        this.hijacked = true;
        highjackAjax({
          start: this.start,
          stop: this.stop,
          getHijackFilter: () => this.hijackFilter || null
        });
      }
    },

    beforeDestroy () {
      clearTimeout(this.timer);
      this.hijacked === true && restoreAjax(this.start);
    },

    render (h) {
      return h('div', {
        class: this.classes,
        style: this.style,
        attrs: this.attrs
      })
    }
  });

  const sizes = {
    xs: 18,
    sm: 24,
    md: 32,
    lg: 38,
    xl: 46
  };

  function getSizeMixin (sizes) {
    return {
      props: {
        size: String
      },

      computed: {
        sizeStyle () {
          if (this.size !== void 0) {
            return { fontSize: this.size in sizes ? `${sizes[this.size]}px` : this.size }
          }
        }
      }
    }
  }

  var SizeMixin = getSizeMixin(sizes);

  var TagMixin = {
    props: {
      tag: {
        type: String,
        default: 'div'
      }
    }
  };

  var ListenersMixin = getPropCacheMixin('$listeners', 'qListeners');

  function slot (vm, slotName, otherwise) {
    return vm.$scopedSlots[slotName] !== void 0
      ? vm.$scopedSlots[slotName]()
      : otherwise
  }

  function uniqueSlot (vm, slotName, otherwise) {
    return vm.$scopedSlots[slotName] !== void 0
      ? [].concat(vm.$scopedSlots[slotName]())
      : otherwise
  }

  /**
   * Source definitely exists,
   * so it's merged with the possible slot
   */
  function mergeSlot (source, vm, slotName) {
    return vm.$scopedSlots[slotName] !== void 0
      ? source.concat(vm.$scopedSlots[slotName]())
      : source
  }

  /**
   * Merge with possible slot,
   * even if source might not exist
   */
  function mergeSlotSafely (source, vm, slotName) {
    if (vm.$scopedSlots[slotName] === void 0) {
      return source
    }

    const slot = vm.$scopedSlots[slotName]();
    return source !== void 0
      ? source.concat(slot)
      : slot
  }

  const defaultViewBox = '0 0 24 24';

  const sameFn = i => i;
  const ionFn = i => `ionicons ${i}`;

  const libMap = {
    'mdi-': i => `mdi ${i}`,
    'icon-': sameFn, // fontawesome equiv
    'bt-': i => `bt ${i}`,
    'eva-': i => `eva ${i}`,
    'ion-md': ionFn,
    'ion-ios': ionFn,
    'ion-logo': ionFn,
    'iconfont ': sameFn,
    'ti-': i => `themify-icon ${i}`,
    'bi-': i => `bootstrap-icons ${i}`
  };

  const matMap = {
    o_: '-outlined',
    r_: '-round',
    s_: '-sharp'
  };

  const symMap = {
    sym_o_: '-outlined',
    sym_r_: '-rounded',
    sym_s_: '-sharp'
  };

  const libRE = new RegExp('^(' + Object.keys(libMap).join('|') + ')');
  const matRE = new RegExp('^(' + Object.keys(matMap).join('|') + ')');
  const symRE = new RegExp('^(' + Object.keys(symMap).join('|') + ')');
  const mRE = /^[Mm]\s?[-+]?\.?\d/;
  const imgRE = /^img:/;
  const svgUseRE = /^svguse:/;
  const ionRE = /^ion-/;
  const faRE = /^(fa-(solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /;

  var QIcon = Vue.extend({
    name: 'QIcon',

    mixins: [ ListenersMixin, SizeMixin, TagMixin ],

    props: {
      tag: {
        type: String,
        default: 'i'
      },

      name: String,
      color: String,
      left: Boolean,
      right: Boolean
    },

    computed: {
      classes () {
        return 'q-icon' +
          (this.left === true ? ' on-left' : '') +
          (this.right === true ? ' on-right' : '') +
          (this.color !== void 0 ? ` text-${this.color}` : '')
      },

      type () {
        let cls;
        let icon = this.name;

        if (icon === 'none' || !icon) {
          return { none: true }
        }

        if (this.$q.iconMapFn !== void 0) {
          const res = this.$q.iconMapFn(icon);
          if (res !== void 0) {
            if (res.icon !== void 0) {
              icon = res.icon;
              if (icon === 'none' || !icon) {
                return { none: true }
              }
            }
            else {
              return {
                cls: res.cls,
                content: res.content !== void 0
                  ? res.content
                  : ' '
              }
            }
          }
        }

        if (mRE.test(icon) === true) {
          const [ def, viewBox = defaultViewBox ] = icon.split('|');

          return {
            svg: true,
            viewBox,
            nodes: def.split('&&').map(path => {
              const [ d, style, transform ] = path.split('@@');
              return this.$createElement('path', {
                attrs: { d, transform },
                style
              })
            })
          }
        }

        if (imgRE.test(icon) === true) {
          return {
            img: true,
            src: icon.substring(4)
          }
        }

        if (svgUseRE.test(icon) === true) {
          const [ def, viewBox = defaultViewBox ] = icon.split('|');

          return {
            svguse: true,
            src: def.substring(7),
            viewBox
          }
        }

        let content = ' ';
        const matches = icon.match(libRE);

        if (matches !== null) {
          cls = libMap[ matches[ 1 ] ](icon);
        }
        else if (faRE.test(icon) === true) {
          cls = icon;
        }
        else if (ionRE.test(icon) === true) {
          cls = `ionicons ion-${this.$q.platform.is.ios === true ? 'ios' : 'md'}${icon.substr(3)}`;
        }
        else if (symRE.test(icon) === true) {
          // "notranslate" class is for Google Translate
          // to avoid tampering with Material Symbols ligature font
          //
          // Caution: To be able to add suffix to the class name,
          // keep the 'material-symbols' at the end of the string.
          cls = 'notranslate material-symbols';

          const matches = icon.match(symRE);
          if (matches !== null) {
            icon = icon.substring(6);
            cls += symMap[ matches[ 1 ] ];
          }

          content = icon;
        }
        else {
          // "notranslate" class is for Google Translate
          // to avoid tampering with Material Icons ligature font
          //
          // Caution: To be able to add suffix to the class name,
          // keep the 'material-icons' at the end of the string.
          cls = 'notranslate material-icons';

          const matches = icon.match(matRE);
          if (matches !== null) {
            icon = icon.substring(2);
            cls += matMap[ matches[ 1 ] ];
          }

          content = icon;
        }

        return {
          cls,
          content
        }
      }
    },

    render (h) {
      const data = {
        class: this.classes,
        style: this.sizeStyle,
        on: { ...this.qListeners },
        attrs: {
          'aria-hidden': 'true',
          role: 'presentation'
        }
      };

      if (this.type.none === true) {
        return h(this.tag, data, slot(this, 'default'))
      }

      if (this.type.img === true) {
        return h('span', data, mergeSlot([
          h('img', {
            attrs: { src: this.type.src }
          })
        ], this, 'default'))
      }

      if (this.type.svg === true) {
        return h('span', data, mergeSlot([
          h('svg', {
            attrs: {
              viewBox: this.type.viewBox || '0 0 24 24',
              focusable: 'false' /* needed for IE11 */
            }
          }, this.type.nodes)
        ], this, 'default'))
      }

      if (this.type.svguse === true) {
        return h('span', data, mergeSlot([
          h('svg', {
            attrs: {
              viewBox: this.type.viewBox,
              focusable: 'false' /* needed for IE11 */
            }
          }, [
            h('use', { attrs: { 'xlink:href': this.type.src } })
          ])
        ], this, 'default'))
      }

      if (this.type.cls !== void 0) {
        data.class += ' ' + this.type.cls;
      }

      return h(this.tag, data, mergeSlot([
        this.type.content
      ], this, 'default'))
    }
  });

  var QAvatar = Vue.extend({
    name: 'QAvatar',

    mixins: [ ListenersMixin, SizeMixin ],

    props: {
      fontSize: String,

      color: String,
      textColor: String,

      icon: String,
      square: Boolean,
      rounded: Boolean
    },

    computed: {
      classes () {
        return {
          [`bg-${this.color}`]: this.color,
          [`text-${this.textColor} q-chip--colored`]: this.textColor,
          'q-avatar--square': this.square,
          'rounded-borders': this.rounded
        }
      },

      contentStyle () {
        if (this.fontSize) {
          return { fontSize: this.fontSize }
        }
      }
    },

    render (h) {
      const icon = this.icon !== void 0
        ? [ h(QIcon, { props: { name: this.icon } }) ]
        : void 0;

      return h('div', {
        staticClass: 'q-avatar',
        style: this.sizeStyle,
        class: this.classes,
        on: { ...this.qListeners }
      }, [
        h('div', {
          staticClass: 'q-avatar__content row flex-center overflow-hidden',
          style: this.contentStyle
        }, mergeSlotSafely(icon, this, 'default'))
      ])
    }
  });

  var QBadge = Vue.extend({
    name: 'QBadge',

    mixins: [ ListenersMixin ],

    props: {
      color: String,
      textColor: String,

      floating: Boolean,
      transparent: Boolean,
      multiLine: Boolean,
      outline: Boolean,
      rounded: Boolean,

      label: [Number, String],

      align: {
        type: String,
        validator: v => ['top', 'middle', 'bottom'].includes(v)
      }
    },

    computed: {
      style () {
        if (this.align !== void 0) {
          return { verticalAlign: this.align }
        }
      },

      classes () {
        const text = this.outline === true
          ? this.color || this.textColor
          : this.textColor;

        return 'q-badge flex inline items-center no-wrap' +
          ` q-badge--${this.multiLine === true ? 'multi' : 'single'}-line` +
          (this.outline === true
            ? ' q-badge--outline'
            : (this.color !== void 0 ? ` bg-${this.color}` : '')
          ) +
          (text !== void 0 ? ` text-${text}` : '') +
          (this.floating === true ? ' q-badge--floating' : '') +
          (this.rounded === true ? ' q-badge--rounded' : '') +
          (this.transparent === true ? ' q-badge--transparent' : '')
      },

      attrs () {
        return {
          role: 'alert',
          'aria-label': this.label
        }
      }
    },

    render (h) {
      return h('div', {
        style: this.style,
        class: this.classes,
        attrs: this.attrs,
        on: { ...this.qListeners }
      }, this.label !== void 0 ? [ this.label ] : slot(this, 'default'))
    }
  });

  var DarkMixin = {
    props: {
      dark: {
        type: Boolean,
        default: null
      }
    },

    computed: {
      isDark () {
        return this.dark === null
          ? this.$q.dark.isActive
          : this.dark
      }
    }
  };

  const attrs = { role: 'alert' };

  var QBanner = Vue.extend({
    name: 'QBanner',

    mixins: [ ListenersMixin, DarkMixin ],

    props: {
      inlineActions: Boolean,
      dense: Boolean,
      rounded: Boolean
    },

    render (h) {
      const actions = slot(this, 'action');
      const child = [
        h('div', {
          staticClass: 'q-banner__avatar col-auto row items-center self-start'
        }, slot(this, 'avatar')),

        h('div', {
          staticClass: 'q-banner__content col text-body2'
        }, slot(this, 'default'))
      ];

      actions !== void 0 && child.push(
        h('div', {
          staticClass: 'q-banner__actions row items-center justify-end',
          class: `col-${this.inlineActions === true ? 'auto' : 'all'}`
        }, actions)
      );

      return h('div', {
        staticClass: 'q-banner row items-center',
        class: {
          'q-banner--top-padding': actions !== void 0 && !this.inlineActions,
          'q-banner--dense': this.dense,
          'q-banner--dark q-dark': this.isDark,
          'rounded-borders': this.rounded
        },
        attrs,
        on: { ...this.qListeners }
      }, child)
    }
  });

  const attrs$1 = { role: 'toolbar' };

  var QBar = Vue.extend({
    name: 'QBar',

    mixins: [ ListenersMixin, DarkMixin ],

    props: {
      dense: Boolean
    },

    computed: {
      classes () {
        return `q-bar--${this.dense === true ? 'dense' : 'standard'} ` +
          `q-bar--${this.isDark === true ? 'dark' : 'light'}`
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-bar row no-wrap items-center',
        class: this.classes,
        attrs: attrs$1,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  const
    alignMap = {
      left: 'start',
      center: 'center',
      right: 'end',
      between: 'between',
      around: 'around',
      evenly: 'evenly',
      stretch: 'stretch'
    },
    alignValues = Object.keys(alignMap);

  var AlignMixin = {
    props: {
      align: {
        type: String,
        validator: v => alignValues.includes(v)
      }
    },

    computed: {
      alignClass () {
        const align = this.align === void 0
          ? (this.vertical === true ? 'stretch' : 'left')
          : this.align;

        return `${this.vertical === true ? 'items' : 'justify'}-${alignMap[align]}`
      }
    }
  };

  const disabledValues = [ true, '' ];

  var QBreadcrumbs = Vue.extend({
    name: 'QBreadcrumbs',

    mixins: [ ListenersMixin, AlignMixin ],

    props: {
      separator: {
        type: String,
        default: '/'
      },
      separatorColor: String,

      activeColor: {
        type: String,
        default: 'primary'
      },

      gutter: {
        type: String,
        validator: v => ['none', 'xs', 'sm', 'md', 'lg', 'xl'].includes(v),
        default: 'sm'
      }
    },

    computed: {
      classes () {
        return `${this.alignClass}${this.gutter === 'none' ? '' : ` q-gutter-${this.gutter}`}`
      },

      sepClass () {
        return this.separatorColor
          ? ` text-${this.separatorColor}`
          : ''
      },

      activeClass () {
        return ` text-${this.activeColor}`
      }
    },

    render (h) {
      const nodes = slot(this, 'default');
      if (nodes === void 0) { return }

      let els = 1;

      const
        child = [],
        len = nodes.filter(c => c.tag !== void 0 && c.tag.endsWith('-QBreadcrumbsEl')).length,
        separator = this.$scopedSlots.separator !== void 0
          ? this.$scopedSlots.separator
          : () => this.separator;

      nodes.forEach(comp => {
        if (comp.tag !== void 0 && comp.tag.endsWith('-QBreadcrumbsEl')) {
          const middle = els < len;
          const disabled = disabledValues.includes(comp.componentOptions.propsData.disable);
          const cls = middle === true
            ? (disabled !== true ? this.activeClass : '')
            : ' q-breadcrumbs--last';

          els++;

          child.push(h('div', {
            staticClass: 'flex items-center' + cls
          }, [ comp ]));

          middle === true && child.push(h('div', {
            staticClass: 'q-breadcrumbs__separator' + this.sepClass
          }, separator()));
        }
        else {
          child.push(comp);
        }
      });

      return h('div', {
        staticClass: 'q-breadcrumbs',
        on: { ...this.qListeners }
      }, [
        h('div', {
          staticClass: 'flex items-center',
          class: this.classes
        }, child)
      ])
    }
  });

  const routerLinkProps = {
    // router-link
    to: [String, Object],
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: {
      type: String,
      default: 'q-router-link--active'
    },
    exactActiveClass: {
      type: String,
      default: 'q-router-link--exact-active'
    },

    // regular <a> link
    href: String,
    target: String,

    // state
    disable: Boolean
  };

  // external props: type, tag
  // external: fallbackTag

  var RouterLinkMixin = {
    props: routerLinkProps,

    computed: {
      hasHrefLink () {
        return this.disable !== true && this.href !== void 0
      },

      hasRouterLinkProps () {
        return this.$router !== void 0 &&
          this.disable !== true &&
          this.hasHrefLink !== true &&
          this.to !== void 0 && this.to !== null && this.to !== ''
      },

      linkRoute () {
        if (this.hasRouterLinkProps === true) {
          // we protect from accessing this.$route without
          // actually needing it so that we won't trigger
          // unnecessary updates

          try {
            return this.append === true
              ? this.$router.resolve(this.to, this.$route, true)
              : this.$router.resolve(this.to)
          }
          catch (err) {}
        }

        return null
      },

      hasRouterLink () {
        return this.linkRoute !== null
      },

      hasLink () {
        return this.hasHrefLink === true || this.hasRouterLink === true
      },

      linkTag () {
        if (this.hasRouterLink === true) {
          return 'router-link'
        }

        return this.type === 'a' || this.hasLink === true
          ? 'a'
          : (this.tag || this.fallbackTag || 'div')
      },

      linkProps () {
        return this.hasHrefLink === true
          ? {
            attrs: {
              href: this.href,
              target: this.target
            }
          }
          : (
            this.hasRouterLink === true
              ? {
                props: {
                  to: this.to,
                  exact: this.exact,
                  append: this.append,
                  replace: this.replace,
                  activeClass: this.activeClass,
                  exactActiveClass: this.exactActiveClass
                },
                attrs: {
                  href: this.linkRoute.href,
                  target: this.target
                }
              }
              : {}
          )
      }
    }
  };

  var QBreadcrumbsEl = Vue.extend({
    name: 'QBreadcrumbsEl',

    mixins: [ ListenersMixin, RouterLinkMixin ],

    props: {
      label: String,
      icon: String
    },

    computed: {
      iconClass () {
        return 'q-breadcrumbs__el-icon' +
          (this.label !== void 0 ? ' q-breadcrumbs__el-icon--with-label' : '')
      },

      renderData () {
        return {
          staticClass: 'q-breadcrumbs__el q-link ' +
            'flex inline items-center relative-position ' +
            (this.disable !== true ? 'q-link--focusable' : 'q-breadcrumbs__el--disabled'),
          ...this.linkProps,
          [this.hasRouterLink === true ? 'nativeOn' : 'on']: { ...this.qListeners }
        }
      }
    },

    beforeCreate () {
      this.fallbackTag = 'span';
    },

    render (h) {
      const child = [];

      this.icon !== void 0 && child.push(
        h(QIcon, {
          class: this.iconClass,
          props: { name: this.icon }
        })
      );

      this.label !== void 0 && child.push(this.label);

      return h(this.linkTag, this.renderData, mergeSlot(child, this, 'default'))
    }
  });

  var mixin = {
    mixins: [ ListenersMixin ],

    props: {
      color: String,
      size: {
        type: [Number, String],
        default: '1em'
      }
    },

    computed: {
      cSize () {
        return this.size in sizes
          ? `${sizes[this.size]}px`
          : this.size
      },

      classes () {
        if (this.color) {
          return `text-${this.color}`
        }
      }
    }
  };

  var QSpinner = Vue.extend({
    name: 'QSpinner',

    mixins: [ mixin ],

    props: {
      thickness: {
        type: Number,
        default: 5
      }
    },

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner q-spinner-mat',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '25 25 50 50'
        }
      }, [
        h('circle', {
          staticClass: 'path',
          attrs: {
            'cx': '50',
            'cy': '50',
            'r': '20',
            'fill': 'none',
            'stroke': 'currentColor',
            'stroke-width': this.thickness,
            'stroke-miterlimit': '10'
          }
        })
      ])
    }
  });

  function offset (el) {
    if (el === window) {
      return { top: 0, left: 0 }
    }
    const { top, left } = el.getBoundingClientRect();
    return { top, left }
  }

  function style (el, property) {
    return window.getComputedStyle(el).getPropertyValue(property)
  }

  function height (el) {
    return el === window
      ? window.innerHeight
      : el.getBoundingClientRect().height
  }

  function width (el) {
    return el === window
      ? window.innerWidth
      : el.getBoundingClientRect().width
  }

  function css (element, css) {
    const style = element.style;

    Object.keys(css).forEach(prop => {
      style[prop] = css[prop];
    });
  }

  function cssBatch (elements, style) {
    elements.forEach(el => css(el, style));
  }

  function ready (fn) {
    if (typeof fn !== 'function') {
      return
    }

    if (document.readyState !== 'loading') {
      return fn()
    }

    document.addEventListener('DOMContentLoaded', fn, false);
  }

  // internal
  function getElement (el) {
    const type = typeof el;

    if (type === 'function') {
      el = el();
    }

    if (type === 'string') {
      try {
        el = document.querySelector(el);
      }
      catch (err) {}
    }

    if (el !== Object(el)) {
      return null
    }

    return el._isVue === true && el.$el !== void 0
      ? el.$el
      : el
  }

  // internal
  function childHasFocus (el, focusedEl) {
    if (el === void 0 || el.contains(focusedEl) === true) {
      return true
    }

    for (let next = el.nextElementSibling; next !== null; next = next.nextElementSibling) {
      if (next.contains(focusedEl)) {
        return true
      }
    }

    return false
  }

  // internal
  function getBodyFullscreenElement (activeEl) {
    return activeEl === document.documentElement || activeEl === null
      ? document.body
      : activeEl
  }

  var dom = {
    offset,
    style,
    height,
    width,
    css,
    cssBatch,
    ready
  };

  function throttle (fn, limit = 250) {
    let wait = false, result;

    return function (/* ...args */) {
      if (wait === false) {
        wait = true;
        setTimeout(() => { wait = false; }, limit);
        result = fn.apply(this, arguments);
      }

      return result
    }
  }

  function showRipple (evt, el, ctx, forceCenter) {
    ctx.modifiers.stop === true && stop(evt);

    const color = ctx.modifiers.color;
    let center = ctx.modifiers.center;
    center = center === true || forceCenter === true;

    const
      node = document.createElement('span'),
      innerNode = document.createElement('span'),
      pos = position(evt),
      { left, top, width, height } = el.getBoundingClientRect(),
      diameter = Math.sqrt(width * width + height * height),
      radius = diameter / 2,
      centerX = `${(width - diameter) / 2}px`,
      x = center ? centerX : `${pos.left - left - radius}px`,
      centerY = `${(height - diameter) / 2}px`,
      y = center ? centerY : `${pos.top - top - radius}px`;

    innerNode.className = 'q-ripple__inner';
    css(innerNode, {
      height: `${diameter}px`,
      width: `${diameter}px`,
      transform: `translate3d(${x},${y},0) scale3d(.2,.2,1)`,
      opacity: 0
    });

    node.className = `q-ripple${color ? ' text-' + color : ''}`;
    node.setAttribute('dir', 'ltr');
    node.appendChild(innerNode);
    el.appendChild(node);

    const abort = () => {
      node.remove();
      clearTimeout(timer);
    };
    ctx.abort.push(abort);

    let timer = setTimeout(() => {
      innerNode.classList.add('q-ripple__inner--enter');
      innerNode.style.transform = `translate3d(${centerX},${centerY},0) scale3d(1,1,1)`;
      innerNode.style.opacity = 0.2;

      timer = setTimeout(() => {
        innerNode.classList.remove('q-ripple__inner--enter');
        innerNode.classList.add('q-ripple__inner--leave');
        innerNode.style.opacity = 0;

        timer = setTimeout(() => {
          node.remove();
          ctx.abort.splice(ctx.abort.indexOf(abort), 1);
        }, 275);
      }, 250);
    }, 50);
  }

  function updateModifiers (ctx, { modifiers, value, arg }) {
    const cfg = Object.assign({}, $q.config.ripple, modifiers, value);
    ctx.modifiers = {
      early: cfg.early === true,
      stop: cfg.stop === true,
      center: cfg.center === true,
      color: cfg.color || arg,
      keyCodes: [].concat(cfg.keyCodes || 13)
    };
  }

  function destroy (el) {
    const ctx = el.__qripple;
    if (ctx !== void 0) {
      ctx.abort.forEach(fn => { fn(); });
      cleanEvt(ctx, 'main');
      delete el._qripple;
    }
  }

  var Ripple = {
    name: 'ripple',

    inserted (el, binding) {
      if (el.__qripple !== void 0) {
        destroy(el);
        el.__qripple_destroyed = true;
      }

      const ctx = {
        enabled: binding.value !== false,
        modifiers: {},
        abort: [],

        start (evt) {
          if (
            ctx.enabled === true &&
            evt.qSkipRipple !== true &&
            // on ENTER in form IE emits a PointerEvent with negative client cordinates
            (client.is.ie !== true || evt.clientX >= 0) &&
            evt.type === (ctx.modifiers.early === true ? 'pointerdown' : 'click')
          ) {
            showRipple(evt, el, ctx, evt.qKeyEvent === true);
          }
        },

        keystart: throttle(evt => {
          if (
            ctx.enabled === true &&
            evt.qSkipRipple !== true &&
            isKeyCode(evt, ctx.modifiers.keyCodes) === true &&
            evt.type === `key${ctx.modifiers.early === true ? 'down' : 'up'}`
          ) {
            showRipple(evt, el, ctx, true);
          }
        }, 300)
      };

      updateModifiers(ctx, binding);

      el.__qripple = ctx;

      addEvt(ctx, 'main', [
        [ el, 'pointerdown', 'start', 'passive' ],
        [ el, 'click', 'start', 'passive' ],
        [ el, 'keydown', 'keystart', 'passive' ],
        [ el, 'keyup', 'keystart', 'passive' ]
      ]);
    },

    update (el, binding) {
      const ctx = el.__qripple;
      if (ctx !== void 0 && binding.oldValue !== binding.value) {
        ctx.enabled = binding.value !== false;

        if (ctx.enabled === true && Object(binding.value) === binding.value) {
          updateModifiers(ctx, binding);
        }
      }
    },

    unbind (el) {
      if (el.__qripple_destroyed === void 0) {
        destroy(el);
      }
      else {
        delete el.__qripple_destroyed;
      }
    }
  };

  var RippleMixin = {
    directives: {
      Ripple
    },

    props: {
      ripple: {
        type: [Boolean, Object],
        default: true
      }
    }
  };

  const padding = {
    none: 0,
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32
  };

  const formTypes = [ 'button', 'submit', 'reset' ];
  const mediaTypeRe = /[^\s]\/[^\s]/;

  var BtnMixin = {
    mixins: [
      ListenersMixin,
      RippleMixin,
      RouterLinkMixin,
      AlignMixin,
      getSizeMixin({
        xs: 8,
        sm: 10,
        md: 14,
        lg: 20,
        xl: 24
      })
    ],

    props: {
      type: {
        type: String,
        default: 'button'
      },

      to: [ Object, String ],
      replace: Boolean,
      append: Boolean,

      label: [ Number, String ],
      icon: String,
      iconRight: String,

      round: Boolean,
      outline: Boolean,
      flat: Boolean,
      unelevated: Boolean,
      rounded: Boolean,
      push: Boolean,
      glossy: Boolean,

      size: String,
      fab: Boolean,
      fabMini: Boolean,
      padding: String,

      color: String,
      textColor: String,
      noCaps: Boolean,
      noWrap: Boolean,
      dense: Boolean,

      tabindex: [ Number, String ],

      align: { default: 'center' },
      stack: Boolean,
      stretch: Boolean,
      loading: {
        type: Boolean,
        default: null
      },
      disable: Boolean
    },

    computed: {
      style () {
        if (this.fab === false && this.fabMini === false) {
          return this.sizeStyle
        }
      },

      isRounded () {
        return this.rounded === true || this.fab === true || this.fabMini === true
      },

      isActionable () {
        return this.disable !== true && this.loading !== true
      },

      computedTabIndex () {
        return this.isActionable === true ? this.tabindex || 0 : -1
      },

      design () {
        if (this.flat === true) return 'flat'
        if (this.outline === true) return 'outline'
        if (this.push === true) return 'push'
        if (this.unelevated === true) return 'unelevated'
        return 'standard'
      },

      attrs () {
        const acc = { tabindex: this.computedTabIndex };

        if (this.hasLink === true) {
          Object.assign(acc, this.linkProps.attrs);
        }
        else if (formTypes.includes(this.type) === true) {
          acc.type = this.type;
        }

        if (this.hasLink === true || this.type === 'a') {
          if (this.disable === true) {
            acc['aria-disabled'] = 'true';
          }
          else if (acc.href === void 0) {
            acc.role = 'button';
          }
          if (mediaTypeRe.test(this.type) === true) {
            acc.type = this.type;
          }
        }
        else if (this.disable === true) {
          acc.disabled = '';
          acc['aria-disabled'] = 'true';
        }

        if (this.loading === true && this.percentage !== void 0) {
          acc.role = 'progressbar';
          acc['aria-valuemin'] = 0;
          acc['aria-valuemax'] = 100;
          acc['aria-valuenow'] = this.percentage;
        }

        return acc
      },

      classes () {
        let colors;

        if (this.color !== void 0) {
          if (this.flat === true || this.outline === true) {
            colors = `text-${this.textColor || this.color}`;
          }
          else {
            colors = `bg-${this.color} text-${this.textColor || 'white'}`;
          }
        }
        else if (this.textColor) {
          colors = `text-${this.textColor}`;
        }

        return `q-btn--${this.design} ` +
          `q-btn--${this.round === true ? 'round' : `rectangle${this.isRounded === true ? ' q-btn--rounded' : ''}`}` +
          (colors !== void 0 ? ' ' + colors : '') +
          (this.isActionable === true ? ' q-btn--actionable q-focusable q-hoverable' : (this.disable === true ? ' disabled' : '')) +
          (this.fab === true ? ' q-btn--fab' : (this.fabMini === true ? ' q-btn--fab-mini' : '')) +
          (this.noCaps === true ? ' q-btn--no-uppercase' : '') +
          (this.noWrap === true ? '' : ' q-btn--wrap') + // this is for IE11
          (this.dense === true ? ' q-btn--dense' : '') +
          (this.stretch === true ? ' no-border-radius self-stretch' : '') +
          (this.glossy === true ? ' glossy' : '')
      },

      innerClasses () {
        return this.alignClass + (this.stack === true ? ' column' : ' row') +
          (this.noWrap === true ? ' no-wrap text-no-wrap' : '') +
          (this.loading === true ? ' q-btn__content--hidden' : '')
      },

      wrapperStyle () {
        if (this.padding !== void 0) {
          return {
            padding: this.padding
              .split(/\s+/)
              .map(v => v in padding ? padding[v] + 'px' : v)
              .join(' '),
            minWidth: '0',
            minHeight: '0'
          }
        }
      }
    }
  };

  const { passiveCapture } = listenOpts;

  let
    touchTarget = void 0,
    keyboardTarget = void 0,
    mouseTarget = void 0;

  const iconAttrs = { role: 'img', 'aria-hidden': 'true' };

  var QBtn = Vue.extend({
    name: 'QBtn',

    mixins: [ BtnMixin ],

    props: {
      percentage: Number,
      darkPercentage: Boolean
    },

    computed: {
      hasLabel () {
        return this.label !== void 0 && this.label !== null && this.label !== ''
      },

      computedRipple () {
        return this.ripple === false
          ? false
          : {
            keyCodes: this.hasLink === true ? [ 13, 32 ] : [ 13 ],
            ...(this.ripple === true ? {} : this.ripple)
          }
      },

      percentageStyle () {
        const val = Math.max(0, Math.min(100, this.percentage));
        if (val > 0) {
          return { transition: 'transform 0.6s', transform: `translateX(${val - 100}%)` }
        }
      },

      onEvents () {
        if (this.loading === true) {
          return {
            mousedown: this.__onLoadingEvt,
            touchstart: this.__onLoadingEvt,
            click: this.__onLoadingEvt,
            keydown: this.__onLoadingEvt,
            keyup: this.__onLoadingEvt
          }
        }

        if (this.isActionable === true) {
          const on = {
            ...this.qListeners,
            click: this.click,
            keydown: this.__onKeydown,
            mousedown: this.__onMousedown
          };

          if (this.$q.platform.has.touch === true) {
            on.touchstart = this.__onTouchstart;
          }

          return on
        }

        return {
          // needed; especially for disabled <a> tags
          click: stopAndPrevent
        }
      },

      directives () {
        if (this.disable !== true && this.ripple !== false) {
          return [{
            name: 'ripple',
            value: this.computedRipple,
            modifiers: { center: this.round }
          }]
        }
      }
    },

    methods: {
      click (e) {
        if (e !== void 0) {
          if (e.defaultPrevented === true) {
            return
          }

          const el = document.activeElement;
          // focus button if it came from ENTER on form
          // prevent the new submit (already done)
          if (
            this.type === 'submit' &&
            (
              (this.$q.platform.is.ie === true && (e.clientX < 0 || e.clientY < 0)) ||
              (
                el !== document.body &&
                this.$el.contains(el) === false &&
                // required for iOS and desktop Safari
                el.contains(this.$el) === false
              )
            )
          ) {
            this.$el.focus();

            const onClickCleanup = () => {
              document.removeEventListener('keydown', stopAndPrevent, true);
              document.removeEventListener('keyup', onClickCleanup, passiveCapture);
              this.$el !== void 0 && this.$el.removeEventListener('blur', onClickCleanup, passiveCapture);
            };

            document.addEventListener('keydown', stopAndPrevent, true);
            document.addEventListener('keyup', onClickCleanup, passiveCapture);
            this.$el.addEventListener('blur', onClickCleanup, passiveCapture);
          }

          if (this.hasRouterLink === true) {
            if (
              e.ctrlKey === true ||
              e.shiftKey === true ||
              e.altKey === true ||
              e.metaKey === true
            ) {
              // if it has meta keys, let vue-router link
              // handle this by its own
              return
            }

            stopAndPrevent(e);
          }
        }

        const go = () => {
          // vue-router now throwing error if navigating
          // to the same route that the user is currently at
          // https://github.com/vuejs/vue-router/issues/2872
          this.$router[this.replace === true ? 'replace' : 'push'](this.linkRoute.route, void 0, noop);
        };

        this.$emit('click', e, go);
        this.hasRouterLink === true && e.navigate !== false && go();
      },

      __onKeydown (e) {
        this.$emit('keydown', e);

        if (isKeyCode(e, [ 13, 32 ]) === true) {
          if (keyboardTarget !== this.$el) {
            keyboardTarget !== void 0 && this.__cleanup();

            if (e.defaultPrevented !== true) {
              // focus external button if the focus helper was focused before
              this.$el.focus();

              keyboardTarget = this.$el;
              this.$el.classList.add('q-btn--active');
              document.addEventListener('keyup', this.__onPressEnd, true);
              this.$el.addEventListener('blur', this.__onPressEnd, passiveCapture);
            }
          }

          stopAndPrevent(e);
        }
      },

      __onTouchstart (e) {
        this.$emit('touchstart', e);

        if (touchTarget !== this.$el) {
          touchTarget !== void 0 && this.__cleanup();

          if (e.defaultPrevented !== true) {
            touchTarget = this.$el;
            const target = this.touchTargetEl = e.target;
            target.addEventListener('touchcancel', this.__onPressEnd, passiveCapture);
            target.addEventListener('touchend', this.__onPressEnd, passiveCapture);
          }
        }

        // avoid duplicated mousedown event
        // triggering another early ripple
        this.avoidMouseRipple = true;
        clearTimeout(this.mouseTimer);
        this.mouseTimer = setTimeout(() => {
          this.avoidMouseRipple = false;
        }, 200);
      },

      __onMousedown (e) {
        e.qSkipRipple = this.avoidMouseRipple === true;
        this.$emit('mousedown', e);

        if (mouseTarget !== this.$el) {
          mouseTarget !== void 0 && this.__cleanup();

          if (e.defaultPrevented !== true) {
            mouseTarget = this.$el;
            this.$el.classList.add('q-btn--active');
            document.addEventListener('mouseup', this.__onPressEnd, passiveCapture);
          }
        }
      },

      __onPressEnd (e) {
        // needed for IE (because it emits blur when focusing button from focus helper)
        if (e !== void 0 && e.type === 'blur' && document.activeElement === this.$el) {
          return
        }

        if (e !== void 0 && e.type === 'keyup') {
          if (keyboardTarget === this.$el && isKeyCode(e, [ 13, 32 ]) === true) {
            // for click trigger
            const evt = new MouseEvent('click', e);
            evt.qKeyEvent = true;
            e.defaultPrevented === true && prevent(evt);
            e.cancelBubble === true && stop(evt);
            this.$el.dispatchEvent(evt);

            stopAndPrevent(e);

            // for ripple
            e.qKeyEvent = true;
          }

          this.$emit('keyup', e);
        }

        this.__cleanup();
      },

      __cleanup (destroying) {
        const blurTarget = this.$refs.blurTarget;

        if (
          destroying !== true &&
          (touchTarget === this.$el || mouseTarget === this.$el) &&
          blurTarget !== void 0 &&
          blurTarget !== document.activeElement
        ) {
          blurTarget.setAttribute('tabindex', -1);
          blurTarget.focus();
        }

        if (touchTarget === this.$el) {
          const target = this.touchTargetEl;
          target.removeEventListener('touchcancel', this.__onPressEnd, passiveCapture);
          target.removeEventListener('touchend', this.__onPressEnd, passiveCapture);
          touchTarget = this.touchTargetEl = void 0;
        }

        if (mouseTarget === this.$el) {
          document.removeEventListener('mouseup', this.__onPressEnd, passiveCapture);
          mouseTarget = void 0;
        }

        if (keyboardTarget === this.$el) {
          document.removeEventListener('keyup', this.__onPressEnd, true);
          this.$el !== void 0 && this.$el.removeEventListener('blur', this.__onPressEnd, passiveCapture);
          keyboardTarget = void 0;
        }

        this.$el !== void 0 && this.$el.classList.remove('q-btn--active');
      },

      __onLoadingEvt (evt) {
        stopAndPrevent(evt);
        evt.qSkipRipple = true;
      }
    },

    beforeDestroy () {
      this.__cleanup(true);
    },

    render (h) {
      let inner = [];

      this.icon !== void 0 && inner.push(
        h(QIcon, {
          attrs: iconAttrs,
          props: { name: this.icon, left: this.stack === false && this.hasLabel === true }
        })
      );

      this.hasLabel === true && inner.push(
        h('span', { staticClass: 'block' }, [ this.label ])
      );

      inner = mergeSlot(inner, this, 'default');

      if (this.iconRight !== void 0 && this.round === false) {
        inner.push(
          h(QIcon, {
            attrs: iconAttrs,
            props: { name: this.iconRight, right: this.stack === false && this.hasLabel === true }
          })
        );
      }

      const child = [
        h('span', {
          staticClass: 'q-focus-helper',
          ref: 'blurTarget'
        })
      ];

      if (this.loading === true && this.percentage !== void 0) {
        child.push(
          h('span', {
            staticClass: 'q-btn__progress absolute-full overflow-hidden',
            class: this.darkPercentage === true ? 'q-btn__progress--dark' : ''
          }, [
            h('span', {
              staticClass: 'q-btn__progress-indicator fit block',
              style: this.percentageStyle
            })
          ])
        );
      }

      child.push(
        h('span', {
          staticClass: 'q-btn__wrapper col row q-anchor--skip',
          style: this.wrapperStyle
        }, [
          h('span', {
            staticClass: 'q-btn__content text-center col items-center q-anchor--skip',
            class: this.innerClasses
          }, inner)
        ])
      );

      this.loading !== null && child.push(
        h('transition', {
          props: { name: 'q-transition--fade' }
        }, this.loading === true ? [
          h('span', {
            key: 'loading',
            staticClass: 'absolute-full flex flex-center'
          }, this.$scopedSlots.loading !== void 0 ? this.$scopedSlots.loading() : [ h(QSpinner) ])
        ] : void 0)
      );

      return h(this.hasLink === true || this.type === 'a' ? 'a' : 'button', {
        staticClass: 'q-btn q-btn-item non-selectable no-outline',
        class: this.classes,
        style: this.style,
        attrs: this.attrs,
        on: this.onEvents,
        directives: this.directives
      }, child)
    }
  });

  var QBtnGroup = Vue.extend({
    name: 'QBtnGroup',

    mixin: [ ListenersMixin ],

    props: {
      unelevated: Boolean,
      outline: Boolean,
      flat: Boolean,
      rounded: Boolean,
      push: Boolean,
      stretch: Boolean,
      glossy: Boolean,
      spread: Boolean
    },

    computed: {
      classes () {
        return ['unelevated', 'outline', 'flat', 'rounded', 'push', 'stretch', 'glossy']
          .filter(t => this[t] === true)
          .map(t => `q-btn-group--${t}`).join(' ')
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-btn-group row no-wrap ' +
          (this.spread === true ? 'q-btn-group--spread' : 'inline'),
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  function clearSelection () {
    if (window.getSelection !== void 0) {
      const selection = window.getSelection();
      if (selection.empty !== void 0) {
        selection.empty();
      }
      else if (selection.removeAllRanges !== void 0) {
        selection.removeAllRanges();
        Platform.is.mobile !== true && selection.addRange(document.createRange());
      }
    }
    else if (document.selection !== void 0) {
      document.selection.empty();
    }
  }

  var AnchorMixin = {
    props: {
      target: {
        default: true
      },
      noParentEvent: Boolean,
      contextMenu: Boolean
    },

    watch: {
      contextMenu (val) {
        if (this.anchorEl !== void 0) {
          this.__unconfigureAnchorEl();
          this.__configureAnchorEl(val);
        }
      },

      target () {
        if (this.anchorEl !== void 0) {
          this.__unconfigureAnchorEl();
        }

        this.__pickAnchorEl();
      },

      noParentEvent (val) {
        if (this.anchorEl !== void 0) {
          if (val === true) {
            this.__unconfigureAnchorEl();
          }
          else {
            this.__configureAnchorEl();
          }
        }
      }
    },

    methods: {
      __showCondition (evt) {
        // abort with no parent configured or on multi-touch
        if (this.anchorEl === void 0) {
          return false
        }
        if (evt === void 0) {
          return true
        }
        return evt.touches === void 0 || evt.touches.length <= 1
      },

      __contextClick (evt) {
        this.hide(evt);
        this.$nextTick(() => {
          this.show(evt);
        });
        prevent(evt);
      },

      __toggleKey (evt) {
        isKeyCode(evt, 13) === true && this.toggle(evt);
      },

      __mobileCleanup (evt) {
        this.anchorEl.classList.remove('non-selectable');
        clearTimeout(this.touchTimer);

        if (this.showing === true && evt !== void 0) {
          clearSelection();
        }
      },

      __mobilePrevent: prevent,

      __mobileTouch (evt) {
        this.__mobileCleanup(evt);

        if (this.__showCondition(evt) !== true) {
          return
        }

        this.hide(evt);
        this.anchorEl.classList.add('non-selectable');

        const target = evt.target;
        addEvt(this, 'anchor', [
          [ target, 'touchmove', '__mobileCleanup', 'passive' ],
          [ target, 'touchend', '__mobileCleanup', 'passive' ],
          [ target, 'touchcancel', '__mobileCleanup', 'passive' ],
          [ this.anchorEl, 'contextmenu', '__mobilePrevent', 'notPassive' ]
        ]);

        this.touchTimer = setTimeout(() => {
          this.show(evt);
        }, 300);
      },

      __unconfigureAnchorEl () {
        cleanEvt(this, 'anchor');
      },

      __configureAnchorEl (context = this.contextMenu) {
        if (this.noParentEvent === true || this.anchorEl === void 0) { return }

        let evts;

        if (context === true) {
          if (this.$q.platform.is.mobile === true) {
            evts = [
              [ this.anchorEl, 'touchstart', '__mobileTouch', 'passive' ]
            ];
          }
          else {
            evts = [
              [ this.anchorEl, 'click', 'hide', 'passive' ],
              [ this.anchorEl, 'contextmenu', '__contextClick', 'notPassive' ]
            ];
          }
        }
        else {
          evts = [
            [ this.anchorEl, 'click', 'toggle', 'passive' ],
            [ this.anchorEl, 'keyup', '__toggleKey', 'passive' ]
          ];
        }

        addEvt(this, 'anchor', evts);
      },

      __setAnchorEl (el) {
        this.anchorEl = el;
        while (this.anchorEl.classList.contains('q-anchor--skip')) {
          this.anchorEl = this.anchorEl.parentNode;
        }
        this.__configureAnchorEl();
      },

      __pickAnchorEl () {
        if (this.target === false || this.target === '' || this.parentEl === null) {
          this.anchorEl = void 0;
        }
        else if (this.target === true) {
          this.__setAnchorEl(this.parentEl);
        }
        else {
          this.anchorEl = getElement(this.target) || void 0;

          if (this.anchorEl !== void 0) {
            this.__configureAnchorEl();
          }
          else {
            console.error(`Anchor: target "${this.target}" not found`, this);
          }
        }
      },

      __changeScrollEvent (scrollTarget, fn) {
        const fnProp = `${fn !== void 0 ? 'add' : 'remove'}EventListener`;
        const fnHandler = fn !== void 0 ? fn : this.__scrollFn;

        if (scrollTarget !== window) {
          scrollTarget[fnProp]('scroll', fnHandler, listenOpts.passive);
        }

        window[fnProp]('scroll', fnHandler, listenOpts.passive);

        this.__scrollFn = fn;
      }
    },

    created () {
      if (
        typeof this.__configureScrollTarget === 'function' &&
        typeof this.__unconfigureScrollTarget === 'function'
      ) {
        this.noParentEventWatcher = this.$watch('noParentEvent', () => {
          if (this.__scrollTarget !== void 0) {
            this.__unconfigureScrollTarget();
            this.__configureScrollTarget();
          }
        });
      }
    },

    mounted () {
      this.parentEl = this.$el.parentNode;
      this.__pickAnchorEl();

      if (this.value === true && this.anchorEl === void 0) {
        this.$emit('input', false);
      }
    },

    beforeDestroy () {
      clearTimeout(this.touchTimer);
      this.noParentEventWatcher !== void 0 && this.noParentEventWatcher();
      this.__anchorCleanup !== void 0 && this.__anchorCleanup();
      this.__unconfigureAnchorEl();
    }
  };

  var TimeoutMixin = {
    methods: {
      __nextTick (fn) {
        this.__tickFn = fn;
      },

      __prepareTick () {
        if (this.__tickFn !== void 0) {
          const fn = this.__tickFn;
          this.$nextTick(() => {
            if (this.__tickFn === fn) {
              this.__tickFn();
              this.__tickFn = void 0;
            }
          });
        }
      },

      __clearTick () {
        this.__tickFn = void 0;
      },

      __setTimeout (fn, delay) {
        clearTimeout(this.__timer);
        this.__timer = setTimeout(fn, delay);
      },

      __clearTimeout () {
        clearTimeout(this.__timer);
      }
    },

    beforeDestroy () {
      this.__tickFn = void 0;
      clearTimeout(this.__timer);
    }
  };

  var ModelToggleMixin = {
    mixins: [ TimeoutMixin, ListenersMixin ],

    props: {
      value: {
        type: Boolean,
        default: void 0
      }
    },

    data () {
      return {
        showing: false
      }
    },

    watch: {
      value (val) {
        this.__processModelChange(val);
      },

      $route () {
        this.hideOnRouteChange === true && this.showing === true && this.hide();
      }
    },

    methods: {
      toggle (evt) {
        this[this.showing === true ? 'hide' : 'show'](evt);
      },

      show (evt) {
        if (this.disable === true || (this.__showCondition !== void 0 && this.__showCondition(evt) !== true)) {
          return
        }

        if (this.qListeners.input !== void 0 && isSSR === false) {
          this.$emit('input', true);
          this.payload = evt;
          this.$nextTick(() => {
            if (this.payload === evt) {
              this.payload = void 0;
            }
          });
        }

        if (this.value === void 0 || this.qListeners.input === void 0 || isSSR === true) {
          this.__processShow(evt);
        }
      },

      __processShow (evt) {
        if (this.showing === true) {
          return
        }

        // need to call it before setting showing to true
        // in order to not ruin the animation
        this.__preparePortal !== void 0 && this.__preparePortal();

        this.showing = true;

        this.$emit('before-show', evt);

        if (this.__show !== void 0) {
          this.__clearTick();
          this.__show(evt);
          this.__prepareTick();
        }
        else {
          this.$emit('show', evt);
        }
      },

      hide (evt) {
        if (this.disable === true) {
          return
        }

        if (this.qListeners.input !== void 0 && isSSR === false) {
          this.$emit('input', false);
          this.payload = evt;
          this.$nextTick(() => {
            if (this.payload === evt) {
              this.payload = void 0;
            }
          });
        }
        if (this.value === void 0 || this.qListeners.input === void 0 || isSSR === true) {
          this.__processHide(evt);
        }
      },

      __processHide (evt) {
        if (this.showing === false) {
          return
        }

        this.showing = false;

        this.$emit('before-hide', evt);

        if (this.__hide !== void 0) {
          this.__clearTick();
          this.__hide(evt);
          this.__prepareTick();
        }
        else {
          this.$emit('hide', evt);
        }
      },

      __processModelChange (val) {
        if (this.disable === true && val === true) {
          this.qListeners.input !== void 0 && this.$emit('input', false);
        }
        else if ((val === true) !== this.showing) {
          this[`__process${val === true ? 'Show' : 'Hide'}`](this.payload);
        }
      }
    }
  };

  let queue = [];
  let waitFlags = [];

  function clearFlag (flag) {
    waitFlags = waitFlags.filter(entry => entry !== flag);
  }

  function addFocusWaitFlag (flag) {
    clearFlag(flag);
    waitFlags.push(flag);
  }

  function removeFocusWaitFlag (flag) {
    clearFlag(flag);

    if (waitFlags.length === 0 && queue.length > 0) {
      // only call last focus handler (can't focus multiple things at once)
      queue[ queue.length - 1 ]();
      queue = [];
    }
  }

  function addFocusFn (fn) {
    if (waitFlags.length === 0) {
      fn();
    }
    else {
      queue.push(fn);
    }
  }

  function removeFocusFn (fn) {
    queue = queue.filter(entry => entry !== fn);
  }

  function closePortalMenus (vm, evt) {
    do {
      if (vm.$options.name === 'QMenu') {
        vm.hide(evt);

        // is this a point of separation?
        if (vm.separateClosePopup === true) {
          return vm.$parent
        }
      }
      else if (vm.__renderPortal !== void 0) {
        // treat it as point of separation if parent is QPopupProxy
        // (so mobile matches desktop behavior)
        // and hide it too
        if (vm.$parent !== void 0 && vm.$parent.$options.name === 'QPopupProxy') {
          vm.hide(evt);
          return vm.$parent
        }
        else {
          return vm
        }
      }
      vm = vm.$parent;
    } while (
      vm !== void 0 && (
        vm.$el.contains === void 0 || // IE polyfill does not work on comments
        vm.$el.contains(evt.target) !== true
      )
    )
  }

  function closePortals (vm, evt, depth) {
    while (depth !== 0 && vm !== void 0) {
      if (vm.__renderPortal !== void 0) {
        depth--;

        if (vm.$options.name === 'QMenu') {
          vm = closePortalMenus(vm, evt);
          continue
        }

        vm.hide(evt);
      }

      vm = vm.$parent;
    }
  }

  function isOnGlobalDialog (vm) {
    while (vm !== void 0) {
      if (vm.$options.name === 'QGlobalDialog') {
        return true
      }
      if (vm.$options.name === 'QDialog') {
        return false
      }

      vm = vm.$parent;
    }
    return false
  }

  const Portal = {
    inheritAttrs: false,

    props: {
      contentClass: [ Array, String, Object ],
      contentStyle: [ Array, String, Object ]
    },

    methods: {
      __showPortal (isReady) {
        if (isReady === true) {
          removeFocusWaitFlag(this.focusObj);
          this.__portalIsAccessible = true;
          return
        }

        this.__portalIsAccessible = false;

        if (this.__portalIsActive === true) { return }
        this.__portalIsActive = true;

        if (this.focusObj === void 0) {
          this.focusObj = {};
        }

        addFocusWaitFlag(this.focusObj);

        if (this.$q.fullscreen !== void 0 && this.$q.fullscreen.isCapable === true) {
          const append = () => {
            if (this.__portal === void 0) {
              return
            }

            const newParent = getBodyFullscreenElement(this.$q.fullscreen.activeEl);

            if (
              this.__portal.$el.parentElement !== newParent &&
              newParent.contains(this.$el) === (this.__onGlobalDialog === false)
            ) {
              newParent.appendChild(this.__portal.$el);
            }
          };

          this.unwatchFullscreen = this.$watch('$q.fullscreen.activeEl', debounce(append, 50));

          if (this.__onGlobalDialog === false || this.$q.fullscreen.isActive === true) {
            append();
          }
        }
        else if (this.__portal !== void 0 && this.__onGlobalDialog === false) {
          document.body.appendChild(this.__portal.$el);
        }
      },

      __hidePortal (isReady) {
        this.__portalIsAccessible = false;

        if (isReady !== true) { return }

        this.__portalIsActive = false;
        removeFocusWaitFlag(this.focusObj);

        if (this.__portal !== void 0) {
          if (this.unwatchFullscreen !== void 0) {
            this.unwatchFullscreen();
            this.unwatchFullscreen = void 0;
          }

          if (this.__onGlobalDialog === false) {
            this.__portal.$destroy();
            this.__portal.$el.remove();
          }

          this.__portal = void 0;
        }
      },

      __preparePortal () {
        if (this.__portal === void 0) {
          this.__portal = this.__onGlobalDialog === true
            ? {
              $el: this.$el,
              $refs: this.$refs
            }
            : new Vue({
              name: 'QPortal',
              parent: this,

              inheritAttrs: false,

              render: h => this.__renderPortal(h),

              components: this.$options.components,
              directives: this.$options.directives
            }).$mount();
        }
      }
    },

    render (h) {
      if (this.__onGlobalDialog === true) {
        return this.__renderPortal(h)
      }

      if (this.__portal !== void 0) {
        this.__portal.$forceUpdate();
      }
    },

    beforeDestroy () {
      this.__hidePortal(true);
    }
  };

  if (isSSR === false) {
    Portal.created = function () {
      this.__onGlobalDialog = isOnGlobalDialog(this.$parent);
    };
  }

  var TransitionMixin = {
    props: {
      transitionShow: {
        type: String,
        default: 'fade'
      },

      transitionHide: {
        type: String,
        default: 'fade'
      }
    },

    data () {
      return {
        transitionState: this.showing
      }
    },

    watch: {
      showing (val) {
        this.transitionShow !== this.transitionHide && this.$nextTick(() => {
          this.transitionState = val;
        });
      }
    },

    computed: {
      transition () {
        return 'q-transition--' + (this.transitionState === true ? this.transitionHide : this.transitionShow)
      }
    }
  };

  function getVmOfNode (el) {
    for (let node = el; node !== null; node = node.parentNode) {
      // node.__vue__ can be null if the instance was destroyed
      if (node.__vue__ !== void 0) {
        return node.__vue__
      }
    }
  }

  function isVmChildOf (childVm, parentVm) {
    // node.__vue__ can be null if the instance was destroyed
    if (childVm === null || parentVm === null) {
      return null
    }

    for (let vm = childVm; vm !== void 0; vm = vm.$parent) {
      if (vm === parentVm) {
        return true
      }
    }
    return false
  }

  let timer;

  const
    { notPassiveCapture, passiveCapture: passiveCapture$1 } = listenOpts,
    handlers = {
      click: [],
      focus: []
    };

  function hasModalsAbove (node) {
    while ((node = node.nextElementSibling) !== null) {
      if (node.classList.contains('q-dialog--modal')) {
        return true
      }
    }

    return false
  }

  function execHandlers (list, evt) {
    for (let i = list.length - 1; i >= 0; i--) {
      if (list[i](evt) === void 0) {
        return
      }
    }
  }

  function globalHandler (evt) {
    clearTimeout(timer);

    // prevent autofocus on body resulting from blur
    if (
      evt.type === 'focusin' && (
        (client.is.ie === true && evt.target === document.body) ||
        evt.target.hasAttribute('tabindex') === true
      )
    ) {
      timer = setTimeout(() => {
        execHandlers(handlers.focus, evt);
      }, client.is.ie === true ? 500 : 200);
    }
    else {
      execHandlers(handlers.click, evt);
    }
  }

  var ClickOutside = {
    name: 'click-outside',

    bind (el, { value, arg }, vnode) {
      const vmEl = vnode.componentInstance || vnode.context;

      const ctx = {
        trigger: value,
        toggleEl: arg,

        handler (evt) {
          const target = evt.target;

          if (
            evt.qClickOutside !== true &&
            document.body.contains(target) === true &&
            target.nodeType !== 8 &&
            // directives that prevent click by using pointer-events none generate click on html element
            target !== document.documentElement &&
            target.classList.contains('no-pointer-events') === false &&
            hasModalsAbove(el) !== true &&
            (
              ctx.toggleEl === void 0 ||
              ctx.toggleEl.contains(target) === false
            ) &&
            (
              target === document.body ||
              isVmChildOf(getVmOfNode(target), vmEl) === false
            )
          ) {
            // mark the event as being processed by clickOutside
            // used to prevent refocus after menu close
            evt.qClickOutside = true;

            return ctx.trigger(evt)
          }
        }
      };

      if (el.__qclickoutside) {
        el.__qclickoutside_old = el.__qclickoutside;
      }

      el.__qclickoutside = ctx;

      if (handlers.click.length === 0) {
        document.addEventListener('mousedown', globalHandler, notPassiveCapture);
        document.addEventListener('touchstart', globalHandler, notPassiveCapture);
        document.addEventListener('focusin', globalHandler, passiveCapture$1);
      }

      handlers.click.push(ctx.handler);

      ctx.timerFocusin = setTimeout(() => {
        handlers.focus.push(ctx.handler);
      }, 500);
    },

    update (el, { value, oldValue, arg }) {
      const ctx = el.__qclickoutside;

      if (value !== oldValue) {
        ctx.trigger = value;
      }
      if (arg !== ctx.arg) {
        ctx.toggleEl = arg;
      }
    },

    unbind (el) {
      const ctx = el.__qclickoutside_old || el.__qclickoutside;
      if (ctx !== void 0) {
        clearTimeout(ctx.timerFocusin);

        const
          indexClick = handlers.click.findIndex(h => h === ctx.handler),
          indexFocus = handlers.focus.findIndex(h => h === ctx.handler);

        indexClick > -1 && handlers.click.splice(indexClick, 1);
        indexFocus > -1 && handlers.focus.splice(indexFocus, 1);

        if (handlers.click.length === 0) {
          clearTimeout(timer);
          document.removeEventListener('mousedown', globalHandler, notPassiveCapture);
          document.removeEventListener('touchstart', globalHandler, notPassiveCapture);
          document.removeEventListener('focusin', globalHandler, passiveCapture$1);
        }

        delete el[el.__qclickoutside_old ? '__qclickoutside_old' : '__qclickoutside'];
      }
    }
  };

  const scrollTargets = isSSR === true
    ? []
    : [ null, document, document.body, document.scrollingElement, document.documentElement ];

  let rtlHasScrollBugStatus;
  function rtlHasScrollBug () {
    if (isSSR === true) {
      return false
    }

    if (rtlHasScrollBugStatus === void 0) {
      const scroller = document.createElement('div');
      const spacer = document.createElement('div');

      Object.assign(scroller.style, {
        direction: 'rtl',
        width: '1px',
        height: '1px',
        overflow: 'auto'
      });

      Object.assign(spacer.style, {
        width: '1000px',
        height: '1px'
      });

      scroller.appendChild(spacer);
      document.body.appendChild(scroller);
      scroller.scrollLeft = -1000;

      rtlHasScrollBugStatus = scroller.scrollLeft >= 0;

      scroller.remove();
    }

    return rtlHasScrollBugStatus
  }

  function getScrollTarget (el, targetEl) {
    let target = getElement(targetEl);

    if (target === null) {
      if (el !== Object(el) || typeof el.closest !== 'function') {
        return window
      }

      target = el.closest('.scroll,.scroll-y,.overflow-auto');
    }

    return scrollTargets.includes(target)
      ? window
      : target
  }

  function getScrollHeight (el) {
    return (el === window ? document.body : el).scrollHeight
  }

  function getScrollWidth (el) {
    return (el === window ? document.body : el).scrollWidth
  }

  function getVerticalScrollPosition (scrollTarget) {
    return scrollTarget === window
      ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0
      : scrollTarget.scrollTop
  }

  const getScrollPosition = getVerticalScrollPosition;

  function getHorizontalScrollPosition (scrollTarget) {
    return scrollTarget === window
      ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0
      : scrollTarget.scrollLeft
  }

  function animVerticalScrollTo (el, to, duration = 0 /* , prevTime */) {
    const prevTime = arguments[ 3 ] === void 0 ? performance.now() : arguments[ 3 ];
    const pos = getVerticalScrollPosition(el);

    if (duration <= 0) {
      if (pos !== to) {
        setScroll(el, to);
      }
      return
    }

    requestAnimationFrame(nowTime => {
      const frameTime = nowTime - prevTime;
      const newPos = pos + (to - pos) / Math.max(frameTime, duration) * frameTime;
      setScroll(el, newPos);
      if (newPos !== to) {
        animVerticalScrollTo(el, to, duration - frameTime, nowTime);
      }
    });
  }

  const animScrollTo = animVerticalScrollTo;

  function animHorizontalScrollTo (el, to, duration = 0 /* , prevTime */) {
    const prevTime = arguments[ 3 ] === void 0 ? performance.now() : arguments[ 3 ];
    const pos = getHorizontalScrollPosition(el);

    if (duration <= 0) {
      if (pos !== to) {
        setHorizontalScroll(el, to);
      }
      return
    }

    requestAnimationFrame(nowTime => {
      const frameTime = nowTime - prevTime;
      const newPos = pos + (to - pos) / Math.max(frameTime, duration) * frameTime;
      setHorizontalScroll(el, newPos);
      if (newPos !== to) {
        animHorizontalScrollTo(el, to, duration - frameTime, nowTime);
      }
    });
  }

  function setScroll (scrollTarget, offset) {
    if (scrollTarget === window) {
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, offset);
      return
    }
    scrollTarget.scrollTop = offset;
  }

  function setHorizontalScroll (scrollTarget, offset) {
    if (scrollTarget === window) {
      window.scrollTo(offset, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
      return
    }
    scrollTarget.scrollLeft = offset;
  }

  function setVerticalScrollPosition (scrollTarget, offset, duration) {
    if (duration) {
      animVerticalScrollTo(scrollTarget, offset, duration);
      return
    }
    setScroll(scrollTarget, offset);
  }

  const setScrollPosition = setVerticalScrollPosition;

  function setHorizontalScrollPosition (scrollTarget, offset, duration) {
    if (duration) {
      animHorizontalScrollTo(scrollTarget, offset, duration);
      return
    }
    setHorizontalScroll(scrollTarget, offset);
  }

  let size;
  function getScrollbarWidth () {
    if (size !== void 0) {
      return size
    }

    const
      inner = document.createElement('p'),
      outer = document.createElement('div');

    css(inner, {
      width: '100%',
      height: '200px'
    });
    css(outer, {
      position: 'absolute',
      top: '0px',
      left: '0px',
      visibility: 'hidden',
      width: '200px',
      height: '150px',
      overflow: 'hidden'
    });

    outer.appendChild(inner);

    document.body.appendChild(outer);

    const w1 = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    let w2 = inner.offsetWidth;

    if (w1 === w2) {
      w2 = outer.clientWidth;
    }

    outer.remove();
    size = w1 - w2;

    return size
  }

  function hasScrollbar (el, onY = true) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE) {
      return false
    }

    return onY
      ? (
        el.scrollHeight > el.clientHeight && (
          el.classList.contains('scroll') ||
          el.classList.contains('overflow-auto') ||
          [ 'auto', 'scroll' ].includes(window.getComputedStyle(el)['overflow-y'])
        )
      )
      : (
        el.scrollWidth > el.clientWidth && (
          el.classList.contains('scroll') ||
          el.classList.contains('overflow-auto') ||
          [ 'auto', 'scroll' ].includes(window.getComputedStyle(el)['overflow-x'])
        )
      )
  }

  var scroll = {
    getScrollTarget,

    getScrollHeight,
    getScrollWidth,

    getScrollPosition,
    getVerticalScrollPosition,
    getHorizontalScrollPosition,
    rtlHasScrollBug,

    animScrollTo,
    animVerticalScrollTo,
    animHorizontalScrollTo,

    setScrollPosition,
    setVerticalScrollPosition,
    setHorizontalScrollPosition,

    getScrollbarWidth,
    hasScrollbar
  };

  const handlers$1 = [];
  let escDown = false;

  var EscapeKey = {
    __install () {
      this.__installed = true;
      window.addEventListener('keydown', evt => {
        escDown = evt.keyCode === 27;
      });
      window.addEventListener('blur', () => {
        escDown === true && (escDown = false);
      });
      window.addEventListener('keyup', evt => {
        if (escDown === true) {
          escDown = false;

          if (handlers$1.length !== 0 && isKeyCode(evt, 27) === true) {
            handlers$1[handlers$1.length - 1].fn(evt);
          }
        }
      });
    },

    register (comp, fn) {
      if (comp.$q.platform.is.desktop === true) {
        this.__installed !== true && this.__install();
        handlers$1.push({ comp, fn });
      }
    },

    pop (comp) {
      if (comp.$q.platform.is.desktop === true) {
        const index = handlers$1.findIndex(h => h.comp === comp);
        if (index > -1) {
          handlers$1.splice(index, 1);
        }
      }
    }
  };

  let vpLeft, vpTop;

  function validatePosition (pos) {
    const parts = pos.split(' ');
    if (parts.length !== 2) {
      return false
    }
    if ([ 'top', 'center', 'bottom' ].includes(parts[0]) !== true) {
      console.error('Anchor/Self position must start with one of top/center/bottom');
      return false
    }
    if ([ 'left', 'middle', 'right', 'start', 'end' ].includes(parts[1]) !== true) {
      console.error('Anchor/Self position must end with one of left/middle/right/start/end');
      return false
    }
    return true
  }

  function validateOffset (val) {
    if (!val) { return true }
    if (val.length !== 2) { return false }
    if (typeof val[0] !== 'number' || typeof val[1] !== 'number') {
      return false
    }
    return true
  }

  const horizontalPos = {
    'start#ltr': 'left',
    'start#rtl': 'right',
    'end#ltr': 'right',
    'end#rtl': 'left'
  }

  ;[ 'left', 'middle', 'right' ].forEach(pos => {
    horizontalPos[`${pos}#ltr`] = pos;
    horizontalPos[`${pos}#rtl`] = pos;
  });

  function parsePosition (pos, rtl) {
    const parts = pos.split(' ');
    return {
      vertical: parts[0],
      horizontal: horizontalPos[`${parts[1]}#${rtl === true ? 'rtl' : 'ltr'}`]
    }
  }

  function getAnchorProps (el, offset) {
    let { top, left, right, bottom, width, height } = el.getBoundingClientRect();

    if (offset !== void 0) {
      top -= offset[1];
      left -= offset[0];
      bottom += offset[1];
      right += offset[0];

      width += offset[0];
      height += offset[1];
    }

    return {
      top,
      left,
      right,
      bottom,
      width,
      height,
      middle: left + (right - left) / 2,
      center: top + (bottom - top) / 2
    }
  }

  function getTargetProps (el) {
    return {
      top: 0,
      center: el.offsetHeight / 2,
      bottom: el.offsetHeight,
      left: 0,
      middle: el.offsetWidth / 2,
      right: el.offsetWidth
    }
  }

  // cfg: { el, anchorEl, anchorOrigin, selfOrigin, offset, absoluteOffset, cover, fit, maxHeight, maxWidth }
  function setPosition (cfg) {
    if (client.is.ios === true && window.visualViewport !== void 0) {
      // uses the q-position-engine CSS class

      const el = document.body.style;
      const { offsetLeft: left, offsetTop: top } = window.visualViewport;

      if (left !== vpLeft) {
        el.setProperty('--q-pe-left', left + 'px');
        vpLeft = left;
      }
      if (top !== vpTop) {
        el.setProperty('--q-pe-top', top + 'px');
        vpTop = top;
      }
    }

    let anchorProps;

    // scroll position might change
    // if max-height/-width changes, so we
    // need to restore it after we calculate
    // the new positioning
    const { scrollLeft, scrollTop } = cfg.el;

    if (cfg.absoluteOffset === void 0) {
      anchorProps = getAnchorProps(cfg.anchorEl, cfg.cover === true ? [0, 0] : cfg.offset);
    }
    else {
      const
        { top: anchorTop, left: anchorLeft } = cfg.anchorEl.getBoundingClientRect(),
        top = anchorTop + cfg.absoluteOffset.top,
        left = anchorLeft + cfg.absoluteOffset.left;

      anchorProps = { top, left, width: 1, height: 1, right: left + 1, center: top, middle: left, bottom: top + 1 };
    }

    let elStyle = {
      maxHeight: cfg.maxHeight,
      maxWidth: cfg.maxWidth,
      visibility: 'visible'
    };

    if (cfg.fit === true || cfg.cover === true) {
      elStyle.minWidth = anchorProps.width + 'px';
      if (cfg.cover === true) {
        elStyle.minHeight = anchorProps.height + 'px';
      }
    }

    Object.assign(cfg.el.style, elStyle);

    const
      targetProps = getTargetProps(cfg.el),
      props = {
        top: anchorProps[cfg.anchorOrigin.vertical] - targetProps[cfg.selfOrigin.vertical],
        left: anchorProps[cfg.anchorOrigin.horizontal] - targetProps[cfg.selfOrigin.horizontal]
      };

    applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);

    elStyle = {
      top: props.top + 'px',
      left: props.left + 'px'
    };

    if (props.maxHeight !== void 0) {
      elStyle.maxHeight = props.maxHeight + 'px';

      if (anchorProps.height > props.maxHeight) {
        elStyle.minHeight = elStyle.maxHeight;
      }
    }
    if (props.maxWidth !== void 0) {
      elStyle.maxWidth = props.maxWidth + 'px';

      if (anchorProps.width > props.maxWidth) {
        elStyle.minWidth = elStyle.maxWidth;
      }
    }

    Object.assign(cfg.el.style, elStyle);

    // restore scroll position
    if (cfg.el.scrollTop !== scrollTop) {
      cfg.el.scrollTop = scrollTop;
    }
    if (cfg.el.scrollLeft !== scrollLeft) {
      cfg.el.scrollLeft = scrollLeft;
    }
  }

  function applyBoundaries (props, anchorProps, targetProps, anchorOrigin, selfOrigin) {
    const
      currentHeight = targetProps.bottom,
      currentWidth = targetProps.right,
      margin = getScrollbarWidth(),
      innerHeight = window.innerHeight - margin,
      innerWidth = document.body.clientWidth;

    if (props.top < 0 || props.top + currentHeight > innerHeight) {
      if (selfOrigin.vertical === 'center') {
        props.top = anchorProps[anchorOrigin.vertical] > innerHeight / 2
          ? Math.max(0, innerHeight - currentHeight)
          : 0;
        props.maxHeight = Math.min(currentHeight, innerHeight);
      }
      else if (anchorProps[anchorOrigin.vertical] > innerHeight / 2) {
        const anchorY = Math.min(
          innerHeight,
          anchorOrigin.vertical === 'center'
            ? anchorProps.center
            : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top)
        );
        props.maxHeight = Math.min(currentHeight, anchorY);
        props.top = Math.max(0, anchorY - currentHeight);
      }
      else {
        props.top = Math.max(0, anchorOrigin.vertical === 'center'
          ? anchorProps.center
          : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom)
        );
        props.maxHeight = Math.min(currentHeight, innerHeight - props.top);
      }
    }

    if (props.left < 0 || props.left + currentWidth > innerWidth) {
      props.maxWidth = Math.min(currentWidth, innerWidth);
      if (selfOrigin.horizontal === 'middle') {
        props.left = anchorProps[anchorOrigin.horizontal] > innerWidth / 2
          ? Math.max(0, innerWidth - currentWidth)
          : 0;
      }
      else if (anchorProps[anchorOrigin.horizontal] > innerWidth / 2) {
        const anchorX = Math.min(
          innerWidth,
          anchorOrigin.horizontal === 'middle'
            ? anchorProps.middle
            : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left)
        );
        props.maxWidth = Math.min(currentWidth, anchorX);
        props.left = Math.max(0, anchorX - props.maxWidth);
      }
      else {
        props.left = Math.max(0, anchorOrigin.horizontal === 'middle'
          ? anchorProps.middle
          : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right)
        );
        props.maxWidth = Math.min(currentWidth, innerWidth - props.left);
      }
    }
  }

  var QMenu = Vue.extend({
    name: 'QMenu',

    mixins: [
      AttrsMixin,
      DarkMixin,
      AnchorMixin,
      ModelToggleMixin,
      Portal,
      TransitionMixin
    ],

    directives: {
      ClickOutside
    },

    props: {
      persistent: Boolean,
      autoClose: Boolean,
      separateClosePopup: Boolean,

      noRouteDismiss: Boolean,
      noRefocus: Boolean,
      noFocus: Boolean,

      fit: Boolean,
      cover: Boolean,

      square: Boolean,

      anchor: {
        type: String,
        validator: validatePosition
      },
      self: {
        type: String,
        validator: validatePosition
      },
      offset: {
        type: Array,
        validator: validateOffset
      },

      scrollTarget: {
        default: void 0
      },

      touchPosition: Boolean,

      maxHeight: {
        type: String,
        default: null
      },
      maxWidth: {
        type: String,
        default: null
      }
    },

    computed: {
      anchorOrigin () {
        return parsePosition(
          this.anchor || (
            this.cover === true ? 'center middle' : 'bottom start'
          ),
          this.$q.lang.rtl
        )
      },

      selfOrigin () {
        return this.cover === true
          ? this.anchorOrigin
          : parsePosition(this.self || 'top start', this.$q.lang.rtl)
      },

      menuClass () {
        return (this.square === true ? ' q-menu--square' : '') +
          (this.isDark === true ? ' q-menu--dark q-dark' : '')
      },

      hideOnRouteChange () {
        return this.persistent !== true &&
          this.noRouteDismiss !== true
      },

      onEvents () {
        const on = {
          ...this.qListeners,
          // stop propagating these events from children
          input: stop,
          'popup-show': stop,
          'popup-hide': stop
        };

        if (this.autoClose === true) {
          on.click = this.__onAutoClose;
        }

        return on
      },

      attrs () {
        return {
          tabindex: -1,
          ...this.qAttrs
        }
      }
    },

    methods: {
      focus () {
        addFocusFn(() => {
          let node = this.__portal !== void 0 && this.__portal.$refs !== void 0
            ? this.__portal.$refs.inner
            : void 0;

          if (node !== void 0 && node.contains(document.activeElement) !== true) {
            node = node.querySelector('[autofocus], [data-autofocus]') || node;
            node.focus({ preventScroll: true });
          }
        });
      },

      __show (evt) {
        // IE can have null document.activeElement
        this.__refocusTarget = client.is.mobile !== true && this.noRefocus === false && document.activeElement !== null
          ? document.activeElement
          : void 0;

        EscapeKey.register(this, () => {
          if (this.persistent !== true) {
            this.$emit('escape-key');
            this.hide();
          }
        });

        this.__showPortal();
        this.__configureScrollTarget();

        this.absoluteOffset = void 0;

        if (evt !== void 0 && (this.touchPosition || this.contextMenu)) {
          const pos = position(evt);

          if (pos.left !== void 0) {
            const { top, left } = this.anchorEl.getBoundingClientRect();
            this.absoluteOffset = { left: pos.left - left, top: pos.top - top };
          }
        }

        if (this.unwatch === void 0) {
          this.unwatch = this.$watch(
            () => this.$q.screen.width + '|' + this.$q.screen.height + '|' + this.self + '|' + this.anchor + '|' + this.$q.lang.rtl,
            this.updatePosition
          );
        }

        this.$el.dispatchEvent(create('popup-show', { bubbles: true }));

        // IE can have null document.activeElement
        if (this.noFocus !== true && document.activeElement !== null) {
          document.activeElement.blur();
        }

        this.__nextTick(() => {
          this.updatePosition();
          this.noFocus !== true && this.focus();
        });

        this.__setTimeout(() => {
          // required in order to avoid the "double-tap needed" issue
          if (this.$q.platform.is.ios === true) {
            // if auto-close, then this click should
            // not close the menu
            this.__avoidAutoClose = this.autoClose;
            this.__portal.$el.click();
          }

          this.updatePosition();
          this.__showPortal(true); // done showing
          this.$emit('show', evt);
        }, 300);
      },

      __hide (evt) {
        this.__anchorCleanup(true);
        this.__hidePortal();

        // check null for IE
        if (
          this.__refocusTarget !== void 0 &&
          this.__refocusTarget !== null &&
          (
            // menu was hidden from code or ESC plugin
            evt === void 0 ||
            // menu was not closed from a mouse or touch clickOutside
            evt.qClickOutside !== true
          )
        ) {
          this.__refocusTarget.focus();
          this.__refocusTarget = void 0;
        }

        this.$el.dispatchEvent(create('popup-hide', { bubbles: true }));

        this.__setTimeout(() => {
          this.__hidePortal(true); // done hiding, now destroy
          this.$emit('hide', evt);
        }, 300);
      },

      __anchorCleanup (hiding) {
        this.absoluteOffset = void 0;

        if (this.unwatch !== void 0) {
          this.unwatch();
          this.unwatch = void 0;
        }

        if (hiding === true || this.showing === true) {
          EscapeKey.pop(this);
          this.__unconfigureScrollTarget();
        }
      },

      __unconfigureScrollTarget () {
        if (this.__scrollTarget !== void 0) {
          this.__changeScrollEvent(this.__scrollTarget);
          this.__scrollTarget = void 0;
        }
      },

      __configureScrollTarget () {
        if (this.anchorEl !== void 0 || this.scrollTarget !== void 0) {
          this.__scrollTarget = getScrollTarget(this.anchorEl, this.scrollTarget);
          this.__changeScrollEvent(this.__scrollTarget, this.updatePosition);
        }
      },

      __onAutoClose (e) {
        // if auto-close, then the ios double-tap fix which
        // issues a click should not close the menu
        if (this.__avoidAutoClose !== true) {
          closePortalMenus(this, e);
          this.qListeners.click !== void 0 && this.$emit('click', e);
        }
        else {
          this.__avoidAutoClose = false;
        }
      },

      updatePosition () {
        if (this.anchorEl === void 0 || this.__portal === void 0) {
          return
        }

        const el = this.__portal.$el;

        if (el.nodeType === 8) { // IE replaces the comment with delay
          setTimeout(this.updatePosition, 25);
          return
        }

        setPosition({
          el,
          offset: this.offset,
          anchorEl: this.anchorEl,
          anchorOrigin: this.anchorOrigin,
          selfOrigin: this.selfOrigin,
          absoluteOffset: this.absoluteOffset,
          fit: this.fit,
          cover: this.cover,
          maxHeight: this.maxHeight,
          maxWidth: this.maxWidth
        });
      },

      __onClickOutside (e) {
        if (this.persistent !== true && this.showing === true) {
          const targetClassList = e.target.classList;

          closePortalMenus(this, e);
          if (
            // always prevent touch event
            e.type === 'touchstart' ||
            // prevent click if it's on a dialog backdrop
            targetClassList.contains('q-dialog__backdrop')
          ) {
            stopAndPreventClick(e);
          }
          return true
        }
      },

      __renderPortal (h) {
        return h('transition', {
          props: { name: this.transition }
        }, [
          this.showing === true ? h('div', {
            ref: 'inner',
            staticClass: 'q-menu q-position-engine scroll' + this.menuClass,
            class: this.contentClass,
            style: this.contentStyle,
            attrs: this.attrs,
            on: this.onEvents,
            directives: [{
              name: 'click-outside',
              value: this.__onClickOutside,
              arg: this.anchorEl
            }]
          }, slot(this, 'default')) : null
        ])
      }
    },

    mounted () {
      this.__processModelChange(this.value);
    },

    beforeDestroy () {
      this.__refocusTarget = void 0;

      // When the menu is destroyed while open we can only emit the event on anchorEl
      if (this.showing === true && this.anchorEl !== void 0) {
        this.anchorEl.dispatchEvent(
          create('popup-hide', { bubbles: true })
        );
      }
    }
  });

  var QBtnDropdown = Vue.extend({
    name: 'QBtnDropdown',

    mixins: [ BtnMixin, AttrsMixin ],

    inheritAttrs: false,

    props: {
      value: Boolean,
      split: Boolean,
      dropdownIcon: String,

      contentClass: [ Array, String, Object ],
      contentStyle: [ Array, String, Object ],

      cover: Boolean,
      persistent: Boolean,
      noRouteDismiss: Boolean,
      autoClose: Boolean,

      menuAnchor: {
        type: String,
        default: 'bottom end'
      },
      menuSelf: {
        type: String,
        default: 'top end'
      },
      menuOffset: Array,

      disableMainBtn: Boolean,
      disableDropdown: Boolean,

      noIconAnimation: Boolean
    },

    data () {
      return {
        showing: this.value
      }
    },

    watch: {
      value (val) {
        this.$refs.menu !== void 0 && this.$refs.menu[val ? 'show' : 'hide']();
      },

      split () {
        this.hide();
      }
    },

    render (h) {
      const label = slot(this, 'label', []);
      const attrs = {
        'aria-expanded': this.showing === true ? 'true' : 'false',
        'aria-haspopup': 'true'
      };

      if (
        this.disable === true ||
        (
          (this.split === false && this.disableMainBtn === true) ||
          this.disableDropdown === true
        )
      ) {
        attrs['aria-disabled'] = 'true';
      }

      const Arrow = [
        h(QIcon, {
          props: { name: this.dropdownIcon || this.$q.iconSet.arrow.dropdown },
          class: 'q-btn-dropdown__arrow' +
            (this.showing === true && this.noIconAnimation === false ? ' rotate-180' : '') +
            (this.split === false ? ' q-btn-dropdown__arrow-container' : '')
        })
      ];

      this.disableDropdown !== true && Arrow.push(
        h(QMenu, {
          ref: 'menu',
          props: {
            cover: this.cover,
            fit: true,
            persistent: this.persistent,
            noRouteDismiss: this.noRouteDismiss,
            autoClose: this.autoClose,
            anchor: this.menuAnchor,
            self: this.menuSelf,
            offset: this.menuOffset,
            contentClass: this.contentClass,
            contentStyle: this.contentStyle,
            separateClosePopup: true
          },
          on: cache(this, 'menu', {
            'before-show': e => {
              this.showing = true;
              this.$emit('before-show', e);
            },
            show: e => {
              this.$emit('show', e);
              this.$emit('input', true);
            },
            'before-hide': e => {
              this.showing = false;
              this.$emit('before-hide', e);
            },
            hide: e => {
              this.$emit('hide', e);
              this.$emit('input', false);
            }
          })
        }, slot(this, 'default'))
      );

      if (this.split === false) {
        return h(QBtn, {
          class: 'q-btn-dropdown q-btn-dropdown--simple',
          props: {
            ...this.$props,
            disable: this.disable === true || this.disableMainBtn === true,
            noWrap: true,
            round: false
          },
          attrs: {
            ...this.qAttrs,
            ...attrs
          },
          on: cache(this, 'nonSpl', {
            click: e => {
              this.$emit('click', e);
            }
          })
        }, label.concat(Arrow))
      }

      const Btn = h(QBtn, {
        class: 'q-btn-dropdown--current',
        props: {
          ...this.$props,
          disable: this.disable === true || this.disableMainBtn === true,
          noWrap: true,
          iconRight: this.iconRight,
          round: false
        },
        attrs: this.qAttrs,
        on: cache(this, 'spl', {
          click: e => {
            stop(e); // prevent showing the menu on click
            this.hide();
            this.$emit('click', e);
          }
        })
      }, label);

      return h(QBtnGroup, {
        props: {
          outline: this.outline,
          flat: this.flat,
          rounded: this.rounded,
          push: this.push,
          unelevated: this.unelevated,
          glossy: this.glossy,
          stretch: this.stretch
        },
        staticClass: 'q-btn-dropdown q-btn-dropdown--split no-wrap q-btn-item'
      }, [
        Btn,

        h(QBtn, {
          staticClass: 'q-btn-dropdown__arrow-container q-anchor--skip',
          attrs,
          props: {
            disable: this.disable === true || this.disableDropdown === true,
            outline: this.outline,
            flat: this.flat,
            rounded: this.rounded,
            push: this.push,
            size: this.size,
            color: this.color,
            textColor: this.textColor,
            dense: this.dense,
            ripple: this.ripple
          }
        }, Arrow)
      ])
    },

    methods: {
      toggle (evt) {
        this.$refs.menu && this.$refs.menu.toggle(evt);
      },

      show (evt) {
        this.$refs.menu && this.$refs.menu.show(evt);
      },

      hide (evt) {
        this.$refs.menu && this.$refs.menu.hide(evt);
      }
    },

    mounted () {
      this.value === true && this.show();
    }
  });

  var FormMixin = {
    props: {
      name: String
    },

    computed: {
      formAttrs () {
        return {
          type: 'hidden',
          name: this.name,
          value: this.value
        }
      }
    },

    methods: {
      __injectFormInput (child, action, className) {
        child[action](
          this.$createElement('input', {
            staticClass: 'hidden',
            class: className,
            attrs: this.formAttrs,
            domProps: this.formDomProps
          })
        );
      }
    }
  };

  const FormFieldMixin = {
    props: {
      name: String
    },

    computed: {
      nameProp () {
        return this.name || this.for
      }
    }
  };

  var QBtnToggle = Vue.extend({
    name: 'QBtnToggle',

    mixins: [ ListenersMixin, RippleMixin, FormMixin ],

    props: {
      value: {
        required: true
      },

      options: {
        type: Array,
        required: true,
        validator: v => v.every(
          opt => ('label' in opt || 'icon' in opt || 'slot' in opt) && 'value' in opt
        )
      },

      // To avoid seeing the active raise shadow through the transparent button, give it a color (even white).
      color: String,
      textColor: String,
      toggleColor: {
        type: String,
        default: 'primary'
      },
      toggleTextColor: String,

      outline: Boolean,
      flat: Boolean,
      unelevated: Boolean,
      rounded: Boolean,
      push: Boolean,
      glossy: Boolean,

      size: String,
      padding: String,

      noCaps: Boolean,
      noWrap: Boolean,
      dense: Boolean,
      readonly: Boolean,
      disable: Boolean,

      stack: Boolean,
      stretch: Boolean,

      spread: Boolean,

      clearable: Boolean
    },

    computed: {
      hasActiveValue () {
        return this.options.find(opt => opt.value === this.value) !== void 0
      },

      formAttrs () {
        return {
          type: 'hidden',
          name: this.name,
          value: this.value
        }
      },

      btnOptions () {
        const mergeOption = (opt, key) => opt[key] === void 0 ? this[key] : opt[key];

        return this.options.map((opt, i) => ({
          slot: opt.slot,

          options: {
            key: i,
            class: opt.class,
            style: opt.style,
            on: {
              ...this.qListeners,
              click: e => this.__set(opt.value, opt, e)
            },
            attrs: {
              'aria-pressed': opt.value === this.value ? 'true' : 'false',
              ...opt.attrs
            },
            props: {
              ...opt,
              slot: void 0,
              class: void 0,
              style: void 0,
              value: void 0,
              attrs: void 0,

              outline: this.outline,
              flat: this.flat,
              rounded: this.rounded,
              push: this.push,
              unelevated: this.unelevated,
              dense: this.dense,

              disable: this.disable === true || opt.disable === true,

              // Options that come from the button specific options first, then from general props
              color: opt.value === this.value ? mergeOption(opt, 'toggleColor') : mergeOption(opt, 'color'),
              textColor: opt.value === this.value ? mergeOption(opt, 'toggleTextColor') : mergeOption(opt, 'textColor'),
              noCaps: mergeOption(opt, 'noCaps') === true,
              noWrap: mergeOption(opt, 'noWrap') === true,

              size: mergeOption(opt, 'size'),
              padding: mergeOption(opt, 'padding'),
              ripple: mergeOption(opt, 'ripple'),
              stack: mergeOption(opt, 'stack') === true,
              stretch: mergeOption(opt, 'stretch') === true
            }
          }
        }))
      }
    },

    methods: {
      __set (value, opt, e) {
        if (this.readonly !== true) {
          if (this.value === value) {
            if (this.clearable === true) {
              this.$emit('input', null, null);
              this.$emit('clear');
            }
          }
          else {
            this.$emit('input', value, opt);
          }

          this.$emit('click', e);
        }
      }
    },

    render (h) {
      const child = this.btnOptions.map(opt => {
        return h(QBtn, { ...opt.options }, opt.slot !== void 0 ? slot(this, opt.slot) : void 0)
      });

      if (this.name !== void 0 && this.disable !== true && this.hasActiveValue === true) {
        this.__injectFormInput(child, 'push');
      }

      return h(QBtnGroup, {
        staticClass: 'q-btn-toggle',
        props: {
          outline: this.outline,
          flat: this.flat,
          rounded: this.rounded,
          push: this.push,
          stretch: this.stretch,
          unelevated: this.unelevated,
          glossy: this.glossy,
          spread: this.spread
        }
      }, mergeSlot(child, this, 'default'))
    }
  });

  var QCard = Vue.extend({
    name: 'QCard',

    mixins: [ ListenersMixin, DarkMixin, TagMixin ],

    props: {
      square: Boolean,
      flat: Boolean,
      bordered: Boolean
    },

    computed: {
      classes () {
        return 'q-card' +
          (this.isDark === true ? ' q-card--dark q-dark' : '') +
          (this.bordered === true ? ' q-card--bordered' : '') +
          (this.square === true ? ' q-card--square no-border-radius' : '') +
          (this.flat === true ? ' q-card--flat no-shadow' : '')
      }
    },

    render (h) {
      return h(this.tag, {
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var QCardSection = Vue.extend({
    name: 'QCardSection',

    mixins: [ ListenersMixin, TagMixin ],

    props: {
      horizontal: Boolean
    },

    computed: {
      classes () {
        return 'q-card__section ' +
          `q-card__section--${this.horizontal === true ? 'horiz row no-wrap' : 'vert'}`
      }
    },

    render (h) {
      return h(this.tag, {
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var QCardActions = Vue.extend({
    name: 'QCardActions',

    mixins: [ ListenersMixin, AlignMixin ],

    props: {
      vertical: Boolean
    },

    computed: {
      classes () {
        return `q-card__actions--${this.vertical === true ? 'vert column' : 'horiz row'} ${this.alignClass}`
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-card__actions',
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  const directions = [ 'left', 'right', 'up', 'down', 'horizontal', 'vertical' ];

  const modifiersAll = {
    left: true,
    right: true,
    up: true,
    down: true,
    horizontal: true,
    vertical: true,
    all: true
  };

  function getModifierDirections (mod) {
    const dir = {};

    directions.forEach(direction => {
      if (mod[direction]) {
        dir[direction] = true;
      }
    });

    if (Object.keys(dir).length === 0) {
      return modifiersAll
    }

    if (dir.horizontal === true) {
      dir.left = dir.right = true;
    }
    if (dir.vertical === true) {
      dir.up = dir.down = true;
    }
    if (dir.left === true && dir.right === true) {
      dir.horizontal = true;
    }
    if (dir.up === true && dir.down === true) {
      dir.vertical = true;
    }
    if (dir.horizontal === true && dir.vertical === true) {
      dir.all = true;
    }

    return dir
  }

  function shouldStart (evt, ctx) {
    return ctx.event === void 0 &&
      evt.target !== void 0 &&
      evt.target.draggable !== true &&
      typeof ctx.handler === 'function' &&
      evt.target.nodeName.toUpperCase() !== 'INPUT' &&
      (evt.qClonedBy === void 0 || evt.qClonedBy.indexOf(ctx.uid) === -1)
  }

  function parseArg (arg) {
    // delta (min velocity -- dist / time)
    // mobile min distance on first move
    // desktop min distance until deciding if it's a swipe or not
    const data = [0.06, 6, 50];

    if (typeof arg === 'string' && arg.length) {
      arg.split(':').forEach((val, index) => {
        const v = parseFloat(val);
        v && (data[index] = v);
      });
    }

    return data
  }

  function destroy$1 (el) {
    const ctx = el.__qtouchswipe;

    if (ctx !== void 0) {
      cleanEvt(ctx, 'main');
      cleanEvt(ctx, 'temp');

      client.is.firefox === true && preventDraggable(el, false);
      ctx.styleCleanup !== void 0 && ctx.styleCleanup();

      delete el.__qtouchswipe;
    }
  }

  var TouchSwipe = {
    name: 'touch-swipe',

    bind (el, { value, arg, modifiers }) {
      if (el.__qtouchswipe !== void 0) {
        destroy$1(el);
        el.__qtouchswipe_destroyed = true;
      }

      // early return, we don't need to do anything
      if (modifiers.mouse !== true && client.has.touch !== true) {
        return
      }

      const mouseCapture = modifiers.mouseCapture === true ? 'Capture' : '';

      const ctx = {
        handler: value,
        sensitivity: parseArg(arg),

        modifiers: modifiers,
        direction: getModifierDirections(modifiers),

        noop,

        mouseStart (evt) {
          if (shouldStart(evt, ctx) && leftClick(evt)) {
            addEvt(ctx, 'temp', [
              [ document, 'mousemove', 'move', `notPassive${mouseCapture}` ],
              [ document, 'mouseup', 'end', 'notPassiveCapture' ]
            ]);
            ctx.start(evt, true);
          }
        },

        touchStart (evt) {
          if (shouldStart(evt, ctx)) {
            const target = evt.target;
            addEvt(ctx, 'temp', [
              [ target, 'touchmove', 'move', 'notPassiveCapture' ],
              [ target, 'touchcancel', 'end', 'notPassiveCapture' ],
              [ target, 'touchend', 'end', 'notPassiveCapture' ]
            ]);
            ctx.start(evt);
          }
        },

        start (evt, mouseEvent) {
          client.is.firefox === true && preventDraggable(el, true);

          const pos = position(evt);

          ctx.event = {
            x: pos.left,
            y: pos.top,
            time: Date.now(),
            mouse: mouseEvent === true,
            dir: false
          };
        },

        move (evt) {
          if (ctx.event === void 0) {
            return
          }

          if (ctx.event.dir !== false) {
            stopAndPrevent(evt);
            return
          }

          const time = Date.now() - ctx.event.time;

          if (time === 0) {
            return
          }

          const
            pos = position(evt),
            distX = pos.left - ctx.event.x,
            absX = Math.abs(distX),
            distY = pos.top - ctx.event.y,
            absY = Math.abs(distY);

          if (ctx.event.mouse !== true) {
            if (absX < ctx.sensitivity[1] && absY < ctx.sensitivity[1]) {
              ctx.end(evt);
              return
            }
          }
          else if (absX < ctx.sensitivity[2] && absY < ctx.sensitivity[2]) {
            return
          }

          const
            velX = absX / time,
            velY = absY / time;

          if (
            ctx.direction.vertical === true &&
            absX < absY &&
            absX < 100 &&
            velY > ctx.sensitivity[0]
          ) {
            ctx.event.dir = distY < 0 ? 'up' : 'down';
          }

          if (
            ctx.direction.horizontal === true &&
            absX > absY &&
            absY < 100 &&
            velX > ctx.sensitivity[0]
          ) {
            ctx.event.dir = distX < 0 ? 'left' : 'right';
          }

          if (
            ctx.direction.up === true &&
            absX < absY &&
            distY < 0 &&
            absX < 100 &&
            velY > ctx.sensitivity[0]
          ) {
            ctx.event.dir = 'up';
          }

          if (
            ctx.direction.down === true &&
            absX < absY &&
            distY > 0 &&
            absX < 100 &&
            velY > ctx.sensitivity[0]
          ) {
            ctx.event.dir = 'down';
          }

          if (
            ctx.direction.left === true &&
            absX > absY &&
            distX < 0 &&
            absY < 100 &&
            velX > ctx.sensitivity[0]
          ) {
            ctx.event.dir = 'left';
          }

          if (
            ctx.direction.right === true &&
            absX > absY &&
            distX > 0 &&
            absY < 100 &&
            velX > ctx.sensitivity[0]
          ) {
            ctx.event.dir = 'right';
          }

          if (ctx.event.dir !== false) {
            stopAndPrevent(evt);

            if (ctx.event.mouse === true) {
              document.body.classList.add('no-pointer-events--children');
              document.body.classList.add('non-selectable');
              clearSelection();

              ctx.styleCleanup = withDelay => {
                ctx.styleCleanup = void 0;

                document.body.classList.remove('non-selectable');

                const remove = () => {
                  document.body.classList.remove('no-pointer-events--children');
                };

                if (withDelay === true) { setTimeout(remove, 50); }
                else { remove(); }
              };
            }

            ctx.handler({
              evt,
              touch: ctx.event.mouse !== true,
              mouse: ctx.event.mouse,
              direction: ctx.event.dir,
              duration: time,
              distance: {
                x: absX,
                y: absY
              }
            });
          }
          else {
            ctx.end(evt);
          }
        },

        end (evt) {
          if (ctx.event === void 0) {
            return
          }

          cleanEvt(ctx, 'temp');
          client.is.firefox === true && preventDraggable(el, false);
          ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);
          evt !== void 0 && ctx.event.dir !== false && stopAndPrevent(evt);

          ctx.event = void 0;
        }
      };

      el.__qtouchswipe = ctx;

      modifiers.mouse === true && addEvt(ctx, 'main', [
        [ el, 'mousedown', 'mouseStart', `passive${mouseCapture}` ]
      ]);

      client.has.touch === true && addEvt(ctx, 'main', [
        [ el, 'touchstart', 'touchStart', `passive${modifiers.capture === true ? 'Capture' : ''}` ],
        [ el, 'touchmove', 'noop', 'notPassiveCapture' ]
      ]);
    },

    update (el, { oldValue, value }) {
      const ctx = el.__qtouchswipe;
      if (ctx !== void 0 && oldValue !== value) {
        typeof value !== 'function' && ctx.end();
        ctx.handler = value;
      }
    },

    unbind (el) {
      if (el.__qtouchswipe_destroyed === void 0) {
        destroy$1(el);
      }
      else {
        delete el.__qtouchswipe_destroyed;
      }
    }
  };

  function getPanelWrapper (h) {
    return h('div', {
      staticClass: 'q-panel scroll',
      attrs: { role: 'tabpanel' },
      // stop propagation of content emitted @input
      // which would tamper with Panel's model
      on: cache(this, 'stop', { input: stop })
    }, slot(this, 'default'))
  }

  const PanelWrapper = Vue.extend({
    render: getPanelWrapper
  });

  const PanelParentMixin = {
    mixins: [ ListenersMixin ],

    directives: {
      TouchSwipe
    },

    props: {
      value: {
        required: true
      },

      animated: Boolean,
      infinite: Boolean,
      swipeable: Boolean,
      vertical: Boolean,

      transitionPrev: String,
      transitionNext: String,

      keepAlive: Boolean,
      keepAliveInclude: [ String, Array, RegExp ],
      keepAliveExclude: [ String, Array, RegExp ],
      keepAliveMax: Number
    },

    data () {
      return {
        panelIndex: null,
        panelTransition: null
      }
    },

    computed: {
      panelDirectives () {
        if (this.swipeable === true) {
          return [{
            name: 'touch-swipe',
            value: this.__swipe,
            modifiers: {
              horizontal: this.vertical !== true,
              vertical: this.vertical,
              mouse: true
            }
          }]
        }
      },

      contentKey () {
        return typeof this.value === 'string' || typeof this.value === 'number'
          ? this.value
          : String(this.value)
      },

      transitionPrevComputed () {
        return this.transitionPrev || `slide-${this.vertical === true ? 'down' : 'right'}`
      },

      transitionNextComputed () {
        return this.transitionNext || `slide-${this.vertical === true ? 'up' : 'left'}`
      },

      keepAliveProps () {
        return {
          include: this.keepAliveInclude,
          exclude: this.keepAliveExclude,
          max: this.keepAliveMax
        }
      },

      needsUniqueWrapper () {
        return this.keepAliveInclude !== void 0 ||
          this.keepAliveExclude !== void 0
      }
    },

    watch: {
      value (newVal, oldVal) {
        const index = this.__isValidPanelName(newVal) === true
          ? this.__getPanelIndex(newVal)
          : -1;

        if (this.__forcedPanelTransition !== true) {
          this.__updatePanelTransition(
            index === -1 ? 0 : (index < this.__getPanelIndex(oldVal) ? -1 : 1)
          );
        }

        if (this.panelIndex !== index) {
          this.panelIndex = index;
          this.$emit('before-transition', newVal, oldVal);
          this.$nextTick(() => {
            this.$emit('transition', newVal, oldVal);
          });
        }
      }
    },

    methods: {
      next () {
        this.__go(1);
      },

      previous () {
        this.__go(-1);
      },

      goTo (name) {
        this.$emit('input', name);
      },

      __isValidPanelName (name) {
        return name !== void 0 && name !== null && name !== ''
      },

      __getPanelIndex (name) {
        return this.panels.findIndex(panel => {
          const opt = panel.componentOptions.propsData;
          return opt.name === name &&
            opt.disable !== '' &&
            opt.disable !== true
        })
      },

      __getEnabledPanels () {
        return this.panels.filter(panel => {
          const opt = panel.componentOptions.propsData;
          return opt.disable !== '' && opt.disable !== true
        })
      },

      __updatePanelTransition (direction) {
        const val = direction !== 0 && this.animated === true && this.panelIndex !== -1
          ? 'q-transition--' + (direction === -1 ? this.transitionPrevComputed : this.transitionNextComputed)
          : null;

        if (this.panelTransition !== val) {
          this.panelTransition = val;
        }
      },

      __go (direction, startIndex = this.panelIndex) {
        let index = startIndex + direction;
        const slots = this.panels;

        while (index > -1 && index < slots.length) {
          const opt = slots[index].componentOptions;

          if (
            opt !== void 0 &&
            opt.propsData.disable !== '' &&
            opt.propsData.disable !== true
          ) {
            this.__updatePanelTransition(direction);
            this.__forcedPanelTransition = true;
            this.$emit('input', slots[index].componentOptions.propsData.name);
            setTimeout(() => {
              this.__forcedPanelTransition = false;
            });
            return
          }

          index += direction;
        }

        if (this.infinite === true && slots.length > 0 && startIndex !== -1 && startIndex !== slots.length) {
          this.__go(direction, direction === -1 ? slots.length : -1);
        }
      },

      __swipe (evt) {
        const dir = this.vertical === true ? 'up' : 'left';
        this.__go((this.$q.lang.rtl === true ? -1 : 1) * (evt.direction === dir ? 1 : -1));
      },

      __updatePanelIndex () {
        const index = this.__getPanelIndex(this.value);

        if (this.panelIndex !== index) {
          this.panelIndex = index;
        }

        return true
      },

      __getPanelContent (h) {
        if (this.panels.length === 0) {
          return
        }

        const panel = this.__isValidPanelName(this.value) &&
          this.__updatePanelIndex() &&
          this.panels[this.panelIndex];

        const content = this.keepAlive === true
          ? [
            h('keep-alive', { props: this.keepAliveProps }, [
              h(
                this.needsUniqueWrapper === true
                  ? cacheWithFn(this, this.contentKey, () => Vue.extend({
                    name: this.contentKey,
                    render: getPanelWrapper
                  }))
                  : PanelWrapper,
                { key: this.contentKey },
                [ panel ]
              )
            ])
          ]
          : [
            h('div', {
              staticClass: 'q-panel scroll',
              key: this.contentKey,
              attrs: { role: 'tabpanel' },
              // stop propagation of content emitted @input
              // which would tamper with Panel's model
              on: cache(this, 'stop', { input: stop })
            }, [ panel ])
          ];

        return this.animated === true
          ? [
            h('transition', {
              props: {
                name: this.panelTransition
              }
            }, content)
          ]
          : content
      }
    },

    render (h) {
      this.panels = slot(this, 'default', []).filter(
        panel => panel !== void 0 &&
          panel.componentOptions !== void 0 &&
          panel.componentOptions.propsData !== void 0 &&
          this.__isValidPanelName(panel.componentOptions.propsData.name)
      );

      return this.__renderPanels(h)
    }
  };

  const PanelChildMixin = {
    mixins: [ ListenersMixin ],

    props: {
      name: {
        required: true
      },
      disable: Boolean
    }
  };

  let fullscreenCounter = 0;

  var FullscreenMixin = {
    props: {
      fullscreen: Boolean,
      noRouteFullscreenExit: Boolean
    },

    data () {
      return {
        inFullscreen: false
      }
    },

    watch: {
      $route () {
        this.noRouteFullscreenExit !== true && this.exitFullscreen();
      },

      fullscreen (v) {
        if (this.inFullscreen !== v) {
          this.toggleFullscreen();
        }
      },

      inFullscreen (v) {
        this.$emit('update:fullscreen', v);
        this.$emit('fullscreen', v);
      }
    },

    methods: {
      toggleFullscreen () {
        if (this.inFullscreen === true) {
          this.exitFullscreen();
        }
        else {
          this.setFullscreen();
        }
      },

      setFullscreen () {
        if (this.inFullscreen === true) {
          return
        }

        this.inFullscreen = true;
        this.container = this.$el.parentNode;
        this.container.replaceChild(this.fullscreenFillerNode, this.$el);
        document.body.appendChild(this.$el);

        fullscreenCounter++;

        if (fullscreenCounter === 1) {
          document.body.classList.add('q-body--fullscreen-mixin');
        }

        this.__historyFullscreen = {
          handler: this.exitFullscreen
        };
        History.add(this.__historyFullscreen);
      },

      exitFullscreen () {
        if (this.inFullscreen !== true) {
          return
        }

        if (this.__historyFullscreen !== void 0) {
          History.remove(this.__historyFullscreen);
          this.__historyFullscreen = void 0;
        }
        this.container.replaceChild(this.$el, this.fullscreenFillerNode);
        this.inFullscreen = false;

        fullscreenCounter = Math.max(0, fullscreenCounter - 1);

        if (fullscreenCounter === 0) {
          document.body.classList.remove('q-body--fullscreen-mixin');

          if (this.$el.scrollIntoView !== void 0) {
            setTimeout(() => { this.$el.scrollIntoView(); });
          }
        }
      }
    },

    beforeMount () {
      this.fullscreenFillerNode = document.createElement('span');
    },

    mounted () {
      this.fullscreen === true && this.setFullscreen();
    },

    beforeDestroy () {
      this.exitFullscreen();
    }
  };

  const
    hasMap = typeof Map === 'function',
    hasSet = typeof Set === 'function',
    hasArrayBuffer = typeof ArrayBuffer === 'function';

  function isDeepEqual (a, b) {
    if (a === b) {
      return true
    }

    if (a !== null && b !== null && typeof a === 'object' && typeof b === 'object') {
      if (a.constructor !== b.constructor) {
        return false
      }

      let length, i;

      if (a.constructor === Array) {
        length = a.length;

        if (length !== b.length) {
          return false
        }

        for (i = length; i-- !== 0;) {
          if (isDeepEqual(a[i], b[i]) !== true) {
            return false
          }
        }

        return true
      }

      if (hasMap === true && a.constructor === Map) {
        if (a.size !== b.size) {
          return false
        }

        i = a.entries().next();
        while (i.done !== true) {
          if (b.has(i.value[0]) !== true) {
            return false
          }
          i = i.next();
        }

        i = a.entries().next();
        while (i.done !== true) {
          if (isDeepEqual(i.value[1], b.get(i.value[0])) !== true) {
            return false
          }
          i = i.next();
        }

        return true
      }

      if (hasSet === true && a.constructor === Set) {
        if (a.size !== b.size) {
          return false
        }

        i = a.entries().next();
        while (i.done !== true) {
          if (b.has(i.value[0]) !== true) {
            return false
          }
          i = i.next();
        }

        return true
      }

      if (hasArrayBuffer === true && a.buffer != null && a.buffer.constructor === ArrayBuffer) {
        length = a.length;

        if (length !== b.length) {
          return false
        }

        for (i = length; i-- !== 0;) {
          if (a[i] !== b[i]) {
            return false
          }
        }

        return true
      }

      if (a.constructor === RegExp) {
        return a.source === b.source && a.flags === b.flags
      }

      if (a.valueOf !== Object.prototype.valueOf) {
        return a.valueOf() === b.valueOf()
      }

      if (a.toString !== Object.prototype.toString) {
        return a.toString() === b.toString()
      }

      const keys = Object.keys(a).filter(key => a[key] !== void 0);
      length = keys.length;

      if (length !== Object.keys(b).filter(key => b[key] !== void 0).length) {
        return false
      }

      for (i = length; i-- !== 0;) {
        const key = keys[i];
        if (isDeepEqual(a[key], b[key]) !== true) {
          return false
        }
      }

      return true
    }

    // true if both NaN, false otherwise
    return a !== a && b !== b // eslint-disable-line no-self-compare
  }

  // not perfect, but what we ARE interested is for Arrays not to slip in
  // as spread operator will mess things up in various areas
  // see https://jsbench.me/tbl0iliyax/1
  function isObject (v) {
    return v !== null && typeof v === 'object' && Array.isArray(v) !== true
  }

  function isDate (v) {
    return Object.prototype.toString.call(v) === '[object Date]'
  }

  function isRegexp (v) {
    return Object.prototype.toString.call(v) === '[object RegExp]'
  }

  function isNumber (v) {
    return typeof v === 'number' && isFinite(v)
  }

  var QCarousel = Vue.extend({
    name: 'QCarousel',

    mixins: [ DarkMixin, PanelParentMixin, FullscreenMixin ],

    props: {
      height: String,
      padding: Boolean,

      controlType: {
        type: String,
        validator: v => [ 'regular', 'flat', 'outline', 'push', 'unelevated' ].includes(v),
        default: 'flat'
      },
      controlColor: String,
      controlTextColor: String,

      autoplay: [ Number, Boolean ],

      arrows: Boolean,
      prevIcon: String,
      nextIcon: String,

      navigation: Boolean,
      navigationPosition: {
        type: String,
        validator: v => [ 'top', 'right', 'bottom', 'left' ].includes(v)
      },
      navigationIcon: String,
      navigationActiveIcon: String,

      thumbnails: Boolean
    },

    computed: {
      style () {
        if (this.inFullscreen !== true && this.height !== void 0) {
          return {
            height: this.height
          }
        }
      },

      direction () {
        return this.vertical === true ? 'vertical' : 'horizontal'
      },

      classes () {
        return `q-carousel q-panel-parent q-carousel--with${this.padding === true ? '' : 'out'}-padding` +
          (this.inFullscreen === true ? ' fullscreen' : '') +
          (this.isDark === true ? ' q-carousel--dark q-dark' : '') +
          (this.arrows === true ? ` q-carousel--arrows-${this.direction}` : '') +
          (this.navigation === true ? ` q-carousel--navigation-${this.navigationPositionComputed}` : '')
      },

      arrowIcons () {
        const ico = [
          this.prevIcon || this.$q.iconSet.carousel[this.vertical === true ? 'up' : 'left'],
          this.nextIcon || this.$q.iconSet.carousel[this.vertical === true ? 'down' : 'right']
        ];

        return this.vertical === false && this.$q.lang.rtl === true
          ? ico.reverse()
          : ico
      },

      navIcon () {
        return this.navigationIcon || this.$q.iconSet.carousel.navigationIcon
      },

      navActiveIcon () {
        return this.navigationActiveIcon || this.navIcon
      },

      navigationPositionComputed () {
        return this.navigationPosition || (this.vertical === true ? 'right' : 'bottom')
      },

      controlProps () {
        return {
          color: this.controlColor,
          textColor: this.controlTextColor,
          round: true,
          [ this.controlType ]: true,
          dense: true
        }
      },

      transitionPrevComputed () {
        return this.transitionPrev || 'fade'
      },

      transitionNextComputed () {
        return this.transitionNext || 'fade'
      }
    },

    watch: {
      value () {
        if (this.autoplay) {
          clearInterval(this.timer);
          this.__startTimer();
        }
      },

      autoplay (val) {
        if (val) {
          this.__startTimer();
        }
        else {
          clearInterval(this.timer);
        }
      }
    },

    methods: {
      __startTimer () {
        const duration = isNumber(this.autoplay) === true
          ? this.autoplay
          : 5000;

        this.timer = setTimeout(
          duration >= 0 ? this.next : this.previous,
          Math.abs(duration)
        );
      },

      __getNavigationContainer (h, type, mapping) {
        return h('div', {
          class: 'q-carousel__control q-carousel__navigation no-wrap absolute flex' +
            ` q-carousel__navigation--${type} q-carousel__navigation--${this.navigationPositionComputed}` +
            (this.controlColor !== void 0 ? ` text-${this.controlColor}` : '')
        }, [
          h('div', {
            staticClass: 'q-carousel__navigation-inner flex flex-center no-wrap'
          }, this.__getEnabledPanels().map(mapping))
        ])
      },

      __getContent (h) {
        const node = [];

        if (this.navigation === true) {
          const fn = this.$scopedSlots['navigation-icon'] !== void 0
            ? this.$scopedSlots['navigation-icon']
            : opts => h(QBtn, {
              key: 'nav' + opts.name,
              class: `q-carousel__navigation-icon q-carousel__navigation-icon--${opts.active === true ? '' : 'in'}active`,
              props: opts.btnProps,
              on: cache(this, 'nav#' + opts.name, { click: opts.onClick })
            });

          const maxIndex = this.panels.length - 1;
          node.push(
            this.__getNavigationContainer(h, 'buttons', (panel, index) => {
              const name = panel.componentOptions.propsData.name;
              const active = this.panelIndex === index;

              return fn({
                index,
                maxIndex,
                name,
                active,
                btnProps: {
                  icon: active === true ? this.navActiveIcon : this.navIcon,
                  size: 'sm',
                  ...this.controlProps
                },
                onClick: () => { this.goTo(name); }
              })
            })
          );
        }
        else if (this.thumbnails === true) {
          const color = this.controlColor !== void 0
            ? ` text-${this.controlColor}`
            : '';

          node.push(this.__getNavigationContainer(h, 'thumbnails', panel => {
            const slide = panel.componentOptions.propsData;

            return h('img', {
              class: `q-carousel__thumbnail q-carousel__thumbnail--${slide.name === this.value ? '' : 'in'}active` + color,
              attrs: {
                src: slide.imgSrc
              },
              key: 'tmb#' + slide.name,
              on: cache(this, 'tmb#' + slide.name, { click: () => { this.goTo(slide.name); } })
            })
          }));
        }

        if (this.arrows === true && this.panelIndex >= 0) {
          if (this.infinite === true || this.panelIndex > 0) {
            node.push(
              h('div', {
                key: 'prev',
                staticClass: `q-carousel__control q-carousel__arrow q-carousel__prev-arrow q-carousel__prev-arrow--${this.direction} absolute flex flex-center`
              }, [
                h(QBtn, {
                  props: { icon: this.arrowIcons[0], ...this.controlProps },
                  on: cache(this, 'prev', { click: this.previous })
                })
              ])
            );
          }

          if (this.infinite === true || this.panelIndex < this.panels.length - 1) {
            node.push(
              h('div', {
                key: 'next',
                staticClass: `q-carousel__control q-carousel__arrow q-carousel__next-arrow q-carousel__next-arrow--${this.direction} absolute flex flex-center`
              }, [
                h(QBtn, {
                  props: { icon: this.arrowIcons[1], ...this.controlProps },
                  on: cache(this, 'next', { click: this.next })
                })
              ])
            );
          }
        }

        return mergeSlot(node, this, 'control')
      },

      __renderPanels (h) {
        return h('div', {
          style: this.style,
          class: this.classes,
          on: { ...this.qListeners }
        }, [
          h('div', {
            staticClass: 'q-carousel__slides-container',
            directives: this.panelDirectives
          }, this.__getPanelContent(h))
        ].concat(this.__getContent(h)))
      }
    },

    mounted () {
      this.autoplay && this.__startTimer();
    },

    beforeDestroy () {
      clearInterval(this.timer);
    }
  });

  var QCarouselSlide = Vue.extend({
    name: 'QCarouselSlide',

    mixins: [ PanelChildMixin ],

    props: {
      imgSrc: String
    },

    computed: {
      style () {
        if (this.imgSrc) {
          return {
            backgroundImage: `url("${this.imgSrc}")`
          }
        }
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-carousel__slide',
        style: this.style,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var QCarouselControl = Vue.extend({
    name: 'QCarouselControl',

    mixins: [ ListenersMixin ],

    props: {
      position: {
        type: String,
        default: 'bottom-right',
        validator: v => [
          'top-right', 'top-left',
          'bottom-right', 'bottom-left',
          'top', 'right', 'bottom', 'left'
        ].includes(v)
      },
      offset: {
        type: Array,
        default: () => [18, 18],
        validator: v => v.length === 2
      }
    },

    computed: {
      classes () {
        return `absolute-${this.position}`
      },

      style () {
        return {
          margin: `${this.offset[1]}px ${this.offset[0]}px`
        }
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-carousel__control absolute',
        style: this.style,
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var QChatMessage = Vue.extend({
    name: 'QChatMessage',

    mixins: [ ListenersMixin ],

    props: {
      sent: Boolean,
      label: String,
      bgColor: String,
      textColor: String,
      name: String,
      avatar: String,
      text: Array,
      stamp: String,
      size: String,
      labelSanitize: Boolean,
      nameSanitize: Boolean,
      textSanitize: Boolean,
      stampSanitize: Boolean
    },

    computed: {
      textClass () {
        return `q-message-text-content q-message-text-content--${this.op}` +
          (this.textColor !== void 0 ? ` text-${this.textColor}` : '')
      },

      messageClass () {
        return `q-message-text q-message-text--${this.op}` +
          (this.bgColor !== void 0 ? ` text-${this.bgColor}` : '')
      },

      containerClass () {
        return 'q-message-container row items-end no-wrap' +
          (this.sent === true ? ' reverse' : '')
      },

      sizeClass () {
        if (this.size !== void 0) {
          return `col-${this.size}`
        }
      },

      op () {
        return this.sent === true ? 'sent' : 'received'
      }
    },

    methods: {
      __wrapStamp (h, node) {
        if (this.$scopedSlots.stamp !== void 0) {
          return [ node, h('div', { staticClass: 'q-message-stamp' }, this.$scopedSlots.stamp()) ]
        }

        if (this.stamp) {
          const domPropStamp = this.stampSanitize === true ? 'textContent' : 'innerHTML';

          return [
            node,
            h('div', {
              staticClass: 'q-message-stamp',
              domProps: { [domPropStamp]: this.stamp }
            })
          ]
        }

        return [ node ]
      },

      __getText (h, contentList, withSlots) {
        const domPropText = this.textSanitize === true ? 'textContent' : 'innerHTML';

        if (
          withSlots === true &&
          contentList.some(entry => entry.tag === void 0 && entry.text !== void 0) === true
        ) {
          return [
            h('div', { class: this.messageClass }, [
              h('div', { class: this.textClass }, this.__wrapStamp(h, h('div', contentList)))
            ])
          ]
        }

        const content = withSlots !== true
          ? text => h('div', { domProps: { [domPropText]: text } })
          : (contentList.length > 1 ? text => text : text => h('div', [text]));

        return contentList.map((msg, index) => h('div', {
          key: index,
          class: this.messageClass
        }, [
          h('div', { class: this.textClass }, this.__wrapStamp(h, content(msg)))
        ]))
      }
    },

    render (h) {
      const container = [];

      if (this.$scopedSlots.avatar !== void 0) {
        container.push(this.$scopedSlots.avatar());
      }
      else if (this.avatar !== void 0) {
        container.push(
          h('img', {
            class: `q-message-avatar q-message-avatar--${this.op}`,
            attrs: { src: this.avatar, 'aria-hidden': 'true' }
          })
        );
      }

      const msg = [];

      if (this.$scopedSlots.name !== void 0) {
        msg.push(
          h('div', {
            class: `q-message-name q-message-name--${this.op}`
          }, this.$scopedSlots.name())
        );
      }
      else if (this.name !== void 0) {
        msg.push(
          h('div', {
            class: `q-message-name q-message-name--${this.op}`,
            domProps: { [this.nameSanitize === true ? 'textContent' : 'innerHTML']: this.name }
          })
        );
      }

      this.text !== void 0 && msg.push(
        this.__getText(h, this.text)
      );

      this.$scopedSlots.default !== void 0 && msg.push(
        this.__getText(h, this.$scopedSlots.default(), true)
      );

      container.push(
        h('div', { class: this.sizeClass }, msg)
      );

      const child = [];

      if (this.$scopedSlots.label !== void 0) {
        child.push(
          h('div', { staticClass: 'q-message-label' }, this.$scopedSlots.label())
        );
      }
      else if (this.label !== void 0) {
        child.push(
          h('div', {
            staticClass: 'q-message-label',
            domProps: { [this.labelSanitize === true ? 'textContent' : 'innerHTML']: this.label }
          })
        );
      }

      child.push(
        h('div', { class: this.containerClass }, container)
      );

      return h('div', {
        class: `q-message q-message-${this.op}`,
        on: { ...this.qListeners }
      }, child)
    }
  });

  var OptionSizeMixin = getSizeMixin({
    xs: 30,
    sm: 35,
    md: 40,
    lg: 50,
    xl: 60
  });

  var RefocusTargetMixin = {
    computed: {
      __refocusTargetEl () {
        if (this.disable !== true) {
          return this.$createElement('span', {
            ref: 'refocusTarget',
            staticClass: 'no-outline',
            attrs: { tabindex: -1 }
          })
        }
      }
    },

    methods: {
      __refocusTarget (e) {
        if (e !== void 0 && e.type.indexOf('key') === 0) {
          if (document.activeElement !== this.$el && this.$el.contains(document.activeElement) === true) {
            this.$el.focus();
          }
        }
        else if ((e === void 0 || this.$el.contains(e.target) === true) && this.$refs.refocusTarget !== void 0) {
          this.$refs.refocusTarget.focus();
        }
      }
    }
  };

  var CheckboxMixin = {
    mixins: [ DarkMixin, OptionSizeMixin, FormMixin, RefocusTargetMixin ],

    props: {
      value: {
        required: true,
        default: null
      },
      val: {},

      trueValue: { default: true },
      falseValue: { default: false },
      indeterminateValue: { default: null },

      checkedIcon: String,
      uncheckedIcon: String,
      indeterminateIcon: String,

      toggleOrder: {
        type: String,
        validator: v => v === 'tf' || v === 'ft'
      },
      toggleIndeterminate: Boolean,

      label: String,
      leftLabel: Boolean,

      color: String,
      keepColor: Boolean,
      dense: Boolean,

      disable: Boolean,
      tabindex: [String, Number]
    },

    computed: {
      isTrue () {
        return this.modelIsArray === true
          ? this.index > -1
          : this.value === this.trueValue
      },

      isFalse () {
        return this.modelIsArray === true
          ? this.index === -1
          : this.value === this.falseValue
      },

      isIndeterminate () {
        return this.isTrue === false && this.isFalse === false
      },

      index () {
        if (this.modelIsArray === true) {
          return this.value.indexOf(this.val)
        }
      },

      modelIsArray () {
        return this.val !== void 0 && Array.isArray(this.value)
      },

      computedTabindex () {
        return this.disable === true ? -1 : this.tabindex || 0
      },

      classes () {
        return `q-${this.type} cursor-pointer no-outline row inline no-wrap items-center` +
          (this.disable === true ? ' disabled' : '') +
          (this.isDark === true ? ` q-${this.type}--dark` : '') +
          (this.dense === true ? ` q-${this.type}--dense` : '') +
          (this.leftLabel === true ? ' reverse' : '')
      },

      innerClass () {
        const state = this.isTrue === true ? 'truthy' : (this.isFalse === true ? 'falsy' : 'indet');
        const color = this.color !== void 0 && (
          this.keepColor === true ||
          (this.type === 'toggle' ? this.isTrue === true : this.isFalse !== true)
        )
          ? ` text-${this.color}`
          : '';

        return `q-${this.type}__inner--${state}${color}`
      },

      formAttrs () {
        const prop = { type: 'checkbox' };

        this.name !== void 0 && Object.assign(prop, {
          checked: this.isTrue,
          name: this.name,
          value: this.modelIsArray === true
            ? this.val
            : this.trueValue
        });

        return prop
      },

      attrs () {
        const attrs = {
          tabindex: this.computedTabindex,
          role: 'checkbox',
          'aria-label': this.label,
          'aria-checked': this.isIndeterminate === true
            ? 'mixed'
            : (this.isTrue === true ? 'true' : 'false')
        };

        if (this.disable === true) {
          attrs['aria-disabled'] = 'true';
        }

        return attrs
      }
    },

    methods: {
      toggle (e) {
        if (e !== void 0) {
          stopAndPrevent(e);
          this.__refocusTarget(e);
        }

        if (this.disable !== true) {
          this.$emit('input', this.__getNextValue(), e);
        }
      },

      __getNextValue () {
        if (this.modelIsArray === true) {
          if (this.isTrue === true) {
            const val = this.value.slice();
            val.splice(this.index, 1);
            return val
          }

          return this.value.concat([ this.val ])
        }

        if (this.isTrue === true) {
          if (this.toggleOrder !== 'ft' || this.toggleIndeterminate === false) {
            return this.falseValue
          }
        }
        else if (this.isFalse === true) {
          if (this.toggleOrder === 'ft' || this.toggleIndeterminate === false) {
            return this.trueValue
          }
        }
        else {
          return this.toggleOrder !== 'ft'
            ? this.trueValue
            : this.falseValue
        }

        return this.indeterminateValue
      },

      __onKeydown (e) {
        if (e.keyCode === 13 || e.keyCode === 32) {
          stopAndPrevent(e);
        }
      },

      __onKeyup (e) {
        if (e.keyCode === 13 || e.keyCode === 32) {
          this.toggle(e);
        }
      }
    },

    render (h) {
      const inner = this.__getInner(h);

      this.disable !== true && this.__injectFormInput(
        inner,
        'unshift',
        `q-${this.type}__native absolute q-ma-none q-pa-none`
      );

      const child = [
        h('div', {
          staticClass: `q-${this.type}__inner relative-position non-selectable`,
          class: this.innerClass,
          style: this.sizeStyle
        }, inner)
      ];

      if (this.__refocusTargetEl !== void 0) {
        child.push(this.__refocusTargetEl);
      }

      const label = this.label !== void 0
        ? mergeSlot([ this.label ], this, 'default')
        : slot(this, 'default');

      label !== void 0 && child.push(
        h('div', {
          staticClass: `q-${this.type}__label q-anchor--skip`
        }, label)
      );

      return h('div', {
        class: this.classes,
        attrs: this.attrs,
        on: cache(this, 'inpExt', {
          click: this.toggle,
          keydown: this.__onKeydown,
          keyup: this.__onKeyup
        })
      }, child)
    }
  };

  var QCheckbox = Vue.extend({
    name: 'QCheckbox',

    mixins: [ CheckboxMixin ],

    computed: {
      computedIcon () {
        return this.isTrue === true
          ? this.checkedIcon
          : (this.isIndeterminate === true
            ? this.indeterminateIcon
            : this.uncheckedIcon
          )
      }
    },

    methods: {
      __getInner (h) {
        return this.computedIcon !== void 0
          ? [
            h('div', {
              key: 'icon',
              staticClass: 'q-checkbox__icon-container absolute-full flex flex-center no-wrap'
            }, [
              h(QIcon, {
                staticClass: 'q-checkbox__icon',
                props: { name: this.computedIcon }
              })
            ])
          ]
          : [
            h('div', {
              key: 'svg',
              staticClass: 'q-checkbox__bg absolute'
            }, [
              h('svg', {
                staticClass: 'q-checkbox__svg fit absolute-full',
                attrs: { focusable: 'false' /* needed for IE11 */, viewBox: '0 0 24 24', 'aria-hidden': 'true' }
              }, [
                h('path', {
                  staticClass: 'q-checkbox__truthy',
                  attrs: {
                    fill: 'none',
                    d: 'M1.73,12.91 8.1,19.28 22.79,4.59'
                  }
                }),

                h('path', {
                  staticClass: 'q-checkbox__indet',
                  attrs: {
                    d: 'M4,14H20V10H4'
                  }
                })
              ])
            ])
          ]
      }
    },

    created () {
      this.type = 'checkbox';
    }
  });

  var QChip = Vue.extend({
    name: 'QChip',

    mixins: [
      RippleMixin,
      DarkMixin,
      getSizeMixin({
        xs: 8,
        sm: 10,
        md: 14,
        lg: 20,
        xl: 24
      })
    ],

    model: {
      event: 'remove'
    },

    props: {
      dense: Boolean,

      icon: String,
      iconRight: String,
      iconRemove: String,
      iconSelected: String,
      label: [String, Number],

      color: String,
      textColor: String,

      value: {
        type: Boolean,
        default: true
      },
      selected: {
        type: Boolean,
        default: null
      },

      square: Boolean,
      outline: Boolean,
      clickable: Boolean,
      removable: Boolean,

      tabindex: [String, Number],
      disable: Boolean
    },

    computed: {
      classes () {
        const text = this.outline === true
          ? this.color || this.textColor
          : this.textColor;

        return {
          [`bg-${this.color}`]: this.outline === false && this.color !== void 0,
          [`text-${text} q-chip--colored`]: text,
          disabled: this.disable,
          'q-chip--dense': this.dense,
          'q-chip--outline': this.outline,
          'q-chip--selected': this.selected,
          'q-chip--clickable cursor-pointer non-selectable q-hoverable': this.isClickable,
          'q-chip--square': this.square,
          'q-chip--dark q-dark': this.isDark
        }
      },

      hasLeftIcon () {
        return this.selected === true || this.icon !== void 0
      },

      leftIcon () {
        return this.selected === true
          ? this.iconSelected || this.$q.iconSet.chip.selected
          : this.icon
      },

      removeIcon () {
        return this.iconRemove || this.$q.iconSet.chip.remove
      },

      isClickable () {
        return this.disable === false && (this.clickable === true || this.selected !== null)
      },

      attrs () {
        return this.disable === true
          ? { tabindex: -1, 'aria-disabled': 'true' }
          : { tabindex: this.tabindex || 0 }
      }
    },

    methods: {
      __onKeyup (e) {
        e.keyCode === 13 /* ENTER */ && this.__onClick(e);
      },

      __onClick (e) {
        if (!this.disable) {
          this.$emit('update:selected', !this.selected);
          this.$emit('click', e);
        }
      },

      __onRemove (e) {
        if (e.keyCode === void 0 || e.keyCode === 13) {
          stopAndPrevent(e);
          !this.disable && this.$emit('remove', false);
        }
      },

      __getContent (h) {
        const child = [];

        this.isClickable === true && child.push(
          h('div', { staticClass: 'q-focus-helper' })
        );

        this.hasLeftIcon === true && child.push(
          h(QIcon, {
            staticClass: 'q-chip__icon q-chip__icon--left',
            props: { name: this.leftIcon }
          })
        );

        const label = this.label !== void 0
          ? [ h('div', { staticClass: 'ellipsis' }, [ this.label ]) ]
          : void 0;

        child.push(
          h('div', {
            staticClass: 'q-chip__content col row no-wrap items-center q-anchor--skip'
          }, mergeSlotSafely(label, this, 'default'))
        );

        this.iconRight && child.push(
          h(QIcon, {
            staticClass: 'q-chip__icon q-chip__icon--right',
            props: { name: this.iconRight }
          })
        );

        this.removable === true && child.push(
          h(QIcon, {
            staticClass: 'q-chip__icon q-chip__icon--remove cursor-pointer',
            props: { name: this.removeIcon },
            attrs: this.attrs,
            on: cache(this, 'non', {
              click: this.__onRemove,
              keyup: this.__onRemove
            })
          })
        );

        return child
      }
    },

    render (h) {
      if (this.value === false) { return }

      const data = {
        staticClass: 'q-chip row inline no-wrap items-center',
        class: this.classes,
        style: this.sizeStyle
      };

      this.isClickable === true && Object.assign(data, {
        attrs: this.attrs,
        on: cache(this, 'click', {
          click: this.__onClick,
          keyup: this.__onKeyup
        }),
        directives: cache(this, 'dir#' + this.ripple, [
          { name: 'ripple', value: this.ripple }
        ])
      });

      return h('div', data, this.__getContent(h))
    }
  });

  const
    radius = 50,
    diameter = 2 * radius,
    circumference = diameter * Math.PI,
    strokeDashArray = Math.round(circumference * 1000) / 1000;

  var QCircularProgress = Vue.extend({
    name: 'QCircularProgress',

    mixins: [ ListenersMixin, SizeMixin ],

    props: {
      value: {
        type: Number,
        default: 0
      },

      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },

      color: String,
      centerColor: String,
      trackColor: String,

      fontSize: String,

      // ratio
      thickness: {
        type: Number,
        default: 0.2,
        validator: v => v >= 0 && v <= 1
      },

      angle: {
        type: Number,
        default: 0
      },

      indeterminate: Boolean,
      showValue: Boolean,
      reverse: Boolean,

      instantFeedback: Boolean
    },

    computed: {
      normalizedValue () {
        return between(this.value, this.min, this.max)
      },

      svgStyle () {
        const angle = this.$q.lang.rtl === true ? -this.angle : this.angle;

        return {
          transform: this.reverse !== (this.$q.lang.rtl === true)
            ? `scale3d(-1, 1, 1) rotate3d(0, 0, 1, ${-90 - angle}deg)`
            : `rotate3d(0, 0, 1, ${angle - 90}deg)`
        }
      },

      circleStyle () {
        if (this.instantFeedback !== true && this.indeterminate !== true) {
          return { transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease' }
        }
      },

      viewBox () {
        return diameter / (1 - this.thickness / 2)
      },

      viewBoxAttr () {
        return `${this.viewBox / 2} ${this.viewBox / 2} ${this.viewBox} ${this.viewBox}`
      },

      strokeDashOffset () {
        const progress = 1 - (this.normalizedValue - this.min) / (this.max - this.min);
        return progress * circumference
      },

      strokeWidth () {
        return this.thickness / 2 * this.viewBox
      },

      attrs () {
        return {
          role: 'progressbar',
          'aria-valuemin': this.min,
          'aria-valuemax': this.max,
          'aria-valuenow': this.indeterminate === true ? void 0 : this.normalizedValue
        }
      }
    },

    methods: {
      __getCircle (h, { thickness, offset, color, cls }) {
        return h('circle', {
          staticClass: 'q-circular-progress__' + cls,
          class: color !== void 0 ? `text-${color}` : null,
          style: this.circleStyle,
          attrs: {
            fill: 'transparent',
            stroke: 'currentColor',
            'stroke-width': thickness,
            'stroke-dasharray': strokeDashArray,
            'stroke-dashoffset': offset,
            cx: this.viewBox,
            cy: this.viewBox,
            r: radius
          }
        })
      }
    },

    render (h) {
      const svgChild = [];

      this.centerColor !== void 0 && this.centerColor !== 'transparent' && svgChild.push(
        h('circle', {
          staticClass: 'q-circular-progress__center',
          class: `text-${this.centerColor}`,
          attrs: {
            fill: 'currentColor',
            r: radius - this.strokeWidth / 2,
            cx: this.viewBox,
            cy: this.viewBox
          }
        })
      );

      this.trackColor !== void 0 && this.trackColor !== 'transparent' && svgChild.push(
        this.__getCircle(h, {
          cls: 'track',
          thickness: this.strokeWidth,
          offset: 0,
          color: this.trackColor
        })
      );

      svgChild.push(
        this.__getCircle(h, {
          cls: 'circle',
          thickness: this.strokeWidth,
          offset: this.strokeDashOffset,
          color: this.color
        })
      );

      const child = [
        h('svg', {
          staticClass: 'q-circular-progress__svg',
          style: this.svgStyle,
          attrs: {
            focusable: 'false' /* needed for IE11 */,
            viewBox: this.viewBoxAttr,
            'aria-hidden': 'true'
          }
        }, svgChild)
      ];

      this.showValue === true && child.push(
        h('div', {
          staticClass: 'q-circular-progress__text absolute-full row flex-center content-center',
          style: { fontSize: this.fontSize }
        }, this.$scopedSlots.default !== void 0 ? this.$scopedSlots.default() : [ h('div', [ this.normalizedValue ]) ])
      );

      return h('div', {
        staticClass: 'q-circular-progress',
        class: `q-circular-progress--${this.indeterminate === true ? 'in' : ''}determinate`,
        style: this.sizeStyle,
        on: { ...this.qListeners },
        attrs: this.attrs
      }, mergeSlotSafely(child, this, 'internal'))
    }
  });

  // file referenced from docs

  const
    hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/,
    hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/,
    hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/,
    rgb = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/,
    rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/;

  const testPattern = {
    date: v => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v),
    time: v => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(v),
    fulltime: v => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(v),
    timeOrFulltime: v => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(v),

    // -- RFC 5322 --
    // -- Added in v1.18.10 --
    // This is a basic helper validation.
    // For something more complex (like RFC 822) you should write and use your own rule.
    // We won't be accepting PRs to enhance the one below because of the reason above.
    email: v => /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v),

    hexColor: v => hex.test(v),
    hexaColor: v => hexa.test(v),
    hexOrHexaColor: v => hexOrHexa.test(v),

    rgbColor: v => rgb.test(v),
    rgbaColor: v => rgba.test(v),
    rgbOrRgbaColor: v => rgb.test(v) || rgba.test(v),

    hexOrRgbColor: v => hex.test(v) || rgb.test(v),
    hexaOrRgbaColor: v => hexa.test(v) || rgba.test(v),
    anyColor: v => hexOrHexa.test(v) || rgb.test(v) || rgba.test(v)
  };

  var patterns = {
    testPattern
  };

  function getChanges (evt, ctx, isFinal) {
    const pos = position(evt);
    let
      dir,
      distX = pos.left - ctx.event.x,
      distY = pos.top - ctx.event.y,
      absX = Math.abs(distX),
      absY = Math.abs(distY);

    const direction = ctx.direction;

    if (direction.horizontal === true && direction.vertical !== true) {
      dir = distX < 0 ? 'left' : 'right';
    }
    else if (direction.horizontal !== true && direction.vertical === true) {
      dir = distY < 0 ? 'up' : 'down';
    }
    else if (direction.up === true && distY < 0) {
      dir = 'up';
      if (absX > absY) {
        if (direction.left === true && distX < 0) {
          dir = 'left';
        }
        else if (direction.right === true && distX > 0) {
          dir = 'right';
        }
      }
    }
    else if (direction.down === true && distY > 0) {
      dir = 'down';
      if (absX > absY) {
        if (direction.left === true && distX < 0) {
          dir = 'left';
        }
        else if (direction.right === true && distX > 0) {
          dir = 'right';
        }
      }
    }
    else if (direction.left === true && distX < 0) {
      dir = 'left';
      if (absX < absY) {
        if (direction.up === true && distY < 0) {
          dir = 'up';
        }
        else if (direction.down === true && distY > 0) {
          dir = 'down';
        }
      }
    }
    else if (direction.right === true && distX > 0) {
      dir = 'right';
      if (absX < absY) {
        if (direction.up === true && distY < 0) {
          dir = 'up';
        }
        else if (direction.down === true && distY > 0) {
          dir = 'down';
        }
      }
    }

    let synthetic = false;

    if (dir === void 0 && isFinal === false) {
      if (ctx.event.isFirst === true || ctx.event.lastDir === void 0) {
        return {}
      }

      dir = ctx.event.lastDir;
      synthetic = true;

      if (dir === 'left' || dir === 'right') {
        pos.left -= distX;
        absX = 0;
        distX = 0;
      }
      else {
        pos.top -= distY;
        absY = 0;
        distY = 0;
      }
    }

    return {
      synthetic,
      payload: {
        evt,
        touch: ctx.event.mouse !== true,
        mouse: ctx.event.mouse === true,
        position: pos,
        direction: dir,
        isFirst: ctx.event.isFirst,
        isFinal: isFinal === true,
        duration: Date.now() - ctx.event.time,
        distance: {
          x: absX,
          y: absY
        },
        offset: {
          x: distX,
          y: distY
        },
        delta: {
          x: pos.left - ctx.event.lastX,
          y: pos.top - ctx.event.lastY
        }
      }
    }
  }

  function destroy$2 (el) {
    const ctx = el.__qtouchpan;
    if (ctx !== void 0) {
      // emit the end event when the directive is destroyed while active
      // this is only needed in TouchPan because the rest of the touch directives do not emit an end event
      // the condition is also checked in the start of function but we avoid the call
      ctx.event !== void 0 && ctx.end();

      cleanEvt(ctx, 'main');
      cleanEvt(ctx, 'temp');

      client.is.firefox === true && preventDraggable(el, false);
      ctx.styleCleanup !== void 0 && ctx.styleCleanup();

      delete el.__qtouchpan;
    }
  }

  let uid = 0;

  var TouchPan = {
    name: 'touch-pan',

    bind (el, { value, modifiers }) {
      if (el.__qtouchpan !== void 0) {
        destroy$2(el);
        el.__qtouchpan_destroyed = true;
      }

      // early return, we don't need to do anything
      if (modifiers.mouse !== true && client.has.touch !== true) {
        return
      }

      function handleEvent (evt, mouseEvent) {
        if (modifiers.mouse === true && mouseEvent === true) {
          stopAndPrevent(evt);
        }
        else {
          modifiers.stop === true && stop(evt);
          modifiers.prevent === true && prevent(evt);
        }
      }

      const ctx = {
        uid: 'qvtp_' + (uid++),
        handler: value,
        modifiers,
        direction: getModifierDirections(modifiers),

        noop,

        mouseStart (evt) {
          if (shouldStart(evt, ctx) && leftClick(evt)) {
            addEvt(ctx, 'temp', [
              [ document, 'mousemove', 'move', 'notPassiveCapture' ],
              [ document, 'mouseup', 'end', 'passiveCapture' ]
            ]);

            ctx.start(evt, true);
          }
        },

        touchStart (evt) {
          if (shouldStart(evt, ctx)) {
            const target = evt.target;

            addEvt(ctx, 'temp', [
              [ target, 'touchmove', 'move', 'notPassiveCapture' ],
              [ target, 'touchcancel', 'end', 'passiveCapture' ],
              [ target, 'touchend', 'end', 'passiveCapture' ]
            ]);

            ctx.start(evt);
          }
        },

        start (evt, mouseEvent) {
          client.is.firefox === true && preventDraggable(el, true);
          ctx.lastEvt = evt;

          const pos = position(evt);

          /*
           * Stop propagation so possible upper v-touch-pan don't catch this as well;
           * If we're not the target (based on modifiers), we'll re-emit the event later
           */
          if (mouseEvent === true || modifiers.stop === true) {
            /*
             * are we directly switching to detected state?
             * clone event only otherwise
             */
            if (
              ctx.direction.all !== true &&
              (mouseEvent !== true || ctx.direction.mouseAllDir !== true)
            ) {
              const clone = evt.type.indexOf('mouse') > -1
                ? new MouseEvent(evt.type, evt)
                : new TouchEvent(evt.type, evt);

              evt.defaultPrevented === true && prevent(clone);
              evt.cancelBubble === true && stop(clone);

              clone.qClonedBy = evt.qClonedBy === void 0
                ? [ctx.uid]
                : evt.qClonedBy.concat(ctx.uid);
              clone.qKeyEvent = evt.qKeyEvent;
              clone.qClickOutside = evt.qClickOutside;

              ctx.initialEvent = {
                target: evt.target,
                event: clone
              };
            }

            stop(evt);
          }

          ctx.event = {
            x: pos.left,
            y: pos.top,
            time: Date.now(),
            mouse: mouseEvent === true,
            detected: false,
            isFirst: true,
            isFinal: false,
            lastX: pos.left,
            lastY: pos.top
          };
        },

        move (evt) {
          if (ctx.event === void 0) {
            return
          }

          ctx.lastEvt = evt;

          const isMouseEvt = ctx.event.mouse === true;
          const start = () => {
            handleEvent(evt, isMouseEvt);

            if (modifiers.preserveCursor !== true) {
              document.documentElement.style.cursor = 'grabbing';
            }
            isMouseEvt === true && document.body.classList.add('no-pointer-events--children');
            document.body.classList.add('non-selectable');
            clearSelection();

            ctx.styleCleanup = withDelayedFn => {
              ctx.styleCleanup = void 0;

              if (modifiers.preserveCursor !== true) {
                document.documentElement.style.cursor = '';
              }
              document.body.classList.remove('non-selectable');

              if (isMouseEvt === true) {
                const remove = () => {
                  document.body.classList.remove('no-pointer-events--children');
                };

                if (withDelayedFn !== void 0) {
                  setTimeout(() => {
                    remove();
                    withDelayedFn();
                  }, 50);
                }
                else { remove(); }
              }
              else if (withDelayedFn !== void 0) {
                withDelayedFn();
              }
            };
          };

          if (ctx.event.detected === true) {
            ctx.event.isFirst !== true && handleEvent(evt, ctx.event.mouse);

            const { payload, synthetic } = getChanges(evt, ctx, false);

            if (payload !== void 0) {
              if (ctx.handler(payload) === false) {
                ctx.end(evt);
              }
              else {
                if (ctx.styleCleanup === void 0 && ctx.event.isFirst === true) {
                  start();
                }

                ctx.event.lastX = payload.position.left;
                ctx.event.lastY = payload.position.top;
                ctx.event.lastDir = synthetic === true ? void 0 : payload.direction;
                ctx.event.isFirst = false;
              }
            }

            return
          }

          if (
            ctx.direction.all === true ||
            (isMouseEvt === true && ctx.modifiers.mouseAllDir === true)
          ) {
            start();
            ctx.event.detected = true;
            ctx.move(evt);
            return
          }

          const
            pos = position(evt),
            distX = pos.left - ctx.event.x,
            distY = pos.top - ctx.event.y,
            absX = Math.abs(distX),
            absY = Math.abs(distY);

          if (absX !== absY) {
            if (
              (ctx.direction.horizontal === true && absX > absY) ||
              (ctx.direction.vertical === true && absX < absY) ||
              (ctx.direction.up === true && absX < absY && distY < 0) ||
              (ctx.direction.down === true && absX < absY && distY > 0) ||
              (ctx.direction.left === true && absX > absY && distX < 0) ||
              (ctx.direction.right === true && absX > absY && distX > 0)
            ) {
              ctx.event.detected = true;
              ctx.move(evt);
            }
            else {
              ctx.end(evt, true);
            }
          }
        },

        end (evt, abort) {
          if (ctx.event === void 0) {
            return
          }

          cleanEvt(ctx, 'temp');
          client.is.firefox === true && preventDraggable(el, false);

          if (abort === true) {
            ctx.styleCleanup !== void 0 && ctx.styleCleanup();

            if (ctx.event.detected !== true && ctx.initialEvent !== void 0) {
              ctx.initialEvent.target.dispatchEvent(ctx.initialEvent.event);
            }
          }
          else if (ctx.event.detected === true) {
            ctx.event.isFirst === true && ctx.handler(getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx).payload);

            const { payload } = getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx, true);
            const fn = () => { ctx.handler(payload); };

            if (ctx.styleCleanup !== void 0) {
              ctx.styleCleanup(fn);
            }
            else {
              fn();
            }
          }

          ctx.event = void 0;
          ctx.initialEvent = void 0;
          ctx.lastEvt = void 0;
        }
      };

      el.__qtouchpan = ctx;

      modifiers.mouse === true && addEvt(ctx, 'main', [
        [ el, 'mousedown', 'mouseStart', `passive${modifiers.mouseCapture === true ? 'Capture' : ''}` ]
      ]);

      client.has.touch === true && addEvt(ctx, 'main', [
        [ el, 'touchstart', 'touchStart', `passive${modifiers.capture === true ? 'Capture' : ''}` ],
        [ el, 'touchmove', 'noop', 'notPassiveCapture' ]
      ]);
    },

    update (el, { oldValue, value }) {
      const ctx = el.__qtouchpan;
      if (ctx !== void 0 && oldValue !== value) {
        typeof value !== 'function' && ctx.end();
        ctx.handler = value;
      }
    },

    unbind (el) {
      if (el.__qtouchpan_destroyed === void 0) {
        destroy$2(el);
      }
      else {
        delete el.__qtouchpan_destroyed;
      }
    }
  };

  const markerPrefixClass = 'q-slider__marker-labels';
  const defaultMarkerConvertFn = v => ({ value: v });

  // PGDOWN, LEFT, DOWN, PGUP, RIGHT, UP
  const keyCodes = [ 34, 37, 40, 33, 39, 38 ];

  const SliderMixin = {
    mixins: [ DarkMixin, FormMixin ],

    directives: {
      TouchPan
    },

    props: {
      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },
      innerMin: Number,
      innerMax: Number,

      step: {
        type: Number,
        default: 1,
        validator: v => v >= 0
      },

      snap: Boolean,

      vertical: Boolean,
      reverse: Boolean,

      hideSelection: Boolean,

      color: String,
      markerLabelsClass: String,

      label: Boolean,
      labelColor: String,
      labelTextColor: String,
      labelAlways: Boolean,
      switchLabelSide: Boolean,

      markers: [ Boolean, Number ],
      markerLabels: [ Boolean, Array, Object, Function ],
      switchMarkerLabelsSide: Boolean,

      trackImg: String,
      trackColor: String,
      innerTrackImg: String,
      innerTrackColor: String,
      selectionColor: String,
      selectionImg: String,

      thumbSize: {
        type: String,
        default: '20px'
      },
      trackSize: {
        type: String,
        default: '4px'
      },

      disable: Boolean,
      readonly: Boolean,
      dense: Boolean,

      tabindex: [ String, Number ],

      thumbColor: String,
      thumbPath: {
        type: String,
        default: 'M 4, 10 a 6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0'
      }
    },

    data () {
      return {
        active: false,
        preventFocus: false,
        focus: false,
        dragging: false
      }
    },

    computed: {
      axis () {
        return this.vertical === true ? '--v' : '--h'
      },

      labelSide () {
        return '-' + (this.switchLabelSide === true ? 'switched' : 'standard')
      },

      isReversed () {
        return this.vertical === true
          ? this.reverse === true
          : this.reverse !== (this.$q.lang.rtl === true)
      },

      computedInnerMin () {
        return this.__getInnerMin(this.innerMin)
      },

      computedInnerMax () {
        return this.__getInnerMax(this.innerMax)
      },

      editable () {
        return this.disable !== true && this.readonly !== true &&
          this.computedInnerMin < this.computedInnerMax
      },

      computedDecimals () {
        return (String(this.step).trim('0').split('.')[ 1 ] || '').length
      },

      computedStep () {
        return this.step === 0 ? 1 : this.step
      },

      computedTabindex () {
        return this.editable === true ? this.tabindex || 0 : -1
      },

      trackLen () {
        return this.max - this.min
      },

      innerBarLen () {
        return this.computedInnerMax - this.computedInnerMin
      },

      innerMinRatio () {
        return this.__convertModelToRatio(this.computedInnerMin)
      },

      innerMaxRatio () {
        return this.__convertModelToRatio(this.computedInnerMax)
      },

      positionProp () {
        return this.vertical === true
          ? (this.isReversed === true ? 'bottom' : 'top')
          : (this.isReversed === true ? 'right' : 'left')
      },

      sizeProp () {
        return this.vertical === true ? 'height' : 'width'
      },

      thicknessProp () {
        return this.vertical === true ? 'width' : 'height'
      },

      orientation () {
        return this.vertical === true ? 'vertical' : 'horizontal'
      },

      attributes () {
        const acc = {
          role: 'slider',
          'aria-valuemin': this.computedInnerMin,
          'aria-valuemax': this.computedInnerMax,
          'aria-orientation': this.orientation,
          'data-step': this.step
        };

        if (this.disable === true) {
          acc[ 'aria-disabled' ] = 'true';
        }
        else if (this.readonly === true) {
          acc[ 'aria-readonly' ] = 'true';
        }

        return acc
      },

      classes () {
        return `q-slider q-slider${this.axis} q-slider--${this.active === true ? '' : 'in'}active inline no-wrap ` +
          (this.vertical === true ? 'row' : 'column') +
          (this.disable === true ? ' disabled' : ' q-slider--enabled' + (this.editable === true ? ' q-slider--editable' : '')) +
          (this.focus === 'both' ? ' q-slider--focus' : '') +
          (this.label || this.labelAlways === true ? ' q-slider--label' : '') +
          (this.labelAlways === true ? ' q-slider--label-always' : '') +
          (this.isDark === true ? ' q-slider--dark' : '') +
          (this.dense === true ? ' q-slider--dense q-slider--dense' + this.axis : '')
      },

      selectionBarClass () {
        const color = this.selectionColor || this.color;
        return 'q-slider__selection absolute' +
          (color !== void 0 ? ` text-${color}` : '')
      },

      markerClass () {
        return this.__getAxisClass('markers') + ' absolute overflow-hidden'
      },
      trackContainerClass () {
        return this.__getAxisClass('track-container')
      },
      pinClass () {
        return this.__getPositionClass('pin')
      },
      labelClass () {
        return this.__getPositionClass('label')
      },
      textContainerClass () {
        return this.__getPositionClass('text-container')
      },
      markerLabelsContainerClass () {
        return this.__getPositionClass('marker-labels-container') +
          (this.markerLabelsClass !== void 0 ? ` ${this.markerLabelsClass}` : '')
      },

      trackClass () {
        return 'q-slider__track relative-position no-outline' +
          (this.trackColor !== void 0 ? ` bg-${this.trackColor}` : '')
      },
      trackStyle () {
        const acc = { [ this.thicknessProp ]: this.trackSize };
        if (this.trackImg !== void 0) {
          acc.backgroundImage = `url(${this.trackImg}) !important`;
        }
        return acc
      },

      innerBarClass () {
        return 'q-slider__inner absolute' +
          (this.innerTrackColor !== void 0 ? ` bg-${this.innerTrackColor}` : '')
      },

      innerBarStyle () {
        const acc = {
          [ this.positionProp ]: `${100 * this.innerMinRatio}%`,
          [ this.sizeProp ]: `${100 * (this.innerMaxRatio - this.innerMinRatio)}%`
        };
        if (this.innerTrackImg !== void 0) {
          acc.backgroundImage = `url(${this.innerTrackImg}) !important`;
        }
        return acc
      },

      markerStep () {
        return isNumber(this.markers) === true ? this.markers : this.computedStep
      },

      markerTicks () {
        const acc = [];
        const step = this.markerStep;

        let value = this.min;
        do {
          acc.push(value);
          value += step;
        } while (value < this.max)

        acc.push(this.max);
        return acc
      },

      markerLabelClass () {
        const prefix = ` ${markerPrefixClass}${this.axis}-`;
        return markerPrefixClass +
          `${prefix}${this.switchMarkerLabelsSide === true ? 'switched' : 'standard'}` +
          `${prefix}${this.isReversed === true ? 'rtl' : 'ltr'}`
      },

      markerLabelsList () {
        if (this.markerLabels === false) { return null }

        return this.__getMarkerList(this.markerLabels).map((entry, index) => ({
          index,
          value: entry.value,
          label: entry.label || entry.value,
          classes: this.markerLabelClass +
            (entry.classes !== void 0 ? ' ' + entry.classes : ''),
          style: {
            ...this.__getMarkerLabelStyle(entry.value),
            ...(entry.style || {})
          }
        }))
      },

      markerScope () {
        return {
          markerList: this.markerLabelsList,
          markerMap: this.markerLabelsMap,
          classes: this.markerLabelClass,
          getStyle: this.__getMarkerLabelStyle
        }
      },

      markerStyle () {
        if (this.innerBarLen !== 0) {
          const size = 100 * this.markerStep / this.innerBarLen;

          return {
            ...this.innerBarStyle,
            backgroundSize: this.vertical === true
              ? `2px ${size}%`
              : `${size}% 2px`
          }
        }

        return null
      },

      markerLabelsMap () {
        if (this.markerLabels === false) { return null }

        const acc = {};
        this.markerLabelsList.forEach(entry => {
          acc[ entry.value ] = entry;
        });
        return acc
      },

      panDirectives () {
        return this.editable === true
          ? [{
            name: 'touch-pan',
            value: this.__onPan,
            modifiers: {
              [ this.orientation ]: true,
              prevent: true,
              stop: true,
              mouse: true,
              mouseAllDir: true
            }
          }]
          : null
      }
    },

    methods: {
      __getInnerMin (val) {
        return isNaN(val) === true || this.innerMin < this.min
          ? this.min
          : this.innerMin
      },

      __getInnerMax (val) {
        return isNaN(val) === true || val > this.max
          ? this.max
          : this.innerMax
      },

      __getPositionClass (name) {
        const cls = 'q-slider__' + name;
        return `${cls} ${cls}${this.axis} ${cls}${this.axis}${this.labelSide}`
      },

      __getAxisClass (name) {
        const cls = 'q-slider__' + name;
        return `${cls} ${cls}${this.axis}`
      },

      __convertRatioToModel (ratio) {
        let model = this.min + ratio * (this.max - this.min);

        if (this.step > 0) {
          const modulo = (model - this.min) % this.step;
          model += (Math.abs(modulo) >= this.step / 2 ? (modulo < 0 ? -1 : 1) * this.step : 0) - modulo;
        }

        if (this.computedDecimals > 0) {
          model = parseFloat(model.toFixed(this.computedDecimals));
        }

        return between(model, this.computedInnerMin, this.computedInnerMax)
      },

      __convertModelToRatio (model) {
        return this.trackLen === 0
          ? 0
          : (model - this.min) / this.trackLen
      },

      __getDraggingRatio (evt, dragging) {
        const
          pos = position(evt),
          val = this.vertical === true
            ? between((pos.top - dragging.top) / dragging.height, 0, 1)
            : between((pos.left - dragging.left) / dragging.width, 0, 1);

        return between(
          this.isReversed === true ? 1.0 - val : val,
          this.innerMinRatio,
          this.innerMaxRatio
        )
      },

      __getMarkerList (def) {
        if (def === false) { return null }

        if (def === true) {
          return this.markerTicks.map(defaultMarkerConvertFn)
        }

        if (typeof def === 'function') {
          return this.markerTicks.map(value => {
            const item = def(value);
            return isObject(item) === true ? { ...item, value } : { value, label: item }
          })
        }

        const filterFn = ({ value }) => value >= this.min && value <= this.max;

        if (Array.isArray(def) === true) {
          return def
            .map(item => (isObject(item) === true ? item : { value: item }))
            .filter(filterFn)
        }

        return Object.keys(def).map(key => {
          const item = def[ key ];
          const value = Number(key);
          return isObject(item) === true ? { ...item, value } : { value, label: item }
        }).filter(filterFn)
      },

      __getMarkerLabelStyle (val) {
        return { [ this.positionProp ]: `${100 * (val - this.min) / this.trackLen}%` }
      },

      __getMarkerLabelsContent (h) {
        if (this.$scopedSlots[ 'marker-label-group' ] !== void 0) {
          return this.$scopedSlots[ 'marker-label-group' ](this.markerScope)
        }

        const fn = this.$scopedSlots[ 'marker-label' ];
        if (fn !== void 0) {
          return this.markerLabelsList.map(marker => fn({
            marker,
            ...this.markerScope
          }))
        }

        return this.markerLabelsList.map(marker => h('div', {
          key: marker.value,
          style: marker.style,
          class: marker.classes
        }, marker.label))
      },

      __onPan (event) {
        if (event.isFinal === true) {
          if (this.dragging !== void 0) {
            this.__updatePosition(event.evt);
            // only if touch, because we also have mousedown/up:
            event.touch === true && this.__updateValue(true);
            this.dragging = void 0;
            this.$emit('pan', 'end');
          }
          this.active = false;
          this.focus = false;
        }
        else if (event.isFirst === true) {
          this.dragging = this.__getDragging(event.evt);
          this.__updatePosition(event.evt);
          this.__updateValue();
          this.active = true;
          this.$emit('pan', 'start');
        }
        else {
          this.__updatePosition(event.evt);
          this.__updateValue();
        }
      },

      __onBlur () {
        this.focus = false;
      },

      __onActivate (evt) {
        this.__updatePosition(evt, this.__getDragging(evt));
        this.__updateValue();

        this.preventFocus = true;
        this.active = true;

        document.addEventListener('mouseup', this.__onDeactivate, true);
      },

      __onDeactivate () {
        this.preventFocus = false;
        this.active = false;

        this.__updateValue(true);
        this.__onBlur();

        document.removeEventListener('mouseup', this.__onDeactivate, true);
      },

      __onMobileClick (evt) {
        this.__updatePosition(evt, this.__getDragging(evt));
        this.__updateValue(true);
      },

      __onKeyup (evt) {
        if (keyCodes.includes(evt.keyCode)) {
          this.__updateValue(true);
        }
      },

      __getTextContainerStyle (ratio) {
        if (this.vertical === true) { return null }

        const p = this.$q.lang.rtl !== this.reverse ? 1 - ratio : ratio;
        return {
          transform: `translateX(calc(${2 * p - 1} * ${this.thumbSize} / 2 + ${50 - 100 * p}%))`
        }
      },

      __getThumb (h, thumb) {
        const thumbContent = [
          h('svg', {
            class: 'q-slider__thumb-shape absolute-full',
            attrs: {
              viewBox: '0 0 20 20',
              'aria-hidden': 'true'
            }
          }, [
            h('path', {
              attrs: { d: this.thumbPath }
            })
          ]),

          h('div', { class: 'q-slider__focus-ring fit' })
        ];

        if (this.label === true || this.labelAlways === true) {
          thumbContent.push(
            h('div', {
              class: this.pinClass + ' absolute fit no-pointer-events' + thumb.pinColor
            }, [
              h('div', {
                class: this.labelClass,
                style: { minWidth: this.thumbSize }
              }, [
                h('div', {
                  class: this.textContainerClass,
                  style: thumb.textContainerStyle
                }, [
                  h('span', { class: thumb.textClass }, thumb.label)
                ])
              ])
            ])
          );

          if (this.name !== void 0 && this.disable !== true) {
            this.__injectFormInput(thumbContent, 'push');
          }
        }

        return h('div', {
          class: thumb.classes,
          style: thumb.style,
          ...thumb.nodeData
        }, thumbContent)
      },

      __getContent (h, injectThumb) {
        const trackContent = [];

        this.innerTrackColor !== 'transparent' && trackContent.push(
          h('div', {
            key: 'inner',
            class: this.innerBarClass,
            style: this.innerBarStyle
          })
        );

        this.selectionColor !== 'transparent' && trackContent.push(
          h('div', {
            key: 'selection',
            class: this.selectionBarClass,
            style: this.selectionBarStyle
          })
        );

        this.markers !== false && trackContent.push(
          h('div', {
            key: 'marker',
            class: this.markerClass,
            style: this.markerStyle
          })
        );

        injectThumb(trackContent);

        const content = [
          h(
            'div',
            {
              key: 'trackC',
              class: this.trackContainerClass,
              attrs: this.trackContainerAttrs,
              on: this.trackContainerEvents,
              directives: this.panDirectives
            },
            [
              h('div', {
                class: this.trackClass,
                style: this.trackStyle
              }, trackContent)
            ]
          )
        ];

        if (this.markerLabels !== false) {
          const action = this.switchMarkerLabelsSide === true
            ? 'unshift'
            : 'push';

          content[ action ](
            h('div', {
              key: 'markerL',
              class: this.markerLabelsContainerClass
            }, this.__getMarkerLabelsContent(h))
          );
        }

        return content
      }
    },

    beforeDestroy () {
      document.removeEventListener('mouseup', this.__onDeactivate, true);
    }
  };

  var QSlider = Vue.extend({
    name: 'QSlider',

    mixins: [ SliderMixin ],

    props: {
      value: {
        required: true,
        default: null,
        validator: v => typeof v === 'number' || v === null
      },

      labelValue: [ String, Number ]
    },

    data () {
      const innerMin = this.__getInnerMin(this.innerMin);
      const innerMax = this.__getInnerMax(this.innerMax);
      return {
        model: this.value === null ? innerMin : between(this.value, innerMin, innerMax),
        curRatio: 0
      }
    },

    computed: {
      modelRatio () {
        return this.__convertModelToRatio(this.model)
      },

      ratio () {
        return this.active === true ? this.curRatio : this.modelRatio
      },

      selectionBarStyle () {
        const acc = {
          [ this.positionProp ]: `${100 * this.innerMinRatio}%`,
          [ this.sizeProp ]: `${100 * (this.ratio - this.innerMinRatio)}%`
        };
        if (this.selectionImg !== void 0) {
          acc.backgroundImage = `url(${this.selectionImg}) !important`;
        }
        return acc
      },

      thumbLabel () {
        return this.labelValue !== void 0
          ? this.labelValue
          : this.model
      },

      thumbClasses () {
        const color = this.thumbColor || this.color;
        return `q-slider__thumb q-slider__thumb${this.axis} q-slider__thumb${this.axis}-${this.isReversed === true ? 'rtl' : 'ltr'} absolute non-selectable` +
          (
            this.preventFocus === false && this.focus === true
              ? ' q-slider--focus'
              : ''
          ) +
          (color !== void 0 ? ` text-${color}` : '')
      },

      thumbStyle () {
        return {
          width: this.thumbSize,
          height: this.thumbSize,
          [ this.positionProp ]: `${100 * this.ratio}%`
        }
      },

      thumbPinColor () {
        return this.labelColor !== void 0
          ? ` text-${this.labelColor}`
          : ''
      },

      thumbTextContainerStyle () {
        return this.__getTextContainerStyle(this.ratio)
      },

      thumbTextClass () {
        return 'q-slider__text' +
          (this.labelTextColor !== void 0 ? ` text-${this.labelTextColor}` : '')
      },

      trackContainerEvents () {
        if (this.editable !== true) {
          return {}
        }

        return this.$q.platform.is.mobile === true
          ? { click: this.__onMobileClick }
          : {
            mousedown: this.__onActivate,
            focus: this.__onFocus,
            blur: this.__onBlur,
            keydown: this.__onKeydown,
            keyup: this.__onKeyup
          }
      },

      trackContainerAttrs () {
        return {
          tabindex: this.$q.platform.is.mobile !== true
            ? this.computedTabindex
            : null
        }
      },

      modelUpdate () {
        return `${this.value}|${this.computedInnerMin}|${this.computedInnerMax}`
      }
    },

    watch: {
      modelUpdate () {
        this.model = this.value === null
          ? this.computedInnerMin
          : between(this.value, this.computedInnerMin, this.computedInnerMax);
      }
    },

    methods: {
      __updateValue (change) {
        if (this.model !== this.value) {
          this.$emit('input', this.model);
        }
        change === true && this.$emit('change', this.model);
      },

      __getDragging () {
        return this.$el.getBoundingClientRect()
      },

      __updatePosition (event, dragging = this.dragging) {
        const ratio = this.__getDraggingRatio(event, dragging);

        this.model = this.__convertRatioToModel(ratio);
        this.curRatio = this.snap !== true || this.computedStep === 0
          ? ratio
          : this.__convertModelToRatio(this.model);
      },

      __onFocus () {
        this.focus = true;
      },

      __onKeydown (evt) {
        if (!keyCodes.includes(evt.keyCode)) {
          return
        }

        stopAndPrevent(evt);

        const
          step = ([34, 33].includes(evt.keyCode) ? 10 : 1) * this.computedStep,
          offset = ([ 34, 37, 40 ].includes(evt.keyCode) ? -1 : 1) * (this.isReversed === true ? -1 : 1) * step;

        this.model = between(
          parseFloat((this.model + offset).toFixed(this.computedDecimals)),
          this.computedInnerMin,
          this.computedInnerMax
        );

        this.__updateValue();
      }
    },

    render (h) {
      const content = this.__getContent(h, node => {
        node.push(
          this.__getThumb(h, {
            pinColor: this.thumbPinColor,
            textContainerStyle: this.thumbTextContainerStyle,
            textClass: this.thumbTextClass,
            label: this.thumbLabel,
            classes: this.thumbClasses,
            style: this.thumbStyle,
            nodeData: {}
          })
        );
      });

      return h('div', {
        class: this.classes + (this.value === null ? ' q-slider--no-value' : ''),
        attrs: {
          ...this.attributes,
          'aria-valuenow': this.value
        }
      }, content)
    }
  });

  // using it to manage SSR rendering with best performance

  var CanRenderMixin = {
    data () {
      return {
        canRender: !onSSR
      }
    },

    mounted () {
      this.canRender === false && (this.canRender = true);
    }
  };

  var QResizeObserver = Vue.extend({
    name: 'QResizeObserver',

    mixins: [ CanRenderMixin ],

    props: {
      debounce: {
        type: [ String, Number ],
        default: 100
      }
    },

    data () {
      return this.hasObserver === true
        ? {}
        : { url: this.$q.platform.is.ie === true ? null : 'about:blank' }
    },

    methods: {
      trigger (immediately) {
        if (immediately === true || this.debounce === 0 || this.debounce === '0') {
          this.__emit();
        }
        else if (this.timer === null) {
          this.timer = setTimeout(this.__emit, this.debounce);
        }
      },

      __emit () {
        if (this.timer !== null) {
          clearTimeout(this.timer);
          this.timer = null;
        }

        if (!this.$el || !this.$el.parentNode) {
          return
        }

        const
          parent = this.$el.parentNode,
          size = {
            width: parent.offsetWidth,
            height: parent.offsetHeight
          };

        if (size.width === this.size.width && size.height === this.size.height) {
          return
        }

        this.size = size;
        this.$emit('resize', this.size);
      },

      __cleanup () {
        if (this.curDocView !== void 0) {
          // iOS is fuzzy, need to check it first
          if (this.curDocView.removeEventListener !== void 0) {
            this.curDocView.removeEventListener('resize', this.trigger, listenOpts.passive);
          }
          this.curDocView = void 0;
        }
      },

      __onObjLoad () {
        this.__cleanup();

        if (this.$el.contentDocument) {
          this.curDocView = this.$el.contentDocument.defaultView;
          this.curDocView.addEventListener('resize', this.trigger, listenOpts.passive);
        }

        this.__emit();
      }
    },

    render (h) {
      if (this.canRender === false || this.hasObserver === true) {
        return
      }

      return h('object', {
        style: this.style,
        attrs: {
          tabindex: -1, // fix for Firefox
          type: 'text/html',
          data: this.url,
          'aria-hidden': 'true'
        },
        on: cache(this, 'load', {
          load: this.__onObjLoad
        })
      })
    },

    beforeCreate () {
      this.size = { width: -1, height: -1 };
      if (isSSR === true) { return }

      this.hasObserver = typeof ResizeObserver !== 'undefined';

      if (this.hasObserver !== true) {
        this.style = `${this.$q.platform.is.ie ? 'visibility:hidden;' : ''}display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;`;
      }
    },

    mounted () {
      this.timer = null;

      if (this.hasObserver === true) {
        this.observer = new ResizeObserver(this.trigger);
        this.observer.observe(this.$el.parentNode);
        this.__emit();
        return
      }

      if (this.$q.platform.is.ie === true) {
        this.url = 'about:blank';
        this.__emit();
      }
      else {
        this.__onObjLoad();
      }
    },

    beforeDestroy () {
      clearTimeout(this.timer);

      if (this.hasObserver === true) {
        if (this.observer !== void 0 && this.$el.parentNode) {
          this.observer.unobserve(this.$el.parentNode);
        }
        return
      }

      this.__cleanup();
    }
  });

  function getIndicatorClass (color, top, vertical) {
    const pos = vertical === true
      ? ['left', 'right']
      : ['top', 'bottom'];

    return `absolute-${top === true ? pos[0] : pos[1]}${color ? ` text-${color}` : ''}`
  }

  function bufferPrioritySort (t1, t2) {
    if (t1.priorityMatched === t2.priorityMatched) {
      return t2.priorityHref - t1.priorityHref
    }
    return t2.priorityMatched - t1.priorityMatched
  }

  function bufferCleanSelected (t) {
    t.selected = false;
    return t
  }

  const
    bufferFilters = [
      t => t.selected === true && t.exact === true && t.redirected !== true,
      t => t.selected === true && t.exact === true,
      t => t.selected === true && t.redirected !== true,
      t => t.selected === true,
      t => t.exact === true && t.redirected !== true,
      t => t.redirected !== true,
      t => t.exact === true,
      t => true
    ],
    bufferFiltersLen = bufferFilters.length;

  var QTabs = Vue.extend({
    name: 'QTabs',

    mixins: [ TimeoutMixin, ListenersMixin ],

    provide () {
      return {
        tabs: this.tabs,
        __recalculateScroll: this.__recalculateScroll,
        __activateTab: this.__activateTab,
        __activateRoute: this.__activateRoute,
        __onKbdNavigate: this.__onKbdNavigate
      }
    },

    props: {
      value: [Number, String],

      align: {
        type: String,
        default: 'center',
        validator: v => ['left', 'center', 'right', 'justify'].includes(v)
      },
      breakpoint: {
        type: [String, Number],
        default: 600
      },

      vertical: Boolean,
      shrink: Boolean,
      stretch: Boolean,

      activeClass: String,
      activeColor: String,
      activeBgColor: String,
      indicatorColor: String,
      leftIcon: String,
      rightIcon: String,

      outsideArrows: Boolean,
      mobileArrows: Boolean,

      switchIndicator: Boolean,

      narrowIndicator: Boolean,
      inlineLabel: Boolean,
      noCaps: Boolean,

      dense: Boolean,

      contentClass: String
    },

    data () {
      return {
        tabs: {
          current: this.value,
          hasFocus: false,
          activeClass: this.activeClass,
          activeColor: this.activeColor,
          activeBgColor: this.activeBgColor,
          indicatorClass: getIndicatorClass(
            this.indicatorColor,
            this.switchIndicator,
            this.vertical
          ),
          narrowIndicator: this.narrowIndicator,
          inlineLabel: this.inlineLabel,
          noCaps: this.noCaps
        },
        scrollable: false,
        startArrow: true,
        endArrow: false,
        justify: false
      }
    },

    watch: {
      value (name) {
        this.__activateTab(name, true, true);
      },

      activeClass (v) {
        this.tabs.activeClass = v;
      },

      activeColor (v) {
        this.tabs.activeColor = v;
      },

      activeBgColor (v) {
        this.tabs.activeBgColor = v;
      },

      vertical (v) {
        this.tabs.indicatorClass = getIndicatorClass(this.indicatorColor, this.switchIndicator, v);
      },

      indicatorColor (v) {
        this.tabs.indicatorClass = getIndicatorClass(v, this.switchIndicator, this.vertical);
      },

      switchIndicator (v) {
        this.tabs.indicatorClass = getIndicatorClass(this.indicatorColor, v, this.vertical);
      },

      narrowIndicator (v) {
        this.tabs.narrowIndicator = v;
      },

      inlineLabel (v) {
        this.tabs.inlineLabel = v;
      },

      noCaps (v) {
        this.tabs.noCaps = v;
      },

      outsideArrows () {
        this.__recalculateScroll();
      },

      arrowsEnabled (v) {
        this.__updateArrows = v === true
          ? this.__updateArrowsFn
          : noop;

        this.__recalculateScroll();
      },

      isRTL () {
        this.__updateArrows();
      }
    },

    computed: {
      arrowsEnabled () {
        return this.$q.platform.is.desktop === true || this.mobileArrows === true
      },

      arrowIcons () {
        const sides = this.isRTL === true
          ? [ 'end', 'start' ]
          : [ 'start', 'end' ];

        return {
          [sides[0]]: this.leftIcon || (this.vertical === true ? this.$q.iconSet.tabs.up : this.$q.iconSet.tabs.left),
          [sides[1]]: this.rightIcon || (this.vertical === true ? this.$q.iconSet.tabs.down : this.$q.iconSet.tabs.right)
        }
      },

      alignClass () {
        const align = this.scrollable === true
          ? 'left'
          : (this.justify === true ? 'justify' : this.align);

        return `q-tabs__content--align-${align}`
      },

      classes () {
        return `q-tabs--${this.scrollable === true ? '' : 'not-'}scrollable` +
          ` q-tabs--${this.vertical === true ? 'vertical' : 'horizontal'}` +
          ` q-tabs__arrows--${this.arrowsEnabled === true && this.outsideArrows === true ? 'outside' : 'inside'}` +
          (this.dense === true ? ' q-tabs--dense' : '') +
          (this.shrink === true ? ' col-shrink' : '') +
          (this.stretch === true ? ' self-stretch' : '')
      },

      innerClass () {
        return this.alignClass +
          (this.contentClass !== void 0 ? ` ${this.contentClass}` : '') +
          (this.$q.platform.is.mobile === true ? ' scroll' : '')
      },

      domProps () {
        return this.vertical === true
          ? { container: 'height', content: 'offsetHeight', scroll: 'scrollHeight' }
          : { container: 'width', content: 'offsetWidth', scroll: 'scrollWidth' }
      },

      isRTL () {
        return this.vertical !== true && this.$q.lang.rtl === true
      },

      __getScrollPosition () {
        return this.vertical === true
          ? el => el.scrollTop
          : (
            this.$q.lang.rtl !== true
              ? el => el.scrollLeft
              : (
                this.rtlHasScrollBug === true
                  ? el => el.scrollWidth - el.clientWidth - el.scrollLeft
                  : el => 1 - el.scrollLeft
              )
          )
      },

      __setScrollPosition () {
        return this.vertical === true
          ? (el, value) => { el.scrollTop = value; }
          : (
            this.$q.lang.rtl !== true
              ? (el, value) => { el.scrollLeft = value; }
              : (
                this.rtlHasScrollBug === true
                  ? (el, value) => { el.scrollLeft = el.scrollWidth - el.clientWidth - value; }
                  : (el, value) => { el.scrollLeft = 1 - value; }
              )
          )
      },

      __getScrollOffset () {
        return this.vertical === true
          ? el => el.offsetTop
          : (
            this.$q.lang.rtl !== true || this.rtlHasScrollBug === true
              ? el => el.offsetLeft
              : el => el.offsetParent.offsetWidth - el.offsetLeft - el.clientWidth
          )
      },

      onEvents () {
        return {
          input: stop,
          ...this.qListeners,
          focusin: this.__onFocusin,
          focusout: this.__onFocusout
        }
      }
    },

    methods: {
      __onFocusin (e) {
        this.tabs.hasFocus = true;
        this.qListeners.focusin !== void 0 && this.$emit('focusin', e);
      },

      __onFocusout (e) {
        this.tabs.hasFocus = false;
        this.qListeners.focusout !== void 0 && this.$emit('focusout', e);
      },

      __activateTab (name, setCurrent, skipEmit) {
        if (this.tabs.current !== name) {
          skipEmit !== true && this.$emit('input', name);
          if (setCurrent === true || this.qListeners.input === void 0) {
            this.__animate(this.tabs.current, name);
            this.tabs.current = name;
          }
        }
      },

      __activateRoute (params) {
        if (this.bufferRoute !== this.$route && this.buffer.length > 0) {
          clearTimeout(this.bufferTimer);
          this.bufferTimer = void 0;
          this.buffer.length = 0;
        }
        this.bufferRoute = this.$route;

        if (params !== void 0) {
          if (params.remove === true) {
            this.buffer = this.buffer.filter(t => t.name !== params.name);
          }
          else {
            this.buffer.push(params);
          }
        }

        if (this.bufferTimer === void 0) {
          this.bufferTimer = setTimeout(() => {
            let tabs = [];

            for (let i = 0; i < bufferFiltersLen && tabs.length === 0; i++) {
              tabs = this.buffer.filter(bufferFilters[i]);
            }

            tabs.sort(bufferPrioritySort);
            this.__activateTab(tabs.length === 0 ? null : tabs[0].name, true);
            this.buffer = this.buffer.map(bufferCleanSelected);
            this.bufferTimer = void 0;
          }, 1);
        }
      },

      __recalculateScroll () {
        this.__nextTick(() => {
          this._isDestroyed !== true && this.__updateContainer({
            width: this.$el.offsetWidth,
            height: this.$el.offsetHeight
          });
        });

        this.__prepareTick();
      },

      __updateContainer (domSize) {
        const
          size = domSize[this.domProps.container],
          scrollSize = Math.min(
            this.$refs.content[this.domProps.scroll],
            Array.prototype.reduce.call(
              this.$refs.content.children,
              (acc, el) => acc + (el[this.domProps.content] || 0),
              0
            )
          ),
          scroll = size > 0 && scrollSize > size; // when there is no tab, in Chrome, size === 0 and scrollSize === 1

        if (this.scrollable !== scroll) {
          this.scrollable = scroll;
        }

        // Arrows need to be updated even if the scroll status was already true
        scroll === true && this.$nextTick(() => this.__updateArrows());

        const justify = size < parseInt(this.breakpoint, 10);

        if (this.justify !== justify) {
          this.justify = justify;
        }
      },

      __animate (oldName, newName) {
        const
          oldTab = oldName !== void 0 && oldName !== null && oldName !== ''
            ? this.$children.find(tab => tab.name === oldName)
            : null,
          newTab = newName !== void 0 && newName !== null && newName !== ''
            ? this.$children.find(tab => tab.name === newName)
            : null;

        if (oldTab && newTab) {
          const
            oldEl = oldTab.$el.getElementsByClassName('q-tab__indicator')[0],
            newEl = newTab.$el.getElementsByClassName('q-tab__indicator')[0];

          clearTimeout(this.animateTimer);

          oldEl.style.transition = 'none';
          oldEl.style.transform = 'none';
          newEl.style.transition = 'none';
          newEl.style.transform = 'none';

          const
            oldPos = oldEl.getBoundingClientRect(),
            newPos = newEl.getBoundingClientRect();

          newEl.style.transform = this.vertical === true
            ? `translate3d(0,${oldPos.top - newPos.top}px,0) scale3d(1,${newPos.height ? oldPos.height / newPos.height : 1},1)`
            : `translate3d(${oldPos.left - newPos.left}px,0,0) scale3d(${newPos.width ? oldPos.width / newPos.width : 1},1,1)`;

          // allow scope updates to kick in (QRouteTab needs more time)
          this.$nextTick(() => {
            this.animateTimer = setTimeout(() => {
              newEl.style.transition = 'transform .25s cubic-bezier(.4, 0, .2, 1)';
              newEl.style.transform = 'none';
            }, 70);
          });
        }

        if (newTab && this.scrollable === true) {
          this.__scrollToTab(newTab.$el, void 0, true);
        }
        else {
          this.__updateArrows();
        }
      },

      __updateArrowsFn () {
        const { content } = this.$refs;

        if (content !== void 0) {
          const
            rect = content.getBoundingClientRect(),
            pos = this.__getScrollPosition(content);

          this.startArrow = pos > (this.isRTL === true ? 1 : 0);
          this.endArrow = this.vertical === true
            ? Math.ceil(pos + rect.height) < content.scrollHeight
            : Math.ceil(pos + rect.width) < content.scrollWidth;
        }
      },

      __animScrollTo (value, onEnd) {
        this.__stopAnimScroll();

        this.__onAnimScrollEnd = onEnd;
        this.__scrollTowards(value);

        this.scrollTimer = setInterval(() => {
          if (this.__scrollTowards(value)) {
            this.__stopAnimScroll();
          }
        }, 5);
      },

      __scrollToStart () {
        this.__animScrollTo(0);
      },

      __scrollToEnd () {
        this.__animScrollTo(Number.MAX_SAFE_INTEGER);
      },

      __stopAnimScroll () {
        clearInterval(this.scrollTimer);

        if (this.__onAnimScrollEnd !== void 0) {
          this.__onAnimScrollEnd();
          this.__onAnimScrollEnd = void 0;
        }
      },

      __scrollTowards (value) {
        const content = this.$refs.content;
        const max = this.vertical === true ? content.scrollHeight - content.offsetHeight : content.scrollWidth - content.offsetWidth;

        let pos = this.__getScrollPosition(content);
        let done = false;

        value = Math.max(0, Math.min(max, value));

        const direction = value < pos ? -1 : 1;

        pos += direction * 5;

        if (
          (direction === -1 && pos <= value) ||
          (direction === 1 && pos >= value)
        ) {
          done = true;
          pos = value;
        }

        this.__setScrollPosition(content, pos);
        this.__updateArrows();

        return done
      },

      __scrollToTab (tab, alignEnd, skipFocus) {
        if (this.$refs.content === void 0) {
          return
        }

        const content = this.$refs.content;
        const startContent = this.__getScrollPosition(content);
        const sizeContent = this.vertical === true ? content.offsetHeight : content.offsetWidth;
        const sizeScroll = this.vertical === true ? content.scrollHeight : content.scrollWidth;

        const startTab = this.__getScrollOffset(tab);
        const endTab = startTab + (this.vertical === true ? tab.offsetHeight : tab.offsetWidth);

        const startsBefore = startTab < startContent;
        const endsAfter = endTab > startContent + sizeContent;

        if (startsBefore !== true && endsAfter !== true) {
          alignEnd = void 0;
        }
        else if (alignEnd === void 0) {
          if (endTab >= sizeScroll - 1) {
            alignEnd = true;
          }
          else if (startsBefore === true || (endsAfter === true && startTab < endTab - sizeContent)) {
            alignEnd = false;
          }
          else if (startsBefore !== endsAfter) {
            alignEnd = endsAfter;
          }
        }

        if (alignEnd !== void 0) {
          this.__animScrollTo(
            alignEnd === true ? (endTab >= sizeScroll - 1 ? sizeScroll : endTab - sizeContent) : (startTab <= 1 ? 0 : startTab),
            skipFocus !== true
              ? () => {
                setTimeout(() => {
                  tab && tab.focus();
                });
              }
              : void 0
          );
        }
        else if (skipFocus !== true) {
          tab.focus();
        }
      },

      __onKbdNavigate (keyCode, fromEl) {
        const matchTab = el => el === fromEl || (el.matches && el.matches('.q-tab.q-focusable') === true);
        const tabs = Array.prototype.filter.call(this.$refs.content.children, matchTab);
        const tabsLength = tabs.length;

        if (tabsLength === 0) {
          return
        }

        if (keyCode === 36) { // Home
          if (tabs[0].contains(document.activeElement) === true) {
            return false
          }

          this.__scrollToTab(tabs[0], false);
          this.__recalculateScroll();

          return true
        }
        if (keyCode === 35) { // End
          if (tabs[tabsLength - 1].contains(document.activeElement) === true) {
            return false
          }

          this.__scrollToTab(tabs[tabsLength - 1], true);
          this.__recalculateScroll();

          return true
        }

        const dirPrev = (this.vertical === true && keyCode === 38 /* ArrowUp */) ||
          (this.vertical !== true && keyCode === 37 /* ArrowLeft */);
        const dirNext = (this.vertical === true && keyCode === 40 /* ArrowDown */) ||
          (this.vertical !== true && keyCode === 39 /* ArrowRight */);
        const dir = dirPrev === true ? -1 : (dirNext === true ? 1 : void 0);

        if (dir !== void 0) {
          const rtlDir = this.isRTL === true ? -1 : 1;
          const index = tabs.indexOf(fromEl) + dir * rtlDir;

          if (
            index < 0 ||
            index >= tabsLength ||
            tabs[index].contains(document.activeElement) === true
          ) {
            return false
          }

          this.__scrollToTab(tabs[index], dir === rtlDir);
          this.__recalculateScroll();

          return true
        }
      }
    },

    created () {
      this.buffer = [];

      this.__updateArrows = this.arrowsEnabled === true
        ? this.__updateArrowsFn
        : noop;
    },

    mounted () {
      this.rtlHasScrollBug = rtlHasScrollBug();
    },

    activated () {
      if (this.shouldActivate !== true) { return }
      this.__recalculateScroll();
    },

    deactivated () {
      this.shouldActivate = true;
    },

    beforeDestroy () {
      clearTimeout(this.bufferTimer);
      clearTimeout(this.animateTimer);
    },

    render (h) {
      const child = [
        h(QResizeObserver, {
          on: cache(this, 'resize', { resize: this.__updateContainer })
        }),

        h('div', {
          ref: 'content',
          staticClass: 'q-tabs__content row no-wrap items-center self-stretch hide-scrollbar relative-position',
          class: this.innerClass,
          on: this.arrowsEnabled === true ? cache(this, 'scroll', { scroll: this.__updateArrowsFn }) : void 0
        }, slot(this, 'default'))
      ];

      this.arrowsEnabled === true && child.push(
        h(QIcon, {
          staticClass: 'q-tabs__arrow q-tabs__arrow--start absolute q-tab__icon',
          class: this.startArrow === true ? '' : 'q-tabs__arrow--faded',
          props: { name: this.arrowIcons.start },
          on: cache(this, 'onS', {
            mousedown: this.__scrollToStart,
            touchstart: this.__scrollToStart,
            mouseup: this.__stopAnimScroll,
            mouseleave: this.__stopAnimScroll,
            touchend: this.__stopAnimScroll
          })
        }),

        h(QIcon, {
          staticClass: 'q-tabs__arrow q-tabs__arrow--end absolute q-tab__icon',
          class: this.endArrow === true ? '' : 'q-tabs__arrow--faded',
          props: { name: this.arrowIcons.end },
          on: cache(this, 'onE', {
            mousedown: this.__scrollToEnd,
            touchstart: this.__scrollToEnd,
            mouseup: this.__stopAnimScroll,
            mouseleave: this.__stopAnimScroll,
            touchend: this.__stopAnimScroll
          })
        })
      );

      return h('div', {
        staticClass: 'q-tabs row no-wrap items-center',
        class: this.classes,
        on: this.onEvents,
        attrs: { role: 'tablist' }
      }, child)
    }
  });

  let uid$1 = 0;

  var QTab = Vue.extend({
    name: 'QTab',

    mixins: [ RippleMixin, ListenersMixin ],

    inject: {
      tabs: {
        default () {
          console.error('QTab/QRouteTab components need to be child of QTabs');
        }
      },
      __activateTab: {},
      __recalculateScroll: {},
      __onKbdNavigate: {}
    },

    props: {
      icon: String,
      label: [Number, String],

      alert: [Boolean, String],
      alertIcon: String,

      name: {
        type: [Number, String],
        default: () => `t_${uid$1++}`
      },

      noCaps: Boolean,

      tabindex: [String, Number],
      disable: Boolean,

      contentClass: String
    },

    computed: {
      isActive () {
        return this.tabs.current === this.name
      },

      classes () {
        return {
          ...(
            this.isActive === true
              ? {
                'q-tab--active': true,
                [this.tabs.activeClass]: this.tabs.activeClass,
                [`text-${this.tabs.activeColor}`]: this.tabs.activeColor,
                [`bg-${this.tabs.activeBgColor}`]: this.tabs.activeBgColor
              }
              : { 'q-tab--inactive': true }
          ),
          'q-tab--full': this.icon && this.label && !this.tabs.inlineLabel,
          'q-tab--no-caps': this.noCaps === true || this.tabs.noCaps === true,
          'q-focusable q-hoverable cursor-pointer': !this.disable,
          disabled: this.disable
        }
      },

      innerClass () {
        return (this.tabs.inlineLabel === true ? 'row no-wrap q-tab__content--inline' : 'column') +
          (this.contentClass !== void 0 ? ` ${this.contentClass}` : '')
      },

      computedTabIndex () {
        return this.disable === true || this.tabs.hasFocus === true
          ? -1
          : this.tabindex || 0
      },

      computedRipple () {
        return this.ripple === false
          ? false
          : Object.assign(
            { keyCodes: [13, 32], early: true },
            this.ripple === true ? {} : this.ripple
          )
      },

      onEvents () {
        return {
          input: stop,
          ...this.qListeners,
          click: this.__activate,
          keydown: this.__onKeydown
        }
      },

      attrs () {
        const attrs = {
          tabindex: this.computedTabIndex,
          role: 'tab',
          'aria-selected': this.isActive === true ? 'true' : 'false'
        };

        if (this.disable === true) {
          attrs['aria-disabled'] = 'true';
        }

        return attrs
      }
    },

    methods: {
      __activate (e, keyboard) {
        if (keyboard !== true && this.$refs.blurTarget !== void 0) {
          this.$refs.blurTarget.focus({ preventScroll: true });
        }

        if (this.disable !== true) {
          this.qListeners.click !== void 0 && this.$emit('click', e);
          this.__activateTab(this.name);
        }
      },

      __onKeydown (e) {
        if (shouldIgnoreKey(e)) {
          return
        }

        if ([ 13, 32 ].indexOf(e.keyCode) !== -1) {
          this.__activate(e, true);
          prevent(e);
        }
        else if (e.keyCode >= 35 && e.keyCode <= 40) {
          this.__onKbdNavigate(e.keyCode, this.$el) === true && stopAndPrevent(e);
        }
      },

      __getContent (h) {
        const
          narrow = this.tabs.narrowIndicator,
          content = [],
          indicator = h('div', {
            staticClass: 'q-tab__indicator',
            class: this.tabs.indicatorClass
          });

        this.icon !== void 0 && content.push(
          h(QIcon, {
            staticClass: 'q-tab__icon',
            props: { name: this.icon }
          })
        );

        this.label !== void 0 && content.push(
          h('div', {
            staticClass: 'q-tab__label'
          }, [ this.label ])
        );

        this.alert !== false && content.push(
          this.alertIcon !== void 0
            ? h(QIcon, {
              staticClass: 'q-tab__alert-icon',
              props: {
                color: this.alert !== true
                  ? this.alert
                  : void 0,
                name: this.alertIcon
              }
            })
            : h('div', {
              staticClass: 'q-tab__alert',
              class: this.alert !== true
                ? `text-${this.alert}`
                : null
            })
        );

        narrow === true && content.push(indicator);

        const node = [
          h('div', { staticClass: 'q-focus-helper', attrs: { tabindex: -1 }, ref: 'blurTarget' }),

          h('div', {
            staticClass: 'q-tab__content self-stretch flex-center relative-position q-anchor--skip non-selectable',
            class: this.innerClass
          }, mergeSlot(content, this, 'default'))
        ];

        narrow === false && node.push(indicator);

        return node
      },

      __renderTab (h, tag) {
        const data = {
          staticClass: 'q-tab relative-position self-stretch flex flex-center text-center no-outline',
          class: this.classes,
          attrs: this.attrs,
          directives: this.ripple === false || this.disable === true ? null : [
            { name: 'ripple', value: this.computedRipple }
          ]
        };

        if (this.hasRouterLink === true) {
          return h(tag, {
            ...data,
            nativeOn: this.onEvents,
            props: this.routerTabLinkProps,
            scopedSlots: {
              default: ({ href, isActive, isExactActive }) => h('a', {
                class: {
                  [this.activeClass]: isActive,
                  [this.exactActiveClass]: isExactActive
                },
                attrs: {
                  ...this.linkProps.attrs,
                  href
                }
              }, this.__getContent(h))
            }
          })
        }

        if (this.hasLink === true) {
          Object.assign(data.attrs, this.linkProps.attrs);
          data.props = this.linkProps.props;
        }
        data.on = this.onEvents;
        return h(tag, data, this.__getContent(h))
      }
    },

    mounted () {
      this.__recalculateScroll();
    },

    beforeDestroy () {
      this.__recalculateScroll();
    },

    render (h) {
      return this.__renderTab(h, 'div')
    }
  });

  var QTabPanels = Vue.extend({
    name: 'QTabPanels',

    mixins: [ DarkMixin, PanelParentMixin ],

    computed: {
      classes () {
        return 'q-tab-panels q-panel-parent' +
          (this.isDark === true ? ' q-tab-panels--dark q-dark' : '')
      }
    },

    methods: {
      __renderPanels (h) {
        return h('div', {
          class: this.classes,
          directives: this.panelDirectives,
          on: { ...this.qListeners }
        }, this.__getPanelContent(h))
      }
    }
  });

  var QTabPanel = Vue.extend({
    name: 'QTabPanel',

    mixins: [ PanelChildMixin ],

    render (h) {
      return h('div', {
        staticClass: 'q-tab-panel',
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  const palette = [
    'rgb(255,204,204)', 'rgb(255,230,204)', 'rgb(255,255,204)', 'rgb(204,255,204)', 'rgb(204,255,230)', 'rgb(204,255,255)', 'rgb(204,230,255)', 'rgb(204,204,255)', 'rgb(230,204,255)', 'rgb(255,204,255)',
    'rgb(255,153,153)', 'rgb(255,204,153)', 'rgb(255,255,153)', 'rgb(153,255,153)', 'rgb(153,255,204)', 'rgb(153,255,255)', 'rgb(153,204,255)', 'rgb(153,153,255)', 'rgb(204,153,255)', 'rgb(255,153,255)',
    'rgb(255,102,102)', 'rgb(255,179,102)', 'rgb(255,255,102)', 'rgb(102,255,102)', 'rgb(102,255,179)', 'rgb(102,255,255)', 'rgb(102,179,255)', 'rgb(102,102,255)', 'rgb(179,102,255)', 'rgb(255,102,255)',
    'rgb(255,51,51)', 'rgb(255,153,51)', 'rgb(255,255,51)', 'rgb(51,255,51)', 'rgb(51,255,153)', 'rgb(51,255,255)', 'rgb(51,153,255)', 'rgb(51,51,255)', 'rgb(153,51,255)', 'rgb(255,51,255)',
    'rgb(255,0,0)', 'rgb(255,128,0)', 'rgb(255,255,0)', 'rgb(0,255,0)', 'rgb(0,255,128)', 'rgb(0,255,255)', 'rgb(0,128,255)', 'rgb(0,0,255)', 'rgb(128,0,255)', 'rgb(255,0,255)',
    'rgb(245,0,0)', 'rgb(245,123,0)', 'rgb(245,245,0)', 'rgb(0,245,0)', 'rgb(0,245,123)', 'rgb(0,245,245)', 'rgb(0,123,245)', 'rgb(0,0,245)', 'rgb(123,0,245)', 'rgb(245,0,245)',
    'rgb(214,0,0)', 'rgb(214,108,0)', 'rgb(214,214,0)', 'rgb(0,214,0)', 'rgb(0,214,108)', 'rgb(0,214,214)', 'rgb(0,108,214)', 'rgb(0,0,214)', 'rgb(108,0,214)', 'rgb(214,0,214)',
    'rgb(163,0,0)', 'rgb(163,82,0)', 'rgb(163,163,0)', 'rgb(0,163,0)', 'rgb(0,163,82)', 'rgb(0,163,163)', 'rgb(0,82,163)', 'rgb(0,0,163)', 'rgb(82,0,163)', 'rgb(163,0,163)',
    'rgb(92,0,0)', 'rgb(92,46,0)', 'rgb(92,92,0)', 'rgb(0,92,0)', 'rgb(0,92,46)', 'rgb(0,92,92)', 'rgb(0,46,92)', 'rgb(0,0,92)', 'rgb(46,0,92)', 'rgb(92,0,92)',
    'rgb(255,255,255)', 'rgb(205,205,205)', 'rgb(178,178,178)', 'rgb(153,153,153)', 'rgb(127,127,127)', 'rgb(102,102,102)', 'rgb(76,76,76)', 'rgb(51,51,51)', 'rgb(25,25,25)', 'rgb(0,0,0)'
  ];

  const thumbPath = 'M5 5 h10 v10 h-10 v-10 z';
  const alphaTrackImg = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAH0lEQVQoU2NkYGAwZkAFZ5G5jPRRgOYEVDeB3EBjBQBOZwTVugIGyAAAAABJRU5ErkJggg==';

  var QColor = Vue.extend({
    name: 'QColor',

    mixins: [ ListenersMixin, DarkMixin, FormMixin ],

    directives: {
      TouchPan
    },

    props: {
      value: String,

      defaultValue: String,
      defaultView: {
        type: String,
        default: 'spectrum',
        validator: v => ['spectrum', 'tune', 'palette'].includes(v)
      },

      formatModel: {
        type: String,
        default: 'auto',
        validator: v => ['auto', 'hex', 'rgb', 'hexa', 'rgba'].includes(v)
      },

      palette: Array,

      noHeader: Boolean,
      noHeaderTabs: Boolean,
      noFooter: Boolean,

      square: Boolean,
      flat: Boolean,
      bordered: Boolean,

      disable: Boolean,
      readonly: Boolean
    },

    data () {
      return {
        topView: this.formatModel === 'auto'
          ? (
            (this.value === void 0 || this.value === null || this.value === '' || this.value.startsWith('#'))
              ? 'hex'
              : 'rgb'
          )
          : (this.formatModel.startsWith('hex') ? 'hex' : 'rgb'),
        view: this.defaultView,
        model: this.__parseModel(this.value || this.defaultValue)
      }
    },

    watch: {
      value (v) {
        const model = this.__parseModel(v || this.defaultValue);
        if (model.hex !== this.model.hex) {
          this.model = model;
        }
      },

      defaultValue (v) {
        if (!this.value && v) {
          const model = this.__parseModel(v);
          if (model.hex !== this.model.hex) {
            this.model = model;
          }
        }
      }
    },

    computed: {
      editable () {
        return this.disable !== true && this.readonly !== true
      },

      forceHex () {
        return this.formatModel === 'auto'
          ? null
          : this.formatModel.indexOf('hex') > -1
      },

      forceAlpha () {
        return this.formatModel === 'auto'
          ? null
          : this.formatModel.indexOf('a') > -1
      },

      isHex () {
        return this.value === void 0 ||
          this.value === null ||
          this.value === '' ||
          this.value.startsWith('#')
      },

      isOutputHex () {
        return this.forceHex !== null
          ? this.forceHex
          : this.isHex
      },

      formAttrs () {
        return {
          type: 'hidden',
          name: this.name,
          value: this.model[ this.isOutputHex === true ? 'hex' : 'rgb' ]
        }
      },

      hasAlpha () {
        if (this.forceAlpha !== null) {
          return this.forceAlpha
        }
        return this.model.a !== void 0
      },

      currentBgColor () {
        return {
          backgroundColor: this.model.rgb || '#000'
        }
      },

      headerClass () {
        const light = this.model.a !== void 0 && this.model.a < 65
          ? true
          : luminosity(this.model) > 0.4;

        return `q-color-picker__header-content--${light ? 'light' : 'dark'}`
      },

      spectrumStyle () {
        return {
          background: `hsl(${this.model.h},100%,50%)`
        }
      },

      spectrumPointerStyle () {
        return {
          top: `${100 - this.model.v}%`,
          [this.$q.lang.rtl === true ? 'right' : 'left']: `${this.model.s}%`
        }
      },

      computedPalette () {
        return this.palette !== void 0 && this.palette.length > 0
          ? this.palette
          : palette
      },

      classes () {
        return 'q-color-picker' +
          (this.bordered === true ? ' q-color-picker--bordered' : '') +
          (this.square === true ? ' q-color-picker--square no-border-radius' : '') +
          (this.flat === true ? ' q-color-picker--flat no-shadow' : '') +
          (this.disable === true ? ' disabled' : '') +
          (this.isDark === true ? ' q-color-picker--dark q-dark' : '')
      },

      attrs () {
        if (this.disable === true) {
          return { 'aria-disabled': 'true' }
        }
        if (this.readonly === true) {
          return { 'aria-readonly': 'true' }
        }
      }
    },

    created () {
      this.__spectrumChange = throttle(this.__spectrumChange, 20);
    },

    render (h) {
      const child = [ this.__getContent(h) ];

      if (this.name !== void 0 && this.disable !== true) {
        this.__injectFormInput(child, 'push');
      }

      this.noHeader !== true && child.unshift(
        this.__getHeader(h)
      );

      this.noFooter !== true && child.push(
        this.__getFooter(h)
      );

      return h('div', {
        class: this.classes,
        attrs: this.attrs,
        on: { ...this.qListeners }
      }, child)
    },

    methods: {
      __getHeader (h) {
        const child = [];

        this.noHeaderTabs !== true && child.push(
          h(QTabs, {
            class: 'q-color-picker__header-tabs',
            props: {
              value: this.topView,
              dense: true,
              align: 'justify'
            },
            on: cache(this, 'topVTab', {
              input: val => { this.topView = val; }
            })
          }, [
            h(QTab, {
              props: {
                label: 'HEX' + (this.hasAlpha === true ? 'A' : ''),
                name: 'hex',
                ripple: false
              }
            }),

            h(QTab, {
              props: {
                label: 'RGB' + (this.hasAlpha === true ? 'A' : ''),
                name: 'rgb',
                ripple: false
              }
            })
          ])
        );

        child.push(
          h('div', {
            staticClass: 'q-color-picker__header-banner row flex-center no-wrap'
          }, [
            h('input', {
              staticClass: 'fit',
              domProps: { value: this.model[this.topView] },
              attrs: this.editable !== true ? {
                readonly: true
              } : null,
              on: cache(this, 'topIn', {
                input: evt => {
                  this.__updateErrorIcon(this.__onEditorChange(evt) === true);
                },
                change: stop,
                blur: evt => {
                  this.__onEditorChange(evt, true) === true && this.$forceUpdate();
                  this.__updateErrorIcon(false);
                }
              })
            }),

            h(QIcon, {
              ref: 'errorIcon',
              staticClass: 'q-color-picker__error-icon absolute no-pointer-events',
              props: { name: this.$q.iconSet.type.negative }
            })
          ])
        );

        return h('div', {
          staticClass: 'q-color-picker__header relative-position overflow-hidden'
        }, [
          h('div', { staticClass: 'q-color-picker__header-bg absolute-full' }),

          h('div', {
            staticClass: 'q-color-picker__header-content',
            class: this.headerClass,
            style: this.currentBgColor
          }, child)
        ])
      },

      __getContent (h) {
        return h(QTabPanels, {
          props: {
            value: this.view,
            animated: true
          }
        }, [
          h(QTabPanel, {
            staticClass: 'q-color-picker__spectrum-tab overflow-hidden',
            props: { name: 'spectrum' }
          }, this.__getSpectrumTab(h)),

          h(QTabPanel, {
            staticClass: 'q-pa-md q-color-picker__tune-tab',
            props: { name: 'tune' }
          }, this.__getTuneTab(h)),

          h(QTabPanel, {
            staticClass: 'q-color-picker__palette-tab',
            props: { name: 'palette' }
          }, this.__getPaletteTab(h))
        ])
      },

      __getFooter (h) {
        return h('div', {
          staticClass: 'q-color-picker__footer relative-position overflow-hidden'
        }, [
          h(QTabs, {
            staticClass: 'absolute-full',
            props: {
              value: this.view,
              dense: true,
              align: 'justify'
            },
            on: cache(this, 'ftIn', {
              input: val => { this.view = val; }
            })
          }, [
            h(QTab, {
              props: {
                icon: this.$q.iconSet.colorPicker.spectrum,
                name: 'spectrum',
                ripple: false
              }
            }),

            h(QTab, {
              props: {
                icon: this.$q.iconSet.colorPicker.tune,
                name: 'tune',
                ripple: false
              }
            }),

            h(QTab, {
              props: {
                icon: this.$q.iconSet.colorPicker.palette,
                name: 'palette',
                ripple: false
              }
            })
          ])
        ])
      },

      __getSpectrumTab (h) {
        return [
          h('div', {
            ref: 'spectrum',
            staticClass: 'q-color-picker__spectrum non-selectable relative-position cursor-pointer',
            style: this.spectrumStyle,
            class: { readonly: this.editable !== true },
            on: this.editable === true
              ? cache(this, 'spectrT', {
                click: this.__spectrumClick,
                mousedown: this.__activate
              })
              : null,
            directives: this.editable === true
              ? cache(this, 'spectrDir', [{
                name: 'touch-pan',
                modifiers: {
                  prevent: true,
                  stop: true,
                  mouse: true
                },
                value: this.__spectrumPan
              }])
              : null
          }, [
            h('div', { style: { paddingBottom: '100%' } }),
            h('div', { staticClass: 'q-color-picker__spectrum-white absolute-full' }),
            h('div', { staticClass: 'q-color-picker__spectrum-black absolute-full' }),
            h('div', {
              staticClass: 'absolute',
              style: this.spectrumPointerStyle
            }, [
              this.model.hex !== void 0 ? h('div', { staticClass: 'q-color-picker__spectrum-circle' }) : null
            ])
          ]),

          h('div', {
            staticClass: 'q-color-picker__sliders'
          }, [
            h(QSlider, {
              staticClass: 'q-color-picker__hue non-selectable',
              props: {
                value: this.model.h,
                min: 0,
                max: 360,
                trackSize: '8px',
                innerTrackColor: 'transparent',
                selectionColor: 'transparent',
                readonly: this.editable !== true,
                thumbPath
              },
              on: cache(this, 'hueSlide', {
                input: this.__onHueChange,
                change: val => this.__onHueChange(val, true)
              })
            }),

            this.hasAlpha === true
              ? h(QSlider, {
                staticClass: 'q-color-picker__alpha non-selectable',
                props: {
                  value: this.model.a,
                  min: 0,
                  max: 100,
                  trackSize: '8px',
                  trackColor: 'white',
                  innerTrackColor: 'transparent',
                  selectionColor: 'transparent',
                  trackImg: alphaTrackImg,
                  readonly: this.editable !== true,
                  hideSelection: true,
                  thumbPath
                },
                on: cache(this, 'alphaSlide', {
                  input: value => this.__onNumericChange(value, 'a', 100),
                  change: value => this.__onNumericChange(value, 'a', 100, void 0, true)
                })
              })
              : null
          ])
        ]
      },

      __getTuneTab (h) {
        const attrs = {
          inputmode: 'numeric',
          maxlength: 3,
          readonly: this.editable !== true
        };

        return [
          h('div', { staticClass: 'row items-center no-wrap' }, [
            h('div', ['R']),
            h(QSlider, {
              props: {
                value: this.model.r,
                min: 0,
                max: 255,
                color: 'red',
                dark: this.isDark,
                readonly: this.editable !== true
              },
              on: cache(this, 'rSlide', {
                input: value => this.__onNumericChange(value, 'r', 255),
                change: value => this.__onNumericChange(value, 'r', 255, void 0, true)
              })
            }),
            h('input', {
              domProps: { value: this.model.r },
              attrs,
              on: cache(this, 'rIn', {
                input: evt => this.__onNumericChange(evt.target.value, 'r', 255, evt),
                change: stop,
                blur: evt => this.__onNumericChange(evt.target.value, 'r', 255, evt, true)
              })
            })
          ]),

          h('div', { staticClass: 'row items-center no-wrap' }, [
            h('div', ['G']),
            h(QSlider, {
              props: {
                value: this.model.g,
                min: 0,
                max: 255,
                color: 'green',
                dark: this.isDark,
                readonly: this.editable !== true
              },
              on: cache(this, 'gSlide', {
                input: value => this.__onNumericChange(value, 'g', 255),
                change: value => this.__onNumericChange(value, 'g', 255, void 0, true)
              })
            }),
            h('input', {
              domProps: { value: this.model.g },
              attrs,
              on: cache(this, 'gIn', {
                input: evt => this.__onNumericChange(evt.target.value, 'g', 255, evt),
                change: stop,
                blur: evt => this.__onNumericChange(evt.target.value, 'g', 255, evt, true)
              })
            })
          ]),

          h('div', { staticClass: 'row items-center no-wrap' }, [
            h('div', ['B']),
            h(QSlider, {
              props: {
                value: this.model.b,
                min: 0,
                max: 255,
                color: 'blue',
                readonly: this.editable !== true,
                dark: this.isDark
              },
              on: cache(this, 'bSlide', {
                input: value => this.__onNumericChange(value, 'b', 255),
                change: value => this.__onNumericChange(value, 'b', 255, void 0, true)
              })
            }),
            h('input', {
              domProps: { value: this.model.b },
              attrs,
              on: cache(this, 'bIn', {
                input: evt => this.__onNumericChange(evt.target.value, 'b', 255, evt),
                change: stop,
                blur: evt => this.__onNumericChange(evt.target.value, 'b', 255, evt, true)
              })
            })
          ]),

          this.hasAlpha === true ? h('div', { staticClass: 'row items-center no-wrap' }, [
            h('div', ['A']),
            h(QSlider, {
              props: {
                value: this.model.a,
                color: 'grey',
                readonly: this.editable !== true,
                dark: this.isDark
              },
              on: cache(this, 'aSlide', {
                input: value => this.__onNumericChange(value, 'a', 100),
                change: value => this.__onNumericChange(value, 'a', 100, void 0, true)
              })
            }),
            h('input', {
              domProps: { value: this.model.a },
              attrs,
              on: cache(this, 'aIn', {
                input: evt => this.__onNumericChange(evt.target.value, 'a', 100, evt),
                change: stop,
                blur: evt => this.__onNumericChange(evt.target.value, 'a', 100, evt, true)
              })
            })
          ]) : null
        ]
      },

      __getPaletteTab (h) {
        return [
          h('div', {
            staticClass: 'row items-center q-color-picker__palette-rows',
            class: this.editable === true
              ? 'q-color-picker__palette-rows--editable'
              : ''
          }, this.computedPalette.map(color => h('div', {
            staticClass: 'q-color-picker__cube col-auto',
            style: { backgroundColor: color },
            on: this.editable === true ? cache(this, 'palette#' + color, {
              click: () => {
                this.__onPalettePick(color);
              }
            }) : null
          })))
        ]
      },

      __onSpectrumChange (left, top, change) {
        const panel = this.$refs.spectrum;
        if (panel === void 0) { return }

        const
          width = panel.clientWidth,
          height = panel.clientHeight,
          rect = panel.getBoundingClientRect();

        let x = Math.min(width, Math.max(0, left - rect.left));

        if (this.$q.lang.rtl === true) {
          x = width - x;
        }

        const
          y = Math.min(height, Math.max(0, top - rect.top)),
          s = Math.round(100 * x / width),
          v = Math.round(100 * Math.max(0, Math.min(1, -(y / height) + 1))),
          rgb = hsvToRgb({
            h: this.model.h,
            s,
            v,
            a: this.hasAlpha === true ? this.model.a : void 0
          });

        this.model.s = s;
        this.model.v = v;
        this.__update(rgb, change);
      },

      __onHueChange (h, change) {
        h = Math.round(h);
        const rgb = hsvToRgb({
          h,
          s: this.model.s,
          v: this.model.v,
          a: this.hasAlpha === true ? this.model.a : void 0
        });

        this.model.h = h;
        this.__update(rgb, change);
      },

      __onNumericChange (value, formatModel, max, evt, change) {
        evt !== void 0 && stop(evt);

        if (!/^[0-9]+$/.test(value)) {
          change === true && this.$forceUpdate();
          return
        }

        const val = Math.floor(Number(value));

        if (val < 0 || val > max) {
          change === true && this.$forceUpdate();
          return
        }

        const rgb = {
          r: formatModel === 'r' ? val : this.model.r,
          g: formatModel === 'g' ? val : this.model.g,
          b: formatModel === 'b' ? val : this.model.b,
          a: this.hasAlpha === true
            ? (formatModel === 'a' ? val : this.model.a)
            : void 0
        };

        if (formatModel !== 'a') {
          const hsv = rgbToHsv(rgb);
          this.model.h = hsv.h;
          this.model.s = hsv.s;
          this.model.v = hsv.v;
        }

        this.__update(rgb, change);

        if (evt !== void 0 && change !== true && evt.target.selectionEnd !== void 0) {
          const index = evt.target.selectionEnd;
          this.$nextTick(() => {
            evt.target.setSelectionRange(index, index);
          });
        }
      },

      __onEditorChange (evt, change) {
        let rgb;
        const inp = evt.target.value;

        stop(evt);

        if (this.topView === 'hex') {
          if (
            inp.length !== (this.hasAlpha === true ? 9 : 7) ||
            !/^#[0-9A-Fa-f]+$/.test(inp)
          ) {
            return true
          }

          rgb = hexToRgb(inp);
        }
        else {
          let model;

          if (!inp.endsWith(')')) {
            return true
          }
          else if (this.hasAlpha !== true && inp.startsWith('rgb(')) {
            model = inp.substring(4, inp.length - 1).split(',').map(n => parseInt(n, 10));

            if (
              model.length !== 3 ||
              !/^rgb\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3}\)$/.test(inp)
            ) {
              return true
            }
          }
          else if (this.hasAlpha === true && inp.startsWith('rgba(')) {
            model = inp.substring(5, inp.length - 1).split(',');

            if (
              model.length !== 4 ||
              !/^rgba\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/.test(inp)
            ) {
              return true
            }

            for (let i = 0; i < 3; i++) {
              const v = parseInt(model[i], 10);
              if (v < 0 || v > 255) {
                return true
              }
              model[i] = v;
            }

            const v = parseFloat(model[3]);
            if (v < 0 || v > 1) {
              return true
            }
            model[3] = v;
          }
          else {
            return true
          }

          if (
            model[0] < 0 || model[0] > 255 ||
            model[1] < 0 || model[1] > 255 ||
            model[2] < 0 || model[2] > 255 ||
            (this.hasAlpha === true && (model[3] < 0 || model[3] > 1))
          ) {
            return true
          }

          rgb = {
            r: model[0],
            g: model[1],
            b: model[2],
            a: this.hasAlpha === true
              ? model[3] * 100
              : void 0
          };
        }

        const hsv = rgbToHsv(rgb);
        this.model.h = hsv.h;
        this.model.s = hsv.s;
        this.model.v = hsv.v;

        this.__update(rgb, change);

        if (change !== true) {
          const index = evt.target.selectionEnd;
          this.$nextTick(() => {
            evt.target.setSelectionRange(index, index);
          });
        }
      },

      __onPalettePick (color) {
        const def = this.__parseModel(color);
        const rgb = { r: def.r, g: def.g, b: def.b, a: def.a };

        if (rgb.a === void 0) {
          rgb.a = this.model.a;
        }

        this.model.h = def.h;
        this.model.s = def.s;
        this.model.v = def.v;

        this.__update(rgb, true);
      },

      __update (rgb, change) {
        // update internally
        this.model.hex = rgbToHex(rgb);
        this.model.rgb = rgbToString(rgb);
        this.model.r = rgb.r;
        this.model.g = rgb.g;
        this.model.b = rgb.b;
        this.model.a = rgb.a;

        const value = this.model[this.isOutputHex === true ? 'hex' : 'rgb'];

        // emit new value
        this.$emit('input', value);
        change === true && this.$emit('change', value);
      },

      __updateErrorIcon (val) {
        // we MUST avoid vue triggering a render,
        // so manually changing this
        if (this.$refs.errorIcon !== void 0) {
          this.$refs.errorIcon.$el.style.opacity = val ? 1 : 0;
        }
      },

      __parseModel (v) {
        const forceAlpha = this.forceAlpha !== void 0
          ? this.forceAlpha
          : (
            this.formatModel === 'auto'
              ? null
              : this.formatModel.indexOf('a') > -1
          );

        if (typeof v !== 'string' || v.length === 0 || testPattern.anyColor(v.replace(/ /g, '')) !== true) {
          return {
            h: 0,
            s: 0,
            v: 0,
            r: 0,
            g: 0,
            b: 0,
            a: forceAlpha === true ? 100 : void 0,
            hex: void 0,
            rgb: void 0
          }
        }

        const model = textToRgb(v);

        if (forceAlpha === true && model.a === void 0) {
          model.a = 100;
        }

        model.hex = rgbToHex(model);
        model.rgb = rgbToString(model);

        return Object.assign(model, rgbToHsv(model))
      },

      __spectrumPan (evt) {
        if (evt.isFinal) {
          this.__onSpectrumChange(
            evt.position.left,
            evt.position.top,
            true
          );
        }
        else {
          this.__spectrumChange(evt);
        }
      },

      // throttled in created()
      __spectrumChange (evt) {
        this.__onSpectrumChange(
          evt.position.left,
          evt.position.top
        );
      },

      __spectrumClick (evt) {
        this.__onSpectrumChange(
          evt.pageX - window.pageXOffset,
          evt.pageY - window.pageYOffset,
          true
        );
      },

      __activate (evt) {
        this.__onSpectrumChange(
          evt.pageX - window.pageXOffset,
          evt.pageY - window.pageYOffset
        );
      }
    }
  });

  // taken from https://github.com/jalaali/jalaali-js

  /*
    Jalaali years starting the 33-year rule.
  */
  const breaks = [ -61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210,
    1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178
  ];

  /*
    Converts a Gregorian date to Jalaali.
  */
  function toJalaali (gy, gm, gd) {
    if (Object.prototype.toString.call(gy) === '[object Date]') {
      gd = gy.getDate();
      gm = gy.getMonth() + 1;
      gy = gy.getFullYear();
    }
    return d2j(g2d(gy, gm, gd))
  }

  /*
    Converts a Jalaali date to Gregorian.
  */
  function toGregorian (jy, jm, jd) {
    return d2g(j2d(jy, jm, jd))
  }

  /*
    Is this a leap year or not?
  */
  function isLeapJalaaliYear (jy) {
    return jalCalLeap(jy) === 0
  }

  /*
    Number of days in a given month in a Jalaali year.
  */
  function jalaaliMonthLength (jy, jm) {
    if (jm <= 6) return 31
    if (jm <= 11) return 30
    if (isLeapJalaaliYear(jy)) return 30
    return 29
  }

  /*
      This function determines if the Jalaali (Persian) year is
      leap (366-day long) or is the common year (365 days)

      @param jy Jalaali calendar year (-61 to 3177)
      @returns number of years since the last leap year (0 to 4)
   */
  function jalCalLeap (jy) {
    const bl = breaks.length;
    let
      jp = breaks[0],
      jm,
      jump,
      leap,
      n,
      i;

    if (jy < jp || jy >= breaks[bl - 1]) { throw new Error('Invalid Jalaali year ' + jy) }

    for (i = 1; i < bl; i += 1) {
      jm = breaks[i];
      jump = jm - jp;
      if (jy < jm) { break }
      jp = jm;
    }
    n = jy - jp;

    if (jump - n < 6) { n = n - jump + div(jump + 4, 33) * 33; }
    leap = mod(mod(n + 1, 33) - 1, 4);
    if (leap === -1) {
      leap = 4;
    }

    return leap
  }

  /*
    This function determines if the Jalaali (Persian) year is
    leap (366-day long) or is the common year (365 days), and
    finds the day in March (Gregorian calendar) of the first
    day of the Jalaali year (jy).

    @param jy Jalaali calendar year (-61 to 3177)
    @param withoutLeap when don't need leap (true or false) default is false
    @return
      leap: number of years since the last leap year (0 to 4)
      gy: Gregorian year of the beginning of Jalaali year
      march: the March day of Farvardin the 1st (1st day of jy)
    @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
    @see: http://www.fourmilab.ch/documents/calendar/
  */
  function jalCal (jy, withoutLeap) {
    const
      bl = breaks.length,
      gy = jy + 621;
    let
      leapJ = -14,
      jp = breaks[0],
      jm,
      jump,
      leap,
      n,
      i;

    if (jy < jp || jy >= breaks[bl - 1]) { throw new Error('Invalid Jalaali year ' + jy) }

    // Find the limiting years for the Jalaali year jy.
    for (i = 1; i < bl; i += 1) {
      jm = breaks[i];
      jump = jm - jp;
      if (jy < jm) { break }
      leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
      jp = jm;
    }
    n = jy - jp;

    // Find the number of leap years from AD 621 to the beginning
    // of the current Jalaali year in the Persian calendar.
    leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
    if (mod(jump, 33) === 4 && jump - n === 4) { leapJ += 1; }

    // And the same in the Gregorian calendar (until the year gy).
    const leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;

    // Determine the Gregorian date of Farvardin the 1st.
    const march = 20 + leapJ - leapG;

    // Find how many years have passed since the last leap year.
    if (!withoutLeap) {
      if (jump - n < 6) { n = n - jump + div(jump + 4, 33) * 33; }
      leap = mod(mod(n + 1, 33) - 1, 4);
      if (leap === -1) {
        leap = 4;
      }
    }

    return {
      leap: leap,
      gy: gy,
      march: march
    }
  }

  /*
    Converts a date of the Jalaali calendar to the Julian Day number.

    @param jy Jalaali year (1 to 3100)
    @param jm Jalaali month (1 to 12)
    @param jd Jalaali day (1 to 29/31)
    @return Julian Day number
  */
  function j2d (jy, jm, jd) {
    const r = jalCal(jy, true);
    return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1
  }

  /*
    Converts the Julian Day number to a date in the Jalaali calendar.

    @param jdn Julian Day number
    @return
      jy: Jalaali year (1 to 3100)
      jm: Jalaali month (1 to 12)
      jd: Jalaali day (1 to 29/31)
  */
  function d2j (jdn) {
    const gy = d2g(jdn).gy; // Calculate Gregorian year (gy).
    let
      jy = gy - 621,
      jd,
      jm,
      k;
    const
      r = jalCal(jy, false),
      jdn1f = g2d(gy, 3, r.march);

    // Find number of days that passed since 1 Farvardin.
    k = jdn - jdn1f;
    if (k >= 0) {
      if (k <= 185) {
        // The first 6 months.
        jm = 1 + div(k, 31);
        jd = mod(k, 31) + 1;
        return { jy: jy,
          jm: jm,
          jd: jd
        }
      }
      else {
        // The remaining months.
        k -= 186;
      }
    }
    else {
      // Previous Jalaali year.
      jy -= 1;
      k += 179;
      if (r.leap === 1) { k += 1; }
    }
    jm = 7 + div(k, 30);
    jd = mod(k, 30) + 1;
    return { jy: jy,
      jm: jm,
      jd: jd
    }
  }

  /*
    Calculates the Julian Day number from Gregorian or Julian
    calendar dates. This integer number corresponds to the noon of
    the date (i.e. 12 hours of Universal Time).
    The procedure was tested to be good since 1 March, -100100 (of both
    calendars) up to a few million years into the future.

    @param gy Calendar year (years BC numbered 0, -1, -2, ...)
    @param gm Calendar month (1 to 12)
    @param gd Calendar day of the month (1 to 28/29/30/31)
    @return Julian Day number
  */
  function g2d (gy, gm, gd) {
    let d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) +
        div(153 * mod(gm + 9, 12) + 2, 5) +
        gd - 34840408;
    d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
    return d
  }

  /*
    Calculates Gregorian and Julian calendar dates from the Julian Day number
    (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
    calendars) to some millions years ahead of the present.

    @param jdn Julian Day number
    @return
      gy: Calendar year (years BC numbered 0, -1, -2, ...)
      gm: Calendar month (1 to 12)
      gd: Calendar day of the month M (1 to 28/29/30/31)
  */
  function d2g (jdn) {
    let j = 4 * jdn + 139361631;
    j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
    const
      i = div(mod(j, 1461), 4) * 5 + 308,
      gd = div(mod(i, 153), 5) + 1,
      gm = mod(div(i, 153), 12) + 1,
      gy = div(j, 1461) - 100100 + div(8 - gm, 6);
    return {
      gy: gy,
      gm: gm,
      gd: gd
    }
  }

  /*
    Utility helper functions.
  */

  function div (a, b) {
    return ~~(a / b)
  }

  function mod (a, b) {
    return a - ~~(a / b) * b
  }

  const calendars = [ 'gregorian', 'persian' ];

  var DateTimeMixin = {
    mixins: [ DarkMixin, FormMixin, ListenersMixin ],

    props: {
      value: {
        required: true
      },

      mask: {
        type: String
      },
      locale: Object,

      calendar: {
        type: String,
        validator: v => calendars.includes(v),
        default: 'gregorian'
      },

      landscape: Boolean,

      color: String,
      textColor: String,

      square: Boolean,
      flat: Boolean,
      bordered: Boolean,

      readonly: Boolean,
      disable: Boolean
    },

    computed: {
      computedMask () {
        return this.__getMask()
      },

      computedLocale () {
        return this.__getLocale()
      },

      editable () {
        return this.disable !== true && this.readonly !== true
      },

      computedColor () {
        return this.color || 'primary'
      },

      computedTextColor () {
        return this.textColor || 'white'
      },

      computedTabindex () {
        return this.editable === true ? 0 : -1
      },

      headerClass () {
        const cls = [];
        this.color !== void 0 && cls.push(`bg-${this.color}`);
        this.textColor !== void 0 && cls.push(`text-${this.textColor}`);
        return cls.join(' ')
      }
    },

    methods: {
      __getLocale () {
        return this.locale !== void 0
          ? { ...this.$q.lang.date, ...this.locale }
          : this.$q.lang.date
      },

      __getCurrentDate (dateOnly) {
        const d = new Date();
        const timeFill = dateOnly === true ? null : 0;

        if (this.calendar === 'persian') {
          const jDate = toJalaali(d);
          return {
            year: jDate.jy,
            month: jDate.jm,
            day: jDate.jd
          }
        }

        return {
          year: d.getFullYear(),
          month: d.getMonth() + 1,
          day: d.getDate(),
          hour: timeFill,
          minute: timeFill,
          second: timeFill,
          millisecond: timeFill
        }
      },

      __getCurrentTime () {
        const d = new Date();

        return {
          hour: d.getHours(),
          minute: d.getMinutes(),
          second: d.getSeconds(),
          millisecond: d.getMilliseconds()
        }
      },

      __getDayHash (date) {
        return date.year + '/' + pad(date.month) + '/' + pad(date.day)
      }
    }
  };

  /* eslint no-fallthrough: 0 */

  const
    MILLISECONDS_IN_DAY = 86400000,
    MILLISECONDS_IN_HOUR = 3600000,
    MILLISECONDS_IN_MINUTE = 60000,
    defaultMask = 'YYYY-MM-DDTHH:mm:ss.SSSZ',
    token = /\[((?:[^\]\\]|\\]|\\)*)\]|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]/g,
    reverseToken = /(\[[^\]]*\])|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]|([.*+:?^,\s${}()|\\]+)/g,
    regexStore = {};

  function getRegexData (mask, dateLocale) {
    const
      days = '(' + dateLocale.days.join('|') + ')',
      key = mask + days;

    if (regexStore[ key ] !== void 0) {
      return regexStore[ key ]
    }

    const
      daysShort = '(' + dateLocale.daysShort.join('|') + ')',
      months = '(' + dateLocale.months.join('|') + ')',
      monthsShort = '(' + dateLocale.monthsShort.join('|') + ')';

    const map = {};
    let index = 0;

    const regexText = mask.replace(reverseToken, match => {
      index++;
      switch (match) {
        case 'YY':
          map.YY = index;
          return '(-?\\d{1,2})'
        case 'YYYY':
          map.YYYY = index;
          return '(-?\\d{1,4})'
        case 'M':
          map.M = index;
          return '(\\d{1,2})'
        case 'MM':
          map.M = index; // bumping to M
          return '(\\d{2})'
        case 'MMM':
          map.MMM = index;
          return monthsShort
        case 'MMMM':
          map.MMMM = index;
          return months
        case 'D':
          map.D = index;
          return '(\\d{1,2})'
        case 'Do':
          map.D = index++; // bumping to D
          return '(\\d{1,2}(st|nd|rd|th))'
        case 'DD':
          map.D = index; // bumping to D
          return '(\\d{2})'
        case 'H':
          map.H = index;
          return '(\\d{1,2})'
        case 'HH':
          map.H = index; // bumping to H
          return '(\\d{2})'
        case 'h':
          map.h = index;
          return '(\\d{1,2})'
        case 'hh':
          map.h = index; // bumping to h
          return '(\\d{2})'
        case 'm':
          map.m = index;
          return '(\\d{1,2})'
        case 'mm':
          map.m = index; // bumping to m
          return '(\\d{2})'
        case 's':
          map.s = index;
          return '(\\d{1,2})'
        case 'ss':
          map.s = index; // bumping to s
          return '(\\d{2})'
        case 'S':
          map.S = index;
          return '(\\d{1})'
        case 'SS':
          map.S = index; // bump to S
          return '(\\d{2})'
        case 'SSS':
          map.S = index; // bump to S
          return '(\\d{3})'
        case 'A':
          map.A = index;
          return '(AM|PM)'
        case 'a':
          map.a = index;
          return '(am|pm)'
        case 'aa':
          map.aa = index;
          return '(a\\.m\\.|p\\.m\\.)'

        case 'ddd':
          return daysShort
        case 'dddd':
          return days
        case 'Q':
        case 'd':
        case 'E':
          return '(\\d{1})'
        case 'Qo':
          return '(1st|2nd|3rd|4th)'
        case 'DDD':
        case 'DDDD':
          return '(\\d{1,3})'
        case 'w':
          return '(\\d{1,2})'
        case 'ww':
          return '(\\d{2})'

        case 'Z': // to split: (?:(Z)()()|([+-])?(\\d{2}):?(\\d{2}))
          map.Z = index;
          return '(Z|[+-]\\d{2}:\\d{2})'
        case 'ZZ':
          map.ZZ = index;
          return '(Z|[+-]\\d{2}\\d{2})'

        case 'X':
          map.X = index;
          return '(-?\\d+)'
        case 'x':
          map.x = index;
          return '(-?\\d{4,})'

        default:
          index--;
          if (match[ 0 ] === '[') {
            match = match.substring(1, match.length - 1);
          }
          return match.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      }
    });

    const res = { map, regex: new RegExp('^' + regexText) };
    regexStore[ key ] = res;

    return res
  }

  function getDateLocale (paramDateLocale, langProps) {
    return paramDateLocale !== void 0
      ? paramDateLocale
      : (
        langProps !== void 0
          ? langProps.date
          : defaultLang.date
      )
  }

  function formatTimezone (offset, delimeter = '') {
    const
      sign = offset > 0 ? '-' : '+',
      absOffset = Math.abs(offset),
      hours = Math.floor(absOffset / 60),
      minutes = absOffset % 60;

    return sign + pad(hours) + delimeter + pad(minutes)
  }

  function applyYearMonthDayChange (date, mod, sign) {
    let
      year = date.getFullYear(),
      month = date.getMonth();

    const day = date.getDate();

    if (mod.year !== void 0) {
      year += sign * mod.year;
      delete mod.year;
    }

    if (mod.month !== void 0) {
      month += sign * mod.month;
      delete mod.month;
    }

    date.setDate(1);
    date.setMonth(2);

    date.setFullYear(year);
    date.setMonth(month);
    date.setDate(Math.min(day, daysInMonth(date)));

    if (mod.date !== void 0) {
      date.setDate(date.getDate() + sign * mod.date);
      delete mod.date;
    }

    return date
  }

  function applyYearMonthDay (date, mod, middle) {
    const
      year = mod.year !== void 0 ? mod.year : date[ `get${middle}FullYear` ](),
      month = mod.month !== void 0 ? mod.month - 1 : date[ `get${middle}Month` ](),
      maxDay = (new Date(year, month + 1, 0)).getDate(),
      day = Math.min(maxDay, mod.date !== void 0 ? mod.date : date[ `get${middle}Date` ]());

    date[ `set${middle}Date` ](1);
    date[ `set${middle}Month` ](2);

    date[ `set${middle}FullYear` ](year);
    date[ `set${middle}Month` ](month);
    date[ `set${middle}Date` ](day);

    delete mod.year;
    delete mod.month;
    delete mod.date;

    return date
  }

  function getChange (date, rawMod, sign) {
    const
      mod = normalizeMod(rawMod),
      d = new Date(date),
      t = mod.year !== void 0 || mod.month !== void 0 || mod.date !== void 0
        ? applyYearMonthDayChange(d, mod, sign) // removes year/month/day
        : d;

    for (const key in mod) {
      const op = capitalize(key);
      t[ `set${op}` ](t[ `get${op}` ]() + sign * mod[ key ]);
    }

    return t
  }

  function normalizeMod (mod) {
    const acc = { ...mod };

    if (mod.years !== void 0) {
      acc.year = mod.years;
      delete acc.years;
    }

    if (mod.months !== void 0) {
      acc.month = mod.months;
      delete acc.months;
    }

    if (mod.days !== void 0) {
      acc.date = mod.days;
      delete acc.days;
    }
    if (mod.day !== void 0) {
      acc.date = mod.day;
      delete acc.day;
    }

    if (mod.hour !== void 0) {
      acc.hours = mod.hour;
      delete acc.hour;
    }

    if (mod.minute !== void 0) {
      acc.minutes = mod.minute;
      delete acc.minute;
    }

    if (mod.second !== void 0) {
      acc.seconds = mod.second;
      delete acc.second;
    }

    if (mod.millisecond !== void 0) {
      acc.milliseconds = mod.millisecond;
      delete acc.millisecond;
    }

    return acc
  }

  function adjustDate (date, rawMod, utc) {
    const
      mod = normalizeMod(rawMod),
      middle = utc === true ? 'UTC' : '',
      d = new Date(date),
      t = mod.year !== void 0 || mod.month !== void 0 || mod.date !== void 0
        ? applyYearMonthDay(d, mod, middle) // removes year/month/day
        : d;

    for (const key in mod) {
      const op = key.charAt(0).toUpperCase() + key.slice(1);
      t[ `set${middle}${op}` ](mod[ key ]);
    }

    return t
  }

  function extractDate (str, mask, dateLocale) {
    const d = __splitDate(str, mask, dateLocale);

    const date = new Date(
      d.year,
      d.month === null ? null : d.month - 1,
      d.day === null ? 1 : d.day,
      d.hour,
      d.minute,
      d.second,
      d.millisecond
    );

    const tzOffset = date.getTimezoneOffset();

    return d.timezoneOffset === null || d.timezoneOffset === tzOffset
      ? date
      : getChange(date, { minutes: d.timezoneOffset - tzOffset }, 1)
  }

  function __splitDate (str, mask, dateLocale, calendar, defaultModel) {
    const date = {
      year: null,
      month: null,
      day: null,
      hour: null,
      minute: null,
      second: null,
      millisecond: null,
      timezoneOffset: null,
      dateHash: null,
      timeHash: null
    };

    defaultModel !== void 0 && Object.assign(date, defaultModel);

    if (
      str === void 0 ||
      str === null ||
      str === '' ||
      typeof str !== 'string'
    ) {
      return date
    }

    if (mask === void 0) {
      mask = defaultMask;
    }

    const
      langOpts = getDateLocale(dateLocale, Plugin.props),
      months = langOpts.months,
      monthsShort = langOpts.monthsShort;

    const { regex, map } = getRegexData(mask, langOpts);

    const match = str.match(regex);

    if (match === null) {
      return date
    }

    let tzString = '';

    if (map.X !== void 0 || map.x !== void 0) {
      const stamp = parseInt(match[ map.X !== void 0 ? map.X : map.x ], 10);

      if (isNaN(stamp) === true || stamp < 0) {
        return date
      }

      const d = new Date(stamp * (map.X !== void 0 ? 1000 : 1));

      date.year = d.getFullYear();
      date.month = d.getMonth() + 1;
      date.day = d.getDate();
      date.hour = d.getHours();
      date.minute = d.getMinutes();
      date.second = d.getSeconds();
      date.millisecond = d.getMilliseconds();
    }
    else {
      if (map.YYYY !== void 0) {
        date.year = parseInt(match[ map.YYYY ], 10);
      }
      else if (map.YY !== void 0) {
        const y = parseInt(match[ map.YY ], 10);
        date.year = y < 0 ? y : 2000 + y;
      }

      if (map.M !== void 0) {
        date.month = parseInt(match[ map.M ], 10);
        if (date.month < 1 || date.month > 12) {
          return date
        }
      }
      else if (map.MMM !== void 0) {
        date.month = monthsShort.indexOf(match[ map.MMM ]) + 1;
      }
      else if (map.MMMM !== void 0) {
        date.month = months.indexOf(match[ map.MMMM ]) + 1;
      }

      if (map.D !== void 0) {
        date.day = parseInt(match[ map.D ], 10);

        if (date.year === null || date.month === null || date.day < 1) {
          return date
        }

        const maxDay = calendar !== 'persian'
          ? (new Date(date.year, date.month, 0)).getDate()
          : jalaaliMonthLength(date.year, date.month);

        if (date.day > maxDay) {
          return date
        }
      }

      if (map.H !== void 0) {
        date.hour = parseInt(match[ map.H ], 10) % 24;
      }
      else if (map.h !== void 0) {
        date.hour = parseInt(match[ map.h ], 10) % 12;
        if (
          (map.A && match[ map.A ] === 'PM') ||
          (map.a && match[ map.a ] === 'pm') ||
          (map.aa && match[ map.aa ] === 'p.m.')
        ) {
          date.hour += 12;
        }
        date.hour = date.hour % 24;
      }

      if (map.m !== void 0) {
        date.minute = parseInt(match[ map.m ], 10) % 60;
      }

      if (map.s !== void 0) {
        date.second = parseInt(match[ map.s ], 10) % 60;
      }

      if (map.S !== void 0) {
        date.millisecond = parseInt(match[ map.S ], 10) * 10 ** (3 - match[ map.S ].length);
      }

      if (map.Z !== void 0 || map.ZZ !== void 0) {
        tzString = (map.Z !== void 0 ? match[ map.Z ].replace(':', '') : match[ map.ZZ ]);
        date.timezoneOffset = (tzString[ 0 ] === '+' ? -1 : 1) * (60 * tzString.slice(1, 3) + 1 * tzString.slice(3, 5));
      }
    }

    date.dateHash = pad(date.year, 6) + '/' + pad(date.month) + '/' + pad(date.day);
    date.timeHash = pad(date.hour) + ':' + pad(date.minute) + ':' + pad(date.second) + tzString;

    return date
  }

  function isValid (date) {
    return typeof date === 'number'
      ? true
      : isNaN(Date.parse(date)) === false
  }

  function buildDate (mod, utc) {
    return adjustDate(new Date(), mod, utc)
  }

  function getDayOfWeek (date) {
    const dow = new Date(date).getDay();
    return dow === 0 ? 7 : dow
  }

  function getWeekOfYear (date) {
    // Remove time components of date
    const thursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    // Change date to Thursday same week
    thursday.setDate(thursday.getDate() - ((thursday.getDay() + 6) % 7) + 3);

    // Take January 4th as it is always in week 1 (see ISO 8601)
    const firstThursday = new Date(thursday.getFullYear(), 0, 4);

    // Change date to Thursday same week
    firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

    // Check if daylight-saving-time-switch occurred and correct for it
    const ds = thursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
    thursday.setHours(thursday.getHours() - ds);

    // Number of weeks between target Thursday and first Thursday
    const weekDiff = (thursday - firstThursday) / (MILLISECONDS_IN_DAY * 7);
    return 1 + Math.floor(weekDiff)
  }

  function getDayIdentifier (date) {
    return date.getFullYear() * 10000 + date.getMonth() * 100 + date.getDate()
  }

  function getDateIdentifier (date, onlyDate /* = false */) {
    const d = new Date(date);
    return onlyDate === true ? getDayIdentifier(d) : d.getTime()
  }

  function isBetweenDates (date, from, to, opts = {}) {
    const
      d1 = getDateIdentifier(from, opts.onlyDate),
      d2 = getDateIdentifier(to, opts.onlyDate),
      cur = getDateIdentifier(date, opts.onlyDate);

    return (cur > d1 || (opts.inclusiveFrom === true && cur === d1)) &&
      (cur < d2 || (opts.inclusiveTo === true && cur === d2))
  }

  function addToDate (date, mod) {
    return getChange(date, mod, 1)
  }
  function subtractFromDate (date, mod) {
    return getChange(date, mod, -1)
  }

  function startOfDate (date, unit, utc) {
    const
      t = new Date(date),
      prefix = `set${utc === true ? 'UTC' : ''}`;

    switch (unit) {
      case 'year':
      case 'years':
        t[ `${prefix}Month` ](0);
      case 'month':
      case 'months':
        t[ `${prefix}Date` ](1);
      case 'day':
      case 'days':
      case 'date':
        t[ `${prefix}Hours` ](0);
      case 'hour':
      case 'hours':
        t[ `${prefix}Minutes` ](0);
      case 'minute':
      case 'minutes':
        t[ `${prefix}Seconds` ](0);
      case 'second':
      case 'seconds':
        t[ `${prefix}Milliseconds` ](0);
    }
    return t
  }

  function endOfDate (date, unit, utc) {
    const
      t = new Date(date),
      prefix = `set${utc === true ? 'UTC' : ''}`;

    switch (unit) {
      case 'year':
      case 'years':
        t[ `${prefix}Month` ](11);
      case 'month':
      case 'months':
        t[ `${prefix}Date` ](daysInMonth(t));
      case 'day':
      case 'days':
      case 'date':
        t[ `${prefix}Hours` ](23);
      case 'hour':
      case 'hours':
        t[ `${prefix}Minutes` ](59);
      case 'minute':
      case 'minutes':
        t[ `${prefix}Seconds` ](59);
      case 'second':
      case 'seconds':
        t[ `${prefix}Milliseconds` ](999);
    }
    return t
  }

  function getMaxDate (date /* , ...args */) {
    let t = new Date(date);
    Array.prototype.slice.call(arguments, 1).forEach(d => {
      t = Math.max(t, new Date(d));
    });
    return t
  }

  function getMinDate (date /*, ...args */) {
    let t = new Date(date);
    Array.prototype.slice.call(arguments, 1).forEach(d => {
      t = Math.min(t, new Date(d));
    });
    return t
  }

  function getDiff (t, sub, interval) {
    return (
      (t.getTime() - t.getTimezoneOffset() * MILLISECONDS_IN_MINUTE) -
      (sub.getTime() - sub.getTimezoneOffset() * MILLISECONDS_IN_MINUTE)
    ) / interval
  }

  function getDateDiff (date, subtract, unit = 'days') {
    const
      t = new Date(date),
      sub = new Date(subtract);

    switch (unit) {
      case 'years':
      case 'year':
        return (t.getFullYear() - sub.getFullYear())

      case 'months':
      case 'month':
        return (t.getFullYear() - sub.getFullYear()) * 12 + t.getMonth() - sub.getMonth()

      case 'days':
      case 'day':
      case 'date':
        return getDiff(startOfDate(t, 'day'), startOfDate(sub, 'day'), MILLISECONDS_IN_DAY)

      case 'hours':
      case 'hour':
        return getDiff(startOfDate(t, 'hour'), startOfDate(sub, 'hour'), MILLISECONDS_IN_HOUR)

      case 'minutes':
      case 'minute':
        return getDiff(startOfDate(t, 'minute'), startOfDate(sub, 'minute'), MILLISECONDS_IN_MINUTE)

      case 'seconds':
      case 'second':
        return getDiff(startOfDate(t, 'second'), startOfDate(sub, 'second'), 1000)
    }
  }

  function getDayOfYear (date) {
    return getDateDiff(date, startOfDate(date, 'year'), 'days') + 1
  }

  function inferDateFormat (date) {
    return isDate(date) === true
      ? 'date'
      : (typeof date === 'number' ? 'number' : 'string')
  }

  function getDateBetween (date, min, max) {
    const t = new Date(date);

    if (min) {
      const low = new Date(min);
      if (t < low) {
        return low
      }
    }

    if (max) {
      const high = new Date(max);
      if (t > high) {
        return high
      }
    }

    return t
  }

  function isSameDate (date, date2, unit) {
    const
      t = new Date(date),
      d = new Date(date2);

    if (unit === void 0) {
      return t.getTime() === d.getTime()
    }

    switch (unit) {
      case 'second':
      case 'seconds':
        if (t.getSeconds() !== d.getSeconds()) {
          return false
        }
      case 'minute': // intentional fall-through
      case 'minutes':
        if (t.getMinutes() !== d.getMinutes()) {
          return false
        }
      case 'hour': // intentional fall-through
      case 'hours':
        if (t.getHours() !== d.getHours()) {
          return false
        }
      case 'day': // intentional fall-through
      case 'days':
      case 'date':
        if (t.getDate() !== d.getDate()) {
          return false
        }
      case 'month': // intentional fall-through
      case 'months':
        if (t.getMonth() !== d.getMonth()) {
          return false
        }
      case 'year': // intentional fall-through
      case 'years':
        if (t.getFullYear() !== d.getFullYear()) {
          return false
        }
        break
      default:
        throw new Error(`date isSameDate unknown unit ${unit}`)
    }

    return true
  }

  function daysInMonth (date) {
    return (new Date(date.getFullYear(), date.getMonth() + 1, 0)).getDate()
  }

  function getOrdinal (n) {
    if (n >= 11 && n <= 13) {
      return `${n}th`
    }
    switch (n % 10) {
      case 1: return `${n}st`
      case 2: return `${n}nd`
      case 3: return `${n}rd`
    }
    return `${n}th`
  }

  const formatter = {
    // Year: 00, 01, ..., 99
    YY (date, _, forcedYear) {
      // workaround for < 1900 with new Date()
      const y = this.YYYY(date, _, forcedYear) % 100;
      return y >= 0
        ? pad(y)
        : '-' + pad(Math.abs(y))
    },

    // Year: 1900, 1901, ..., 2099
    YYYY (date, _, forcedYear) {
      // workaround for < 1900 with new Date()
      return forcedYear !== void 0 && forcedYear !== null
        ? forcedYear
        : date.getFullYear()
    },

    // Month: 1, 2, ..., 12
    M (date) {
      return date.getMonth() + 1
    },

    // Month: 01, 02, ..., 12
    MM (date) {
      return pad(date.getMonth() + 1)
    },

    // Month Short Name: Jan, Feb, ...
    MMM (date, dateLocale) {
      return dateLocale.monthsShort[ date.getMonth() ]
    },

    // Month Name: January, February, ...
    MMMM (date, dateLocale) {
      return dateLocale.months[ date.getMonth() ]
    },

    // Quarter: 1, 2, 3, 4
    Q (date) {
      return Math.ceil((date.getMonth() + 1) / 3)
    },

    // Quarter: 1st, 2nd, 3rd, 4th
    Qo (date) {
      return getOrdinal(this.Q(date))
    },

    // Day of month: 1, 2, ..., 31
    D (date) {
      return date.getDate()
    },

    // Day of month: 1st, 2nd, ..., 31st
    Do (date) {
      return getOrdinal(date.getDate())
    },

    // Day of month: 01, 02, ..., 31
    DD (date) {
      return pad(date.getDate())
    },

    // Day of year: 1, 2, ..., 366
    DDD (date) {
      return getDayOfYear(date)
    },

    // Day of year: 001, 002, ..., 366
    DDDD (date) {
      return pad(getDayOfYear(date), 3)
    },

    // Day of week: 0, 1, ..., 6
    d (date) {
      return date.getDay()
    },

    // Day of week: Su, Mo, ...
    dd (date, dateLocale) {
      return this.dddd(date, dateLocale).slice(0, 2)
    },

    // Day of week: Sun, Mon, ...
    ddd (date, dateLocale) {
      return dateLocale.daysShort[ date.getDay() ]
    },

    // Day of week: Sunday, Monday, ...
    dddd (date, dateLocale) {
      return dateLocale.days[ date.getDay() ]
    },

    // Day of ISO week: 1, 2, ..., 7
    E (date) {
      return date.getDay() || 7
    },

    // Week of Year: 1 2 ... 52 53
    w (date) {
      return getWeekOfYear(date)
    },

    // Week of Year: 01 02 ... 52 53
    ww (date) {
      return pad(getWeekOfYear(date))
    },

    // Hour: 0, 1, ... 23
    H (date) {
      return date.getHours()
    },

    // Hour: 00, 01, ..., 23
    HH (date) {
      return pad(date.getHours())
    },

    // Hour: 1, 2, ..., 12
    h (date) {
      const hours = date.getHours();
      if (hours === 0) {
        return 12
      }
      if (hours > 12) {
        return hours % 12
      }
      return hours
    },

    // Hour: 01, 02, ..., 12
    hh (date) {
      return pad(this.h(date))
    },

    // Minute: 0, 1, ..., 59
    m (date) {
      return date.getMinutes()
    },

    // Minute: 00, 01, ..., 59
    mm (date) {
      return pad(date.getMinutes())
    },

    // Second: 0, 1, ..., 59
    s (date) {
      return date.getSeconds()
    },

    // Second: 00, 01, ..., 59
    ss (date) {
      return pad(date.getSeconds())
    },

    // 1/10 of second: 0, 1, ..., 9
    S (date) {
      return Math.floor(date.getMilliseconds() / 100)
    },

    // 1/100 of second: 00, 01, ..., 99
    SS (date) {
      return pad(Math.floor(date.getMilliseconds() / 10))
    },

    // Millisecond: 000, 001, ..., 999
    SSS (date) {
      return pad(date.getMilliseconds(), 3)
    },

    // Meridiem: AM, PM
    A (date) {
      return this.H(date) < 12 ? 'AM' : 'PM'
    },

    // Meridiem: am, pm
    a (date) {
      return this.H(date) < 12 ? 'am' : 'pm'
    },

    // Meridiem: a.m., p.m.
    aa (date) {
      return this.H(date) < 12 ? 'a.m.' : 'p.m.'
    },

    // Timezone: -01:00, +00:00, ... +12:00
    Z (date, dateLocale, forcedYear, forcedTimezoneOffset) {
      const tzOffset = forcedTimezoneOffset === void 0 || forcedTimezoneOffset === null
        ? date.getTimezoneOffset()
        : forcedTimezoneOffset;

      return formatTimezone(tzOffset, ':')
    },

    // Timezone: -0100, +0000, ... +1200
    ZZ (date, dateLocale, forcedYear, forcedTimezoneOffset) {
      const tzOffset = forcedTimezoneOffset === void 0 || forcedTimezoneOffset === null
        ? date.getTimezoneOffset()
        : forcedTimezoneOffset;

      return formatTimezone(tzOffset)
    },

    // Seconds timestamp: 512969520
    X (date) {
      return Math.floor(date.getTime() / 1000)
    },

    // Milliseconds timestamp: 512969520900
    x (date) {
      return date.getTime()
    }
  };

  function formatDate (val, mask, dateLocale, __forcedYear, __forcedTimezoneOffset) {
    if (
      (val !== 0 && !val) ||
      val === Infinity ||
      val === -Infinity
    ) {
      return
    }

    const date = new Date(val);

    if (isNaN(date)) {
      return
    }

    if (mask === void 0) {
      mask = defaultMask;
    }

    const locale = getDateLocale(dateLocale, Plugin.props);

    return mask.replace(
      token,
      (match, text) => (
        match in formatter
          ? formatter[ match ](date, locale, __forcedYear, __forcedTimezoneOffset)
          : (text === void 0 ? match : text.split('\\]').join(']'))
      )
    )
  }

  function clone (date) {
    return isDate(date) === true
      ? new Date(date.getTime())
      : date
  }

  var date = {
    isValid,
    extractDate,
    buildDate,
    getDayOfWeek,
    getWeekOfYear,
    isBetweenDates,
    addToDate,
    subtractFromDate,
    adjustDate,
    startOfDate,
    endOfDate,
    getMaxDate,
    getMinDate,
    getDateDiff,
    getDayOfYear,
    inferDateFormat,
    getDateBetween,
    isSameDate,
    daysInMonth,
    formatDate,
    clone
  };

  const yearsInterval = 20;
  const views = [ 'Calendar', 'Years', 'Months' ];
  const viewIsValid = v => views.includes(v);
  const yearMonthValidator = v => /^-?[\d]+\/[0-1]\d$/.test(v);
  const lineStr = ' \u2014 ';

  var QDate = Vue.extend({
    name: 'QDate',

    mixins: [ DateTimeMixin ],

    props: {
      multiple: Boolean,
      range: Boolean,

      title: String,
      subtitle: String,

      mask: {
        // this mask is forced
        // when using persian calendar
        default: 'YYYY/MM/DD'
      },

      defaultYearMonth: {
        type: String,
        validator: yearMonthValidator
      },

      yearsInMonthView: Boolean,

      events: [ Array, Function ],
      eventColor: [ String, Function ],

      emitImmediately: Boolean,

      options: [ Array, Function ],

      navigationMinYearMonth: {
        type: String,
        validator: yearMonthValidator
      },

      navigationMaxYearMonth: {
        type: String,
        validator: yearMonthValidator
      },

      noUnset: Boolean,

      firstDayOfWeek: [ String, Number ],
      todayBtn: Boolean,
      minimal: Boolean,
      defaultView: {
        type: String,
        default: 'Calendar',
        validator: viewIsValid
      }
    },

    data () {
      const
        innerMask = this.__getMask(),
        innerLocale = this.__getLocale(),
        viewModel = this.__getViewModel(innerMask, innerLocale),
        year = viewModel.year,
        direction = this.$q.lang.rtl === true ? 'right' : 'left';

      return {
        view: this.defaultView,
        monthDirection: direction,
        yearDirection: direction,
        startYear: year - (year % yearsInterval) - (year < 0 ? yearsInterval : 0),
        editRange: void 0,
        innerMask,
        innerLocale,
        viewModel // model of current calendar view
      }
    },

    watch: {
      value (v) {
        if (this.lastEmitValue === v) {
          this.lastEmitValue = 0;
        }
        else {
          const { year, month } = this.__getViewModel(this.innerMask, this.innerLocale);
          this.__updateViewModel(year, month);
        }
      },

      view () {
        this.$refs.blurTarget !== void 0 && this.$refs.blurTarget.focus();
      },

      'viewModel.year' (year) {
        this.$emit('navigation', { year, month: this.viewModel.month });
      },

      'viewModel.month' (month) {
        this.$emit('navigation', { year: this.viewModel.year, month });
      },

      computedMask (val) {
        this.__updateValue(val, this.innerLocale, 'mask');
        this.innerMask = val;
      },

      computedLocale (val) {
        this.__updateValue(this.innerMask, val, 'locale');
        this.innerLocale = val;
      }
    },

    computed: {
      classes () {
        const type = this.landscape === true ? 'landscape' : 'portrait';
        return `q-date q-date--${type} q-date--${type}-${this.minimal === true ? 'minimal' : 'standard'}` +
          (this.isDark === true ? ' q-date--dark q-dark' : '') +
          (this.bordered === true ? ' q-date--bordered' : '') +
          (this.square === true ? ' q-date--square no-border-radius' : '') +
          (this.flat === true ? ' q-date--flat no-shadow' : '') +
          (this.disable === true ? ' disabled' : (this.readonly === true ? ' q-date--readonly' : ''))
      },

      isImmediate () {
        return this.emitImmediately === true &&
          this.multiple !== true &&
          this.range !== true
      },

      normalizedModel () {
        return Array.isArray(this.value) === true
          ? this.value
          : (this.value !== null && this.value !== void 0 ? [ this.value ] : [])
      },

      daysModel () {
        return this.normalizedModel
          .filter(date => typeof date === 'string')
          .map(date => this.__decodeString(date, this.innerMask, this.innerLocale))
          .filter(date =>
            date.dateHash !== null &&
            date.day !== null &&
            date.month !== null &&
            date.year !== null
          )
      },

      rangeModel () {
        const fn = date => this.__decodeString(date, this.innerMask, this.innerLocale);
        return this.normalizedModel
          .filter(date => isObject(date) === true && date.from !== void 0 && date.to !== void 0)
          .map(range => ({ from: fn(range.from), to: fn(range.to) }))
          .filter(range => range.from.dateHash !== null && range.to.dateHash !== null && range.from.dateHash < range.to.dateHash)
      },

      getNativeDateFn () {
        return this.calendar !== 'persian'
          ? model => new Date(model.year, model.month - 1, model.day)
          : model => {
            const gDate = toGregorian(model.year, model.month, model.day);
            return new Date(gDate.gy, gDate.gm - 1, gDate.gd)
          }
      },

      encodeObjectFn () {
        return this.calendar === 'persian'
          ? this.__getDayHash
          : (date, mask, locale) => formatDate(
            new Date(
              date.year,
              date.month - 1,
              date.day,
              date.hour,
              date.minute,
              date.second,
              date.millisecond
            ),
            mask === void 0 ? this.innerMask : mask,
            locale === void 0 ? this.innerLocale : locale,
            date.year,
            date.timezoneOffset
          )
      },

      daysInModel () {
        return this.daysModel.length + this.rangeModel.reduce(
          (acc, range) => acc + 1 + getDateDiff(
            this.getNativeDateFn(range.to),
            this.getNativeDateFn(range.from)
          ),
          0
        )
      },

      headerTitle () {
        if (this.title !== void 0 && this.title !== null && this.title.length > 0) {
          return this.title
        }

        if (this.editRange !== void 0) {
          const model = this.editRange.init;
          const date = this.getNativeDateFn(model);

          return this.innerLocale.daysShort[ date.getDay() ] + ', ' +
            this.innerLocale.monthsShort[ model.month - 1 ] + ' ' +
            model.day + lineStr + '?'
        }

        if (this.daysInModel === 0) {
          return lineStr
        }

        if (this.daysInModel > 1) {
          return `${this.daysInModel} ${this.innerLocale.pluralDay}`
        }

        const model = this.daysModel[0];
        const date = this.getNativeDateFn(model);

        if (isNaN(date.valueOf()) === true) {
          return lineStr
        }

        if (this.innerLocale.headerTitle !== void 0) {
          return this.innerLocale.headerTitle(date, model)
        }

        return this.innerLocale.daysShort[ date.getDay() ] + ', ' +
          this.innerLocale.monthsShort[ model.month - 1 ] + ' ' +
          model.day
      },

      headerSubtitle () {
        if (this.subtitle !== void 0 && this.subtitle !== null && this.subtitle.length > 0) {
          return this.subtitle
        }

        if (this.daysInModel === 0) {
          return lineStr
        }

        if (this.daysInModel > 1) {
          const from = this.minSelectedModel;
          const to = this.maxSelectedModel;
          const month = this.innerLocale.monthsShort;

          return month[from.month - 1] + (
            from.year !== to.year
              ? ' ' + from.year + lineStr + month[to.month - 1] + ' '
              : (
                from.month !== to.month
                  ? lineStr + month[to.month - 1]
                  : ''
              )
          ) + ' ' + to.year
        }

        return this.daysModel[0].year
      },

      minSelectedModel () {
        const model = this.daysModel.concat(this.rangeModel.map(range => range.from))
          .sort((a, b) => a.year - b.year || a.month - b.month);

        return model[0]
      },

      maxSelectedModel () {
        const model = this.daysModel.concat(this.rangeModel.map(range => range.to))
          .sort((a, b) => b.year - a.year || b.month - a.month);

        return model[0]
      },

      dateArrow () {
        const val = [ this.$q.iconSet.datetime.arrowLeft, this.$q.iconSet.datetime.arrowRight ];
        return this.$q.lang.rtl === true ? val.reverse() : val
      },

      computedFirstDayOfWeek () {
        return this.firstDayOfWeek !== void 0
          ? Number(this.firstDayOfWeek)
          : this.innerLocale.firstDayOfWeek
      },

      daysOfWeek () {
        const
          days = this.innerLocale.daysShort,
          first = this.computedFirstDayOfWeek;

        return first > 0
          ? days.slice(first, 7).concat(days.slice(0, first))
          : days
      },

      daysInMonth () {
        const date = this.viewModel;
        return this.calendar !== 'persian'
          ? (new Date(date.year, date.month, 0)).getDate()
          : jalaaliMonthLength(date.year, date.month)
      },

      today () {
        return this.__getCurrentDate()
      },

      evtColor () {
        return typeof this.eventColor === 'function'
          ? this.eventColor
          : () => this.eventColor
      },

      minNav () {
        if (this.navigationMinYearMonth !== void 0) {
          const data = this.navigationMinYearMonth.split('/');
          return { year: parseInt(data[0], 10), month: parseInt(data[1], 10) }
        }
      },

      maxNav () {
        if (this.navigationMaxYearMonth !== void 0) {
          const data = this.navigationMaxYearMonth.split('/');
          return { year: parseInt(data[0], 10), month: parseInt(data[1], 10) }
        }
      },

      navBoundaries () {
        const data = {
          month: { prev: true, next: true },
          year: { prev: true, next: true }
        };

        if (this.minNav !== void 0 && this.minNav.year >= this.viewModel.year) {
          data.year.prev = false;
          if (this.minNav.year === this.viewModel.year && this.minNav.month >= this.viewModel.month) {
            data.month.prev = false;
          }
        }

        if (this.maxNav !== void 0 && this.maxNav.year <= this.viewModel.year) {
          data.year.next = false;
          if (this.maxNav.year === this.viewModel.year && this.maxNav.month <= this.viewModel.month) {
            data.month.next = false;
          }
        }

        return data
      },

      daysMap () {
        const map = {};

        this.daysModel.forEach(entry => {
          const hash = this.__getMonthHash(entry);

          if (map[hash] === void 0) {
            map[hash] = [];
          }

          map[hash].push(entry.day);
        });

        return map
      },

      rangeMap () {
        const map = {};

        this.rangeModel.forEach(entry => {
          const hashFrom = this.__getMonthHash(entry.from);
          const hashTo = this.__getMonthHash(entry.to);

          if (map[hashFrom] === void 0) {
            map[hashFrom] = [];
          }

          map[hashFrom].push({
            from: entry.from.day,
            to: hashFrom === hashTo ? entry.to.day : void 0,
            range: entry
          });

          if (hashFrom < hashTo) {
            let hash;
            const { year, month } = entry.from;
            const cur = month < 12
              ? { year, month: month + 1 }
              : { year: year + 1, month: 1 };

            while ((hash = this.__getMonthHash(cur)) <= hashTo) {
              if (map[hash] === void 0) {
                map[hash] = [];
              }

              map[hash].push({
                from: void 0,
                to: hash === hashTo ? entry.to.day : void 0,
                range: entry
              });

              cur.month++;
              if (cur.month > 12) {
                cur.year++;
                cur.month = 1;
              }
            }
          }
        });

        return map
      },

      rangeView () {
        if (this.editRange === void 0) {
          return
        }

        const { init, initHash, final, finalHash } = this.editRange;

        const [ from, to ] = initHash <= finalHash
          ? [ init, final ]
          : [ final, init ];

        const fromHash = this.__getMonthHash(from);
        const toHash = this.__getMonthHash(to);

        if (fromHash !== this.viewMonthHash && toHash !== this.viewMonthHash) {
          return
        }

        const view = {};

        if (fromHash === this.viewMonthHash) {
          view.from = from.day;
          view.includeFrom = true;
        }
        else {
          view.from = 1;
        }

        if (toHash === this.viewMonthHash) {
          view.to = to.day;
          view.includeTo = true;
        }
        else {
          view.to = this.daysInMonth;
        }

        return view
      },

      viewMonthHash () {
        return this.__getMonthHash(this.viewModel)
      },

      selectionDaysMap () {
        const map = {};

        if (this.options === void 0) {
          for (let i = 1; i <= this.daysInMonth; i++) {
            map[i] = true;
          }

          return map
        }

        const fn = typeof this.options === 'function'
          ? this.options
          : date => this.options.includes(date);

        for (let i = 1; i <= this.daysInMonth; i++) {
          const dayHash = this.viewMonthHash + '/' + pad(i);
          map[i] = fn(dayHash);
        }

        return map
      },

      eventDaysMap () {
        const map = {};

        if (this.events === void 0) {
          for (let i = 1; i <= this.daysInMonth; i++) {
            map[i] = false;
          }
        }
        else {
          const fn = typeof this.events === 'function'
            ? this.events
            : date => this.events.includes(date);

          for (let i = 1; i <= this.daysInMonth; i++) {
            const dayHash = this.viewMonthHash + '/' + pad(i);
            map[i] = fn(dayHash) === true && this.evtColor(dayHash);
          }
        }

        return map
      },

      viewDays () {
        let date, endDay;
        const { year, month } = this.viewModel;

        if (this.calendar !== 'persian') {
          date = new Date(year, month - 1, 1);
          endDay = (new Date(year, month - 1, 0)).getDate();
        }
        else {
          const gDate = toGregorian(year, month, 1);
          date = new Date(gDate.gy, gDate.gm - 1, gDate.gd);
          let prevJM = month - 1;
          let prevJY = year;
          if (prevJM === 0) {
            prevJM = 12;
            prevJY--;
          }
          endDay = jalaaliMonthLength(prevJY, prevJM);
        }

        return {
          days: date.getDay() - this.computedFirstDayOfWeek - 1,
          endDay
        }
      },

      days () {
        const res = [];
        const { days, endDay } = this.viewDays;

        const len = days < 0 ? days + 7 : days;
        if (len < 6) {
          for (let i = endDay - len; i <= endDay; i++) {
            res.push({ i, fill: true });
          }
        }

        const index = res.length;

        for (let i = 1; i <= this.daysInMonth; i++) {
          const day = { i, event: this.eventDaysMap[i], classes: [] };

          if (this.selectionDaysMap[i] === true) {
            day.in = true;
            day.flat = true;
          }

          res.push(day);
        }

        // if current view has days in model
        if (this.daysMap[this.viewMonthHash] !== void 0) {
          this.daysMap[this.viewMonthHash].forEach(day => {
            const i = index + day - 1;
            Object.assign(res[i], {
              selected: true,
              unelevated: true,
              flat: false,
              color: this.computedColor,
              textColor: this.computedTextColor
            });
          });
        }

        // if current view has ranges in model
        if (this.rangeMap[this.viewMonthHash] !== void 0) {
          this.rangeMap[this.viewMonthHash].forEach(entry => {
            if (entry.from !== void 0) {
              const from = index + entry.from - 1;
              const to = index + (entry.to || this.daysInMonth) - 1;

              for (let day = from; day <= to; day++) {
                Object.assign(res[day], {
                  range: entry.range,
                  unelevated: true,
                  color: this.computedColor,
                  textColor: this.computedTextColor
                });
              }

              Object.assign(res[from], {
                rangeFrom: true,
                flat: false
              });

              entry.to !== void 0 && Object.assign(res[to], {
                rangeTo: true,
                flat: false
              });
            }
            else if (entry.to !== void 0) {
              const to = index + entry.to - 1;

              for (let day = index; day <= to; day++) {
                Object.assign(res[day], {
                  range: entry.range,
                  unelevated: true,
                  color: this.computedColor,
                  textColor: this.computedTextColor
                });
              }

              Object.assign(res[to], {
                flat: false,
                rangeTo: true
              });
            }
            else {
              const to = index + this.daysInMonth - 1;
              for (let day = index; day <= to; day++) {
                Object.assign(res[day], {
                  range: entry.range,
                  unelevated: true,
                  color: this.computedColor,
                  textColor: this.computedTextColor
                });
              }
            }
          });
        }

        if (this.rangeView !== void 0) {
          const from = index + this.rangeView.from - 1;
          const to = index + this.rangeView.to - 1;

          for (let day = from; day <= to; day++) {
            res[day].color = this.computedColor;
            res[day].editRange = true;
          }

          if (this.rangeView.includeFrom === true) {
            res[from].editRangeFrom = true;
          }
          if (this.rangeView.includeTo === true) {
            res[to].editRangeTo = true;
          }
        }

        if (this.viewModel.year === this.today.year && this.viewModel.month === this.today.month) {
          res[index + this.today.day - 1].today = true;
        }

        const left = res.length % 7;
        if (left > 0) {
          const afterDays = 7 - left;
          for (let i = 1; i <= afterDays; i++) {
            res.push({ i, fill: true });
          }
        }

        res.forEach(day => {
          let cls = 'q-date__calendar-item ';

          if (day.fill === true) {
            cls += 'q-date__calendar-item--fill';
          }
          else {
            cls += `q-date__calendar-item--${day.in === true ? 'in' : 'out'}`;

            if (day.range !== void 0) {
              cls += ` q-date__range${day.rangeTo === true ? '-to' : (day.rangeFrom === true ? '-from' : '')}`;
            }

            if (day.editRange === true) {
              cls += ` q-date__edit-range${day.editRangeFrom === true ? '-from' : ''}${day.editRangeTo === true ? '-to' : ''}`;
            }

            if (day.range !== void 0 || day.editRange === true) {
              cls += ` text-${day.color}`;
            }
          }

          day.classes = cls;
        });

        return res
      },

      attrs () {
        if (this.disable === true) {
          return { 'aria-disabled': 'true' }
        }
        if (this.readonly === true) {
          return { 'aria-readonly': 'true' }
        }
      }
    },

    methods: {
      setToday () {
        const date = this.today;
        const month = this.daysMap[this.__getMonthHash(date)];

        if (month === void 0 || month.includes(date.day) === false) {
          this.__addToModel(date);
        }

        this.setCalendarTo(this.today.year, this.today.month);
      },

      setView (view) {
        if (viewIsValid(view) === true) {
          this.view = view;
        }
      },

      offsetCalendar (type, descending) {
        if (['month', 'year'].includes(type)) {
          this[`__goTo${type === 'month' ? 'Month' : 'Year'}`](
            descending === true ? -1 : 1
          );
        }
      },

      setCalendarTo (year, month) {
        this.view = 'Calendar';
        this.__updateViewModel(year, month);
      },

      setEditingRange (from, to) {
        if (this.range === false || !from) {
          this.editRange = void 0;
          return
        }

        const init = Object.assign({ ...this.viewModel }, from);
        const final = to !== void 0
          ? Object.assign({ ...this.viewModel }, to)
          : init;

        this.editRange = {
          init,
          initHash: this.__getDayHash(init),
          final,
          finalHash: this.__getDayHash(final)
        };

        this.setCalendarTo(init.year, init.month);
      },

      __getMask () {
        return this.calendar === 'persian' ? 'YYYY/MM/DD' : this.mask
      },

      __decodeString (date, mask, locale) {
        return __splitDate(
          date,
          mask,
          locale,
          this.calendar,
          {
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0
          }
        )
      },

      __getViewModel (mask, locale) {
        const model = Array.isArray(this.value) === true
          ? this.value
          : (this.value ? [ this.value ] : []);

        if (model.length === 0) {
          return this.__getDefaultViewModel()
        }

        const decoded = this.__decodeString(
          model[0].from !== void 0 ? model[0].from : model[0],
          mask,
          locale
        );

        return decoded.dateHash === null
          ? this.__getDefaultViewModel()
          : decoded
      },

      __getDefaultViewModel () {
        let year, month;

        if (this.defaultYearMonth !== void 0) {
          const d = this.defaultYearMonth.split('/');
          year = parseInt(d[0], 10);
          month = parseInt(d[1], 10);
        }
        else {
          // may come from data() where computed
          // props are not yet available
          const d = this.today !== void 0
            ? this.today
            : this.__getCurrentDate();

          year = d.year;
          month = d.month;
        }

        return {
          year,
          month,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          dateHash: year + '/' + pad(month) + '/01'
        }
      },

      __getHeader (h) {
        if (this.minimal === true) { return }

        return h('div', {
          staticClass: 'q-date__header',
          class: this.headerClass
        }, [
          h('div', {
            staticClass: 'relative-position'
          }, [
            h('transition', {
              props: {
                name: 'q-transition--fade'
              }
            }, [
              h('div', {
                key: 'h-yr-' + this.headerSubtitle,
                staticClass: 'q-date__header-subtitle q-date__header-link',
                class: this.view === 'Years' ? 'q-date__header-link--active' : 'cursor-pointer',
                attrs: { tabindex: this.computedTabindex },
                on: cache(this, 'vY', {
                  click: () => { this.view = 'Years'; },
                  keyup: e => { e.keyCode === 13 && (this.view = 'Years'); }
                })
              }, [ this.headerSubtitle ])
            ])
          ]),

          h('div', {
            staticClass: 'q-date__header-title relative-position flex no-wrap'
          }, [
            h('div', {
              staticClass: 'relative-position col'
            }, [
              h('transition', {
                props: {
                  name: 'q-transition--fade'
                }
              }, [
                h('div', {
                  key: 'h-sub' + this.headerTitle,
                  staticClass: 'q-date__header-title-label q-date__header-link',
                  class: this.view === 'Calendar' ? 'q-date__header-link--active' : 'cursor-pointer',
                  attrs: { tabindex: this.computedTabindex },
                  on: cache(this, 'vC', {
                    click: () => { this.view = 'Calendar'; },
                    keyup: e => { e.keyCode === 13 && (this.view = 'Calendar'); }
                  })
                }, [ this.headerTitle ])
              ])
            ]),

            this.todayBtn === true ? h(QBtn, {
              staticClass: 'q-date__header-today self-start',
              props: {
                icon: this.$q.iconSet.datetime.today,
                flat: true,
                size: 'sm',
                round: true,
                tabindex: this.computedTabindex
              },
              on: cache(this, 'today', { click: this.setToday })
            }) : null
          ])
        ])
      },

      __getNavigation (h, { label, view, key, dir, goTo, boundaries, cls }) {
        return [
          h('div', {
            staticClass: 'row items-center q-date__arrow'
          }, [
            h(QBtn, {
              props: {
                round: true,
                dense: true,
                size: 'sm',
                flat: true,
                icon: this.dateArrow[0],
                tabindex: this.computedTabindex,
                disable: boundaries.prev === false
              },
              on: cache(this, 'go-#' + view, { click () { goTo(-1); } })
            })
          ]),

          h('div', {
            staticClass: 'relative-position overflow-hidden flex flex-center' + cls
          }, [
            h('transition', {
              props: {
                name: 'q-transition--jump-' + dir
              }
            }, [
              h('div', { key }, [
                h(QBtn, {
                  props: {
                    flat: true,
                    dense: true,
                    noCaps: true,
                    label,
                    tabindex: this.computedTabindex
                  },
                  on: cache(this, 'view#' + view, { click: () => { this.view = view; } })
                })
              ])
            ])
          ]),

          h('div', {
            staticClass: 'row items-center q-date__arrow'
          }, [
            h(QBtn, {
              props: {
                round: true,
                dense: true,
                size: 'sm',
                flat: true,
                icon: this.dateArrow[1],
                tabindex: this.computedTabindex,
                disable: boundaries.next === false
              },
              on: cache(this, 'go+#' + view, { click () { goTo(1); } })
            })
          ])
        ]
      },

      __getCalendarView (h) {
        return [
          h('div', {
            key: 'calendar-view',
            staticClass: 'q-date__view q-date__calendar'
          }, [
            h('div', {
              staticClass: 'q-date__navigation row items-center no-wrap'
            }, this.__getNavigation(h, {
              label: this.innerLocale.months[ this.viewModel.month - 1 ],
              view: 'Months',
              key: this.viewModel.month,
              dir: this.monthDirection,
              goTo: this.__goToMonth,
              boundaries: this.navBoundaries.month,
              cls: ' col'
            }).concat(this.__getNavigation(h, {
              label: this.viewModel.year,
              view: 'Years',
              key: this.viewModel.year,
              dir: this.yearDirection,
              goTo: this.__goToYear,
              boundaries: this.navBoundaries.year,
              cls: ''
            }))),

            h('div', {
              staticClass: 'q-date__calendar-weekdays row items-center no-wrap'
            }, this.daysOfWeek.map(day => h('div', { staticClass: 'q-date__calendar-item' }, [ h('div', [ day ]) ]))),

            h('div', {
              staticClass: 'q-date__calendar-days-container relative-position overflow-hidden'
            }, [
              h('transition', {
                props: {
                  name: 'q-transition--slide-' + this.monthDirection
                }
              }, [
                h('div', {
                  key: this.viewMonthHash,
                  staticClass: 'q-date__calendar-days fit'
                }, this.days.map(day => h('div', { staticClass: day.classes }, [
                  day.in === true
                    ? h(QBtn, {
                      staticClass: day.today === true ? 'q-date__today' : null,
                      props: {
                        dense: true,
                        flat: day.flat,
                        unelevated: day.unelevated,
                        color: day.color,
                        textColor: day.textColor,
                        label: day.i,
                        tabindex: this.computedTabindex
                      },
                      on: cache(this, 'day#' + day.i, {
                        click: () => { this.__onDayClick(day.i); },
                        mouseover: () => { this.__onDayMouseover(day.i); }
                      })
                    }, day.event !== false ? [
                      h('div', { staticClass: 'q-date__event bg-' + day.event })
                    ] : null)
                    : h('div', [ day.i ])
                ])))
              ])
            ])
          ])
        ]
      },

      __getMonthsView (h) {
        const currentYear = this.viewModel.year === this.today.year;
        const isDisabled = month => {
          return (
            (this.minNav !== void 0 && this.viewModel.year === this.minNav.year && this.minNav.month > month) ||
            (this.maxNav !== void 0 && this.viewModel.year === this.maxNav.year && this.maxNav.month < month)
          )
        };

        const content = this.innerLocale.monthsShort.map((month, i) => {
          const active = this.viewModel.month === i + 1;

          return h('div', {
            staticClass: 'q-date__months-item flex flex-center'
          }, [
            h(QBtn, {
              staticClass: currentYear === true && this.today.month === i + 1 ? 'q-date__today' : null,
              props: {
                flat: active !== true,
                label: month,
                unelevated: active,
                color: active === true ? this.computedColor : null,
                textColor: active === true ? this.computedTextColor : null,
                tabindex: this.computedTabindex,
                disable: isDisabled(i + 1)
              },
              on: cache(this, 'month#' + i, { click: () => { this.__setMonth(i + 1); } })
            })
          ])
        });

        this.yearsInMonthView === true && content.unshift(
          h('div', { staticClass: 'row no-wrap full-width' }, [
            this.__getNavigation(h, {
              label: this.viewModel.year,
              view: 'Years',
              key: this.viewModel.year,
              dir: this.yearDirection,
              goTo: this.__goToYear,
              boundaries: this.navBoundaries.year,
              cls: ' col'
            })
          ])
        );

        return h('div', {
          key: 'months-view',
          staticClass: 'q-date__view q-date__months flex flex-center'
        }, content)
      },

      __getYearsView (h) {
        const
          start = this.startYear,
          stop = start + yearsInterval,
          years = [];

        const isDisabled = year => {
          return (
            (this.minNav !== void 0 && this.minNav.year > year) ||
            (this.maxNav !== void 0 && this.maxNav.year < year)
          )
        };

        for (let i = start; i <= stop; i++) {
          const active = this.viewModel.year === i;

          years.push(
            h('div', {
              staticClass: 'q-date__years-item flex flex-center'
            }, [
              h(QBtn, {
                key: 'yr' + i,
                staticClass: this.today.year === i ? 'q-date__today' : null,
                props: {
                  flat: !active,
                  label: i,
                  dense: true,
                  unelevated: active,
                  color: active === true ? this.computedColor : null,
                  textColor: active === true ? this.computedTextColor : null,
                  tabindex: this.computedTabindex,
                  disable: isDisabled(i)
                },
                on: cache(this, 'yr#' + i, { click: () => { this.__setYear(i); } })
              })
            ])
          );
        }

        return h('div', {
          staticClass: 'q-date__view q-date__years flex flex-center'
        }, [
          h('div', {
            staticClass: 'col-auto'
          }, [
            h(QBtn, {
              props: {
                round: true,
                dense: true,
                flat: true,
                icon: this.dateArrow[0],
                tabindex: this.computedTabindex,
                disable: isDisabled(start)
              },
              on: cache(this, 'y-', { click: () => { this.startYear -= yearsInterval; } })
            })
          ]),

          h('div', {
            staticClass: 'q-date__years-content col self-stretch row items-center'
          }, years),

          h('div', {
            staticClass: 'col-auto'
          }, [
            h(QBtn, {
              props: {
                round: true,
                dense: true,
                flat: true,
                icon: this.dateArrow[1],
                tabindex: this.computedTabindex,
                disable: isDisabled(stop)
              },
              on: cache(this, 'y+', { click: () => { this.startYear += yearsInterval; } })
            })
          ])
        ])
      },

      __goToMonth (offset) {
        let year = this.viewModel.year;
        let month = Number(this.viewModel.month) + offset;

        if (month === 13) {
          month = 1;
          year++;
        }
        else if (month === 0) {
          month = 12;
          year--;
        }

        this.__updateViewModel(year, month);
        this.isImmediate === true && this.__emitImmediately('month');
      },

      __goToYear (offset) {
        const year = Number(this.viewModel.year) + offset;
        this.__updateViewModel(year, this.viewModel.month);
        this.isImmediate === true && this.__emitImmediately('year');
      },

      __setYear (year) {
        this.__updateViewModel(year, this.viewModel.month);
        this.view = this.defaultView === 'Years' ? 'Months' : 'Calendar';
        this.isImmediate === true && this.__emitImmediately('year');
      },

      __setMonth (month) {
        this.__updateViewModel(this.viewModel.year, month);
        this.view = 'Calendar';
        this.isImmediate === true && this.__emitImmediately('month');
      },

      __getMonthHash (date) {
        return date.year + '/' + pad(date.month)
      },

      __toggleDate (date, monthHash) {
        const month = this.daysMap[monthHash];
        const fn = month !== void 0 && month.includes(date.day) === true
          ? this.__removeFromModel
          : this.__addToModel;

        fn(date);
      },

      __getShortDate (date) {
        return { year: date.year, month: date.month, day: date.day }
      },

      __onDayClick (dayIndex) {
        const day = { ...this.viewModel, day: dayIndex };

        if (this.range === false) {
          this.__toggleDate(day, this.viewMonthHash);
          return
        }

        if (this.editRange === void 0) {
          const dayProps = this.days.find(day => day.fill !== true && day.i === dayIndex);

          if (dayProps.range !== void 0) {
            this.__removeFromModel({ target: day, from: dayProps.range.from, to: dayProps.range.to });
            return
          }

          if (dayProps.selected === true) {
            this.__removeFromModel(day);
            return
          }

          const initHash = this.__getDayHash(day);

          this.editRange = {
            init: day,
            initHash,
            final: day,
            finalHash: initHash
          };

          this.$emit('range-start', this.__getShortDate(day));
        }
        else {
          const
            initHash = this.editRange.initHash,
            finalHash = this.__getDayHash(day),
            payload = initHash <= finalHash
              ? { from: this.editRange.init, to: day }
              : { from: day, to: this.editRange.init };

          this.editRange = void 0;
          this.__addToModel(initHash === finalHash ? day : { target: day, ...payload });

          this.$emit('range-end', {
            from: this.__getShortDate(payload.from),
            to: this.__getShortDate(payload.to)
          });
        }
      },

      __onDayMouseover (dayIndex) {
        if (this.editRange !== void 0) {
          const final = { ...this.viewModel, day: dayIndex };

          Object.assign(this.editRange, {
            final,
            finalHash: this.__getDayHash(final)
          });
        }
      },

      __updateViewModel (year, month) {
        if (this.minNav !== void 0 && year <= this.minNav.year) {
          year = this.minNav.year;
          if (month < this.minNav.month) {
            month = this.minNav.month;
          }
        }

        if (this.maxNav !== void 0 && year >= this.maxNav.year) {
          year = this.maxNav.year;
          if (month > this.maxNav.month) {
            month = this.maxNav.month;
          }
        }

        const newHash = year + '/' + pad(month) + '/01';

        if (newHash !== this.viewModel.dateHash) {
          this.monthDirection = (this.viewModel.dateHash < newHash) === (this.$q.lang.rtl !== true) ? 'left' : 'right';
          if (year !== this.viewModel.year) {
            this.yearDirection = this.monthDirection;
          }

          this.$nextTick(() => {
            this.startYear = year - year % yearsInterval - (year < 0 ? yearsInterval : 0);
            Object.assign(this.viewModel, {
              year,
              month,
              day: 1,
              dateHash: newHash
            });
          });
        }
      },

      __emitValue (val, action, date) {
        const value = val !== null && val.length === 1 && this.multiple === false
          ? val[0]
          : val;

        this.lastEmitValue = value;

        const { reason, details } = this.__getEmitParams(action, date);
        this.$emit('input', value, reason, details);
      },

      __emitImmediately (reason) {
        const date = this.daysModel[0] !== void 0 && this.daysModel[0].dateHash !== null
          ? { ...this.daysModel[0] }
          : { ...this.viewModel }; // inherit day, hours, minutes, milliseconds...

        // nextTick required because of animation delay in viewModel
        this.$nextTick(() => {
          date.year = this.viewModel.year;
          date.month = this.viewModel.month;

          const maxDay = this.calendar !== 'persian'
            ? (new Date(date.year, date.month, 0)).getDate()
            : jalaaliMonthLength(date.year, date.month);

          date.day = Math.min(Math.max(1, date.day), maxDay);

          const value = this.__encodeEntry(date);
          this.lastEmitValue = value;

          const { details } = this.__getEmitParams('', date);
          this.$emit('input', value, reason, details);
        });
      },

      __getEmitParams (action, date) {
        return date.from !== void 0
          ? {
            reason: `${action}-range`,
            details: {
              ...this.__getShortDate(date.target),
              from: this.__getShortDate(date.from),
              to: this.__getShortDate(date.to),
              changed: true // TODO remove in v2; legacy purposes
            }
          }
          : {
            reason: `${action}-day`,
            details: {
              ...this.__getShortDate(date),
              changed: true // TODO remove in v2; legacy purposes
            }
          }
      },

      __encodeEntry (date, mask, locale) {
        return date.from !== void 0
          ? { from: this.encodeObjectFn(date.from, mask, locale), to: this.encodeObjectFn(date.to, mask, locale) }
          : this.encodeObjectFn(date, mask, locale)
      },

      __addToModel (date) {
        let value;

        if (this.multiple === true) {
          if (date.from !== void 0) {
            // we also need to filter out intersections

            const fromHash = this.__getDayHash(date.from);
            const toHash = this.__getDayHash(date.to);

            const days = this.daysModel
              .filter(day => day.dateHash < fromHash || day.dateHash > toHash);

            const ranges = this.rangeModel
              .filter(({ from, to }) => to.dateHash < fromHash || from.dateHash > toHash);

            value = days.concat(ranges).concat(date).map(entry => this.__encodeEntry(entry));
          }
          else {
            const model = this.normalizedModel.slice();
            model.push(this.__encodeEntry(date));
            value = model;
          }
        }
        else {
          value = this.__encodeEntry(date);
        }

        this.__emitValue(value, 'add', date);
      },

      __removeFromModel (date) {
        if (this.noUnset === true) {
          return
        }

        let model = null;

        if (this.multiple === true && Array.isArray(this.value) === true) {
          const val = this.__encodeEntry(date);

          if (date.from !== void 0) {
            model = this.value.filter(
              date => date.from !== void 0
                ? (date.from !== val.from && date.to !== val.to)
                : true
            );
          }
          else {
            model = this.value.filter(date => date !== val);
          }

          if (model.length === 0) {
            model = null;
          }
        }

        this.__emitValue(model, 'remove', date);
      },

      __updateValue (mask, locale, reason) {
        const model = this.daysModel
          .concat(this.rangeModel)
          .map(entry => this.__encodeEntry(entry, mask, locale))
          .filter(entry => {
            return entry.from !== void 0
              ? entry.from.dateHash !== null && entry.to.dateHash !== null
              : entry.dateHash !== null
          });

        this.$emit('input', (this.multiple === true ? model : model[0]) || null, reason);
      }
    },

    render (h) {
      const content = [
        h('div', {
          staticClass: 'q-date__content col relative-position'
        }, [
          h('transition', {
            props: { name: 'q-transition--fade' }
          }, [
            this[`__get${this.view}View`](h)
          ])
        ])
      ];

      const def = slot(this, 'default');
      def !== void 0 && content.push(
        h('div', { staticClass: 'q-date__actions' }, def)
      );

      if (this.name !== void 0 && this.disable !== true) {
        this.__injectFormInput(content, 'push');
      }

      return h('div', {
        class: this.classes,
        attrs: this.attrs,
        on: { ...this.qListeners }
      }, [
        this.__getHeader(h),

        h('div', {
          staticClass: 'q-date__main col column',
          attrs: { tabindex: -1 },
          ref: 'blurTarget'
        }, content)
      ])
    }
  });

  var HistoryMixin = {
    methods: {
      __addHistory () {
        this.__historyEntry = {
          condition: () => { return this.hideOnRouteChange === true },
          handler: this.hide
        };
        History.add(this.__historyEntry);
      },

      __removeHistory () {
        if (this.__historyEntry !== void 0) {
          History.remove(this.__historyEntry);
          this.__historyEntry = void 0;
        }
      }
    },

    beforeDestroy () {
      this.showing === true && this.__removeHistory();
    }
  };

  let
    registered = 0,
    scrollPositionX,
    scrollPositionY,
    maxScrollTop,
    vpPendingUpdate = false,
    bodyLeft,
    bodyTop,
    closeTimer;

  function onWheel (e) {
    if (shouldPreventScroll(e)) {
      stopAndPrevent(e);
    }
  }

  function shouldPreventScroll (e) {
    if (e.target === document.body || e.target.classList.contains('q-layout__backdrop')) {
      return true
    }

    const
      path = getEventPath(e),
      shift = e.shiftKey && !e.deltaX,
      scrollY = !shift && Math.abs(e.deltaX) <= Math.abs(e.deltaY),
      delta = shift || scrollY ? e.deltaY : e.deltaX;

    for (let index = 0; index < path.length; index++) {
      const el = path[index];

      if (hasScrollbar(el, scrollY)) {
        return scrollY
          ? (
            delta < 0 && el.scrollTop === 0
              ? true
              : delta > 0 && el.scrollTop + el.clientHeight === el.scrollHeight
          )
          : (
            delta < 0 && el.scrollLeft === 0
              ? true
              : delta > 0 && el.scrollLeft + el.clientWidth === el.scrollWidth
          )
      }
    }

    return true
  }

  function onAppleScroll (e) {
    if (e.target === document) {
      // required, otherwise iOS blocks further scrolling
      // until the mobile scrollbar dissappears
      document.scrollingElement.scrollTop = document.scrollingElement.scrollTop; // eslint-disable-line
    }
  }

  function onAppleResize (evt) {
    if (vpPendingUpdate === true) {
      return
    }

    vpPendingUpdate = true;

    requestAnimationFrame(() => {
      vpPendingUpdate = false;

      const
        { height } = evt.target,
        { clientHeight, scrollTop } = document.scrollingElement;

      if (maxScrollTop === void 0 || height !== window.innerHeight) {
        maxScrollTop = clientHeight - height;
        document.scrollingElement.scrollTop = scrollTop;
      }

      if (scrollTop > maxScrollTop) {
        document.scrollingElement.scrollTop -= Math.ceil((scrollTop - maxScrollTop) / 8);
      }
    });
  }

  function apply (action) {
    const
      body = document.body,
      hasViewport = window.visualViewport !== void 0;

    if (action === 'add') {
      const overflowY = window.getComputedStyle(body).overflowY;

      scrollPositionX = getHorizontalScrollPosition(window);
      scrollPositionY = getScrollPosition(window);
      bodyLeft = body.style.left;
      bodyTop = body.style.top;

      body.style.left = `-${scrollPositionX}px`;
      body.style.top = `-${scrollPositionY}px`;
      if (overflowY !== 'hidden' && (overflowY === 'scroll' || body.scrollHeight > window.innerHeight)) {
        body.classList.add('q-body--force-scrollbar');
      }

      body.classList.add('q-body--prevent-scroll');
      document.qScrollPrevented = true;
      if (client.is.ios === true) {
        if (hasViewport === true) {
          window.scrollTo(0, 0);
          window.visualViewport.addEventListener('resize', onAppleResize, listenOpts.passiveCapture);
          window.visualViewport.addEventListener('scroll', onAppleResize, listenOpts.passiveCapture);
          window.scrollTo(0, 0);
        }
        else {
          window.addEventListener('scroll', onAppleScroll, listenOpts.passiveCapture);
        }
      }
    }

    if (client.is.desktop === true && client.is.mac === true) {
      // ref. https://developers.google.com/web/updates/2017/01/scrolling-intervention
      window[`${action}EventListener`]('wheel', onWheel, listenOpts.notPassive);
    }

    if (action === 'remove') {
      if (client.is.ios === true) {
        if (hasViewport === true) {
          window.visualViewport.removeEventListener('resize', onAppleResize, listenOpts.passiveCapture);
          window.visualViewport.removeEventListener('scroll', onAppleResize, listenOpts.passiveCapture);
        }
        else {
          window.removeEventListener('scroll', onAppleScroll, listenOpts.passiveCapture);
        }
      }

      body.classList.remove('q-body--prevent-scroll');
      body.classList.remove('q-body--force-scrollbar');
      document.qScrollPrevented = false;

      body.style.left = bodyLeft;
      body.style.top = bodyTop;

      window.scrollTo(scrollPositionX, scrollPositionY);
      maxScrollTop = void 0;
    }
  }

  function preventScroll (state) {
    let action = 'add';

    if (state === true) {
      registered++;

      if (closeTimer !== void 0) {
        clearTimeout(closeTimer);
        closeTimer = void 0;
        return
      }

      if (registered > 1) {
        return
      }
    }
    else {
      if (registered === 0) {
        return
      }

      registered--;

      if (registered > 0) {
        return
      }

      action = 'remove';

      if (client.is.ios === true && client.is.nativeMobile === true) {
        clearTimeout(closeTimer);

        closeTimer = setTimeout(() => {
          apply(action);
          closeTimer = void 0;
        }, 100);
        return
      }
    }

    apply(action);
  }

  var PreventScrollMixin = {
    methods: {
      __preventScroll (state) {
        if (
          state !== this.preventedScroll &&
          (this.preventedScroll !== void 0 || state === true)
        ) {
          this.preventedScroll = state;
          preventScroll(state);
        }
      }
    }
  };

  let maximizedModals = 0;

  const positionClass = {
    standard: 'fixed-full flex-center',
    top: 'fixed-top justify-center',
    bottom: 'fixed-bottom justify-center',
    right: 'fixed-right items-center',
    left: 'fixed-left items-center'
  };

  const transitions = {
    standard: ['scale', 'scale'],
    top: ['slide-down', 'slide-up'],
    bottom: ['slide-up', 'slide-down'],
    right: ['slide-left', 'slide-right'],
    left: ['slide-right', 'slide-left']
  };

  var QDialog = Vue.extend({
    name: 'QDialog',

    mixins: [
      AttrsMixin,
      HistoryMixin,
      ModelToggleMixin,
      Portal,
      PreventScrollMixin
    ],

    props: {
      persistent: Boolean,
      autoClose: Boolean,

      noEscDismiss: Boolean,
      noBackdropDismiss: Boolean,
      noRouteDismiss: Boolean,
      noRefocus: Boolean,
      noFocus: Boolean,
      noShake: Boolean,

      seamless: Boolean,

      maximized: Boolean,
      fullWidth: Boolean,
      fullHeight: Boolean,

      square: Boolean,

      position: {
        type: String,
        default: 'standard',
        validator: val => val === 'standard' ||
          ['top', 'bottom', 'left', 'right'].includes(val)
      },

      transitionShow: String,
      transitionHide: String
    },

    data () {
      return {
        transitionState: this.showing,
        animating: false
      }
    },

    watch: {
      showing (val) {
        if (this.transitionShowComputed !== this.transitionHideComputed) {
          this.$nextTick(() => {
            this.transitionState = val;
          });
        }
      },

      maximized (state) {
        this.showing === true && this.__updateMaximized(state);
      },

      useBackdrop (v) {
        this.__preventScroll(v);
        this.__preventFocusout(v);
      }
    },

    computed: {
      classes () {
        return `q-dialog__inner--${this.maximized === true ? 'maximized' : 'minimized'} ` +
          `q-dialog__inner--${this.position} ${positionClass[this.position]}` +
          (this.animating === true ? ' q-dialog__inner--animating' : '') +
          (this.fullWidth === true ? ' q-dialog__inner--fullwidth' : '') +
          (this.fullHeight === true ? ' q-dialog__inner--fullheight' : '') +
          (this.square === true ? ' q-dialog__inner--square' : '')
      },

      transitionShowComputed () {
        return 'q-transition--' + (this.transitionShow === void 0 ? transitions[this.position][0] : this.transitionShow)
      },

      transitionHideComputed () {
        return 'q-transition--' + (this.transitionHide === void 0 ? transitions[this.position][1] : this.transitionHide)
      },

      transition () {
        return this.transitionState === true
          ? this.transitionHideComputed
          : this.transitionShowComputed
      },

      useBackdrop () {
        return this.showing === true && this.seamless !== true
      },

      hideOnRouteChange () {
        return this.persistent !== true &&
          this.noRouteDismiss !== true &&
          this.seamless !== true
      },

      onEvents () {
        const on = {
          ...this.qListeners,
          // stop propagating these events from children
          input: stop,
          'popup-show': stop,
          'popup-hide': stop
        };

        if (this.autoClose === true) {
          on.click = this.__onAutoClose;
        }

        return on
      }
    },

    methods: {
      focus (selector) {
        addFocusFn(() => {
          let node = this.__getInnerNode();

          if (node === void 0 || node.contains(document.activeElement) === true) {
            return
          }

          node = node.querySelector(selector || '[autofocus], [data-autofocus]') || node;
          node.focus({ preventScroll: true });
        });
      },

      shake () {
        this.focus();
        this.$emit('shake');

        const node = this.__getInnerNode();

        if (node !== void 0) {
          node.classList.remove('q-animate--scale');
          node.classList.add('q-animate--scale');
          clearTimeout(this.shakeTimeout);
          this.shakeTimeout = setTimeout(() => {
            node.classList.remove('q-animate--scale');
          }, 170);
        }
      },

      __getInnerNode () {
        return this.__portal !== void 0 && this.__portal.$refs !== void 0
          ? this.__portal.$refs.inner
          : void 0
      },

      __show (evt) {
        this.__addHistory();

        // IE can have null document.activeElement
        this.__refocusTarget = client.is.mobile !== true && this.noRefocus === false && document.activeElement !== null
          ? document.activeElement
          : void 0;

        this.$el.dispatchEvent(create('popup-show', { bubbles: true }));
        this.__updateMaximized(this.maximized);

        EscapeKey.register(this, () => {
          if (this.seamless !== true) {
            if (this.persistent === true || this.noEscDismiss === true) {
              this.maximized !== true && this.noShake !== true && this.shake();
            }
            else {
              this.$emit('escape-key');
              this.hide();
            }
          }
        });

        this.__showPortal();
        this.animating = true;

        if (this.noFocus !== true) {
          // IE can have null document.activeElement
          document.activeElement !== null && document.activeElement.blur();
          this.__nextTick(this.focus);
        }

        this.__setTimeout(() => {
          if (this.$q.platform.is.ios === true) {
            if (this.seamless !== true && document.activeElement) {
              const
                { top, bottom } = document.activeElement.getBoundingClientRect(),
                { innerHeight } = window,
                height = window.visualViewport !== void 0
                  ? window.visualViewport.height
                  : innerHeight;

              if (top > 0 && bottom > height / 2) {
                document.scrollingElement.scrollTop = Math.min(
                  document.scrollingElement.scrollHeight - height,
                  bottom >= innerHeight
                    ? Infinity
                    : Math.ceil(document.scrollingElement.scrollTop + bottom - height / 2)
                );
              }

              document.activeElement.scrollIntoView();
            }

            // required in order to avoid the "double-tap needed" issue
            this.__portal.$el.click();
          }

          this.animating = false;
          this.__showPortal(true); // done showing
          this.$emit('show', evt);
        }, 300);
      },

      __hide (evt) {
        this.__removeHistory();
        this.__cleanup(true);
        this.__hidePortal();
        this.animating = true;

        // check null for IE
        if (this.__refocusTarget !== void 0 && this.__refocusTarget !== null) {
          this.__refocusTarget.focus(evt);
          this.__refocusTarget = void 0;
        }

        this.$el.dispatchEvent(create('popup-hide', { bubbles: true }));

        this.__setTimeout(() => {
          this.__hidePortal(true); // done hiding, now destroy
          this.animating = false;
          this.$emit('hide', evt);
        }, 300);
      },

      __cleanup (hiding) {
        clearTimeout(this.shakeTimeout);

        if (hiding === true || this.showing === true) {
          EscapeKey.pop(this);
          this.__updateMaximized(false);

          if (this.seamless !== true) {
            this.__preventScroll(false);
            this.__preventFocusout(false);
          }
        }
      },

      __updateMaximized (active) {
        if (active === true) {
          if (this.isMaximized !== true) {
            maximizedModals < 1 && document.body.classList.add('q-body--dialog');
            maximizedModals++;

            this.isMaximized = true;
          }
        }
        else if (this.isMaximized === true) {
          if (maximizedModals < 2) {
            document.body.classList.remove('q-body--dialog');
          }

          maximizedModals--;
          this.isMaximized = false;
        }
      },

      __preventFocusout (state) {
        if (this.$q.platform.is.desktop === true) {
          const action = `${state === true ? 'add' : 'remove'}EventListener`;
          document.body[action]('focusin', this.__onFocusChange);
        }
      },

      __onAutoClose (e) {
        this.hide(e);
        this.qListeners.click !== void 0 && this.$emit('click', e);
      },

      __onBackdropClick (e) {
        if (this.persistent !== true && this.noBackdropDismiss !== true) {
          this.hide(e);
        }
        else if (this.noShake !== true) {
          this.shake();
        }
      },

      __onFocusChange (e) {
        // the focus is not in a vue child component
        if (
          this.__portalIsAccessible === true &&
          childHasFocus(this.__portal.$el, e.target) !== true
        ) {
          this.focus('[tabindex]:not([tabindex="-1"])');
        }
      },

      __renderPortal (h) {
        return h('div', {
          staticClass: `q-dialog fullscreen no-pointer-events q-dialog--${this.useBackdrop === true ? 'modal' : 'seamless'}`,
          class: this.contentClass,
          style: this.contentStyle,
          attrs: this.qAttrs
        }, [
          h('transition', {
            props: { name: 'q-transition--fade' }
          }, this.useBackdrop === true ? [
            h('div', {
              staticClass: 'q-dialog__backdrop fixed-full',
              attrs: ariaHidden,
              on: cache(this, 'bkdrop', {
                click: this.__onBackdropClick
              })
            })
          ] : null),

          h('transition', {
            props: { name: this.transition }
          }, [
            this.showing === true ? h('div', {
              ref: 'inner',
              staticClass: 'q-dialog__inner flex no-pointer-events',
              class: this.classes,
              attrs: { tabindex: -1 },
              on: this.onEvents
            }, slot(this, 'default')) : null
          ])
        ])
      }
    },

    mounted () {
      this.__processModelChange(this.value);
    },

    beforeDestroy () {
      this.__cleanup();
      this.__refocusTarget = void 0;
    }
  });

  const duration = 150;

  const mouseEvents = [
    'mouseover', 'mouseout', 'mouseenter', 'mouseleave'
  ];

  var QDrawer = Vue.extend({
    name: 'QDrawer',

    inject: {
      layout: {
        default () {
          console.error('QDrawer needs to be child of QLayout');
        }
      }
    },

    mixins: [ DarkMixin, HistoryMixin, ModelToggleMixin, PreventScrollMixin ],

    directives: {
      TouchPan
    },

    props: {
      side: {
        type: String,
        default: 'left',
        validator: v => ['left', 'right'].includes(v)
      },

      width: {
        type: Number,
        default: 300
      },

      mini: Boolean,
      miniToOverlay: Boolean,
      miniWidth: {
        type: Number,
        default: 57
      },

      breakpoint: {
        type: Number,
        default: 1023
      },
      showIfAbove: Boolean,

      behavior: {
        type: String,
        validator: v => ['default', 'desktop', 'mobile'].includes(v),
        default: 'default'
      },

      bordered: Boolean,
      elevated: Boolean,
      contentStyle: [String, Object, Array],
      contentClass: [String, Object, Array],

      overlay: Boolean,
      persistent: Boolean,
      noSwipeOpen: Boolean,
      noSwipeClose: Boolean,
      noSwipeBackdrop: Boolean
    },

    data () {
      const belowBreakpoint = (
        this.behavior === 'mobile' ||
        (this.behavior !== 'desktop' && this.layout.totalWidth <= this.breakpoint)
      );

      return {
        belowBreakpoint,
        showing: this.showIfAbove === true && belowBreakpoint === false
          ? true
          : this.value === true
      }
    },

    watch: {
      belowBreakpoint (val) {
        if (val === true) { // from lg to xs
          this.lastDesktopState = this.showing;
          this.showing === true && this.hide(false);
        }
        else if (
          this.overlay === false &&
          this.behavior !== 'mobile' &&
          this.lastDesktopState !== false
        ) { // from xs to lg
          if (this.showing === true) {
            this.__applyPosition(0);
            this.__applyBackdrop(0);
            this.__cleanup();
          }
          else {
            this.show(false);
          }
        }
      },

      'layout.totalWidth' () {
        if (this.layout.container === true || document.qScrollPrevented !== true) {
          this.__updateBelowBreakpoint();
        }
      },

      side (newSide, oldSide) {
        if (this.layout.instances[oldSide] === this) {
          this.layout.instances[oldSide] = void 0;
          this.layout[oldSide].space = false;
          this.layout[oldSide].offset = 0;
        }

        this.layout.instances[newSide] = this;
        this.layout[newSide].size = this.size;
        this.layout[newSide].space = this.onLayout;
        this.layout[newSide].offset = this.offset;
      },

      behavior () {
        this.__updateBelowBreakpoint();
      },

      breakpoint () {
        this.__updateBelowBreakpoint();
      },

      'layout.container' (val) {
        this.showing === true && this.__preventScroll(val !== true);
        val === true && this.__updateBelowBreakpoint();
      },

      'layout.scrollbarWidth' () {
        this.__applyPosition(this.showing === true ? 0 : void 0);
      },

      offset (val) {
        this.__update('offset', val);
      },

      onLayout (val) {
        this.$emit('on-layout', val);
        this.__update('space', val);
      },

      rightSide () {
        this.__applyPosition();
      },

      size (val) {
        this.__applyPosition();
        this.__updateSizeOnLayout(this.miniToOverlay, val);
      },

      miniToOverlay (val) {
        this.__updateSizeOnLayout(val, this.size);
      },

      '$q.lang.rtl' () {
        this.__applyPosition();
      },

      mini () {
        if (this.value === true) {
          this.__animateMini();
          this.layout.__animate();
        }
      },

      isMini (val) {
        this.$emit('mini-state', val);
      }
    },

    computed: {
      rightSide () {
        return this.side === 'right'
      },

      otherSide () {
        return this.rightSide === true ? 'left' : 'right'
      },

      offset () {
        return this.showing === true && this.belowBreakpoint === false && this.overlay === false
          ? (this.miniToOverlay === true ? this.miniWidth : this.size)
          : 0
      },

      size () {
        return this.isMini === true
          ? this.miniWidth
          : this.width
      },

      fixed () {
        return this.overlay === true ||
          this.miniToOverlay === true ||
          this.layout.view.indexOf(this.rightSide ? 'R' : 'L') > -1 ||
          (this.$q.platform.is.ios && this.layout.container === true)
      },

      onLayout () {
        return this.showing === true && this.belowBreakpoint === false && this.overlay === false
      },

      onScreenOverlay () {
        return this.showing === true && this.belowBreakpoint === false && this.overlay === true
      },

      backdropClass () {
        return this.showing === false ? 'hidden' : null
      },

      headerSlot () {
        return this.rightSide === true
          ? this.layout.rows.top[2] === 'r'
          : this.layout.rows.top[0] === 'l'
      },

      footerSlot () {
        return this.rightSide === true
          ? this.layout.rows.bottom[2] === 'r'
          : this.layout.rows.bottom[0] === 'l'
      },

      aboveStyle () {
        const css = {};

        if (this.layout.header.space === true && this.headerSlot === false) {
          if (this.fixed === true) {
            css.top = `${this.layout.header.offset}px`;
          }
          else if (this.layout.header.space === true) {
            css.top = `${this.layout.header.size}px`;
          }
        }

        if (this.layout.footer.space === true && this.footerSlot === false) {
          if (this.fixed === true) {
            css.bottom = `${this.layout.footer.offset}px`;
          }
          else if (this.layout.footer.space === true) {
            css.bottom = `${this.layout.footer.size}px`;
          }
        }

        return css
      },

      style () {
        const style = { width: `${this.size}px` };
        return this.belowBreakpoint === true
          ? style
          : Object.assign(style, this.aboveStyle)
      },

      classes () {
        return `q-drawer--${this.side}` +
          (this.bordered === true ? ' q-drawer--bordered' : '') +
          (this.isDark === true ? ' q-drawer--dark q-dark' : '') +
          (this.showing !== true ? ' q-layout--prevent-focus' : '') +
          (
            this.belowBreakpoint === true
              ? ' fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding'
              : ` q-drawer--${this.isMini === true ? 'mini' : 'standard'}` +
              (this.fixed === true || this.onLayout !== true ? ' fixed' : '') +
              (this.overlay === true || this.miniToOverlay === true ? ' q-drawer--on-top' : '') +
              (this.headerSlot === true ? ' q-drawer--top-padding' : '')
          )
      },

      stateDirection () {
        return (this.$q.lang.rtl === true ? -1 : 1) * (this.rightSide === true ? 1 : -1)
      },

      isMini () {
        return this.mini === true && this.belowBreakpoint !== true
      },

      onNativeEvents () {
        if (this.belowBreakpoint !== true) {
          const evt = {
            '!click': e => { this.$emit('click', e); }
          };

          mouseEvents.forEach(name => {
            evt[name] = e => {
              this.qListeners[name] !== void 0 && this.$emit(name, e);
            };
          });

          return evt
        }
      },

      hideOnRouteChange () {
        return this.persistent !== true &&
          (this.belowBreakpoint === true || this.onScreenOverlay === true)
      },

      openDirective () {
        const dir = this.$q.lang.rtl === true ? this.side : this.otherSide;

        return [{
          name: 'touch-pan',
          value: this.__openByTouch,
          modifiers: {
            [ dir ]: true,
            mouse: true
          }
        }]
      },

      contentCloseDirective () {
        if (this.noSwipeClose !== true) {
          const dir = this.$q.lang.rtl === true ? this.otherSide : this.side;

          return [{
            name: 'touch-pan',
            value: this.__closeByTouch,
            modifiers: {
              [ dir ]: true,
              mouse: true
            }
          }]
        }
      },

      backdropCloseDirective () {
        if (this.noSwipeBackdrop !== true) {
          const dir = this.$q.lang.rtl === true ? this.otherSide : this.side;

          return [{
            name: 'touch-pan',
            value: this.__closeByTouch,
            modifiers: {
              [ dir ]: true,
              mouse: true,
              mouseAllDir: true
            }
          }]
        }
      }
    },

    methods: {
      __applyPosition (position) {
        if (position === void 0) {
          this.$nextTick(() => {
            position = this.showing === true ? 0 : this.size;
            this.__applyPosition(this.stateDirection * position);
          });
        }
        else if (this.$refs.content !== void 0) {
          if (
            this.layout.container === true &&
            this.rightSide === true &&
            (this.belowBreakpoint === true || Math.abs(position) === this.size)
          ) {
            position += this.stateDirection * this.layout.scrollbarWidth;
          }

          if (this.__lastPosition !== position) {
            this.$refs.content.style.transform = `translateX(${position}px)`;
            this.__lastPosition = position;
          }
        }
      },

      __applyBackdrop (x, retry) {
        if (this.$refs.backdrop !== void 0) {
          this.$refs.backdrop.style.backgroundColor =
            this.lastBackdropBg = `rgba(0,0,0,${x * 0.4})`;
        }
        else {
          // rendered nodes might not have
          // picked up this.showing change yet,
          // so we need one retry
          retry !== true && this.$nextTick(() => {
            this.__applyBackdrop(x, true);
          });
        }
      },

      __setBackdropVisible (v) {
        if (this.$refs.backdrop !== void 0) {
          this.$refs.backdrop.classList[v === true ? 'remove' : 'add']('hidden');
        }
      },

      __setScrollable (v) {
        const action = v === true
          ? 'remove'
          : (this.layout.container !== true ? 'add' : '');

        action !== '' && document.body.classList[action]('q-body--drawer-toggle');
      },

      __animateMini () {
        if (this.timerMini !== void 0) {
          clearTimeout(this.timerMini);
        }
        else if (this.$el !== void 0) {
          this.$el.classList.add('q-drawer--mini-animate');
        }
        this.timerMini = setTimeout(() => {
          this.$el !== void 0 && this.$el.classList.remove('q-drawer--mini-animate');
          this.timerMini = void 0;
        }, 150);
      },

      __openByTouch (evt) {
        if (this.showing !== false) {
          // some browsers might capture and trigger this
          // even if Drawer has just been opened (but animation is still pending)
          return
        }

        const
          width = this.size,
          position = between(evt.distance.x, 0, width);

        if (evt.isFinal === true) {
          const
            el = this.$refs.content,
            opened = position >= Math.min(75, width);

          el.classList.remove('no-transition');

          if (opened === true) {
            this.show();
          }
          else {
            this.layout.__animate();
            this.__applyBackdrop(0);
            this.__applyPosition(this.stateDirection * width);
            el.classList.remove('q-drawer--delimiter');
            el.classList.add('q-layout--prevent-focus');
            this.__setBackdropVisible(false);
          }

          return
        }

        this.__applyPosition(
          (this.$q.lang.rtl === true ? this.rightSide !== true : this.rightSide)
            ? Math.max(width - position, 0)
            : Math.min(0, position - width)
        );
        this.__applyBackdrop(
          between(position / width, 0, 1)
        );

        if (evt.isFirst === true) {
          const el = this.$refs.content;
          el.classList.add('no-transition');
          el.classList.add('q-drawer--delimiter');
          el.classList.remove('q-layout--prevent-focus');
          this.__setBackdropVisible(true);
        }
      },

      __closeByTouch (evt) {
        if (this.showing !== true) {
          // some browsers might capture and trigger this
          // even if Drawer has just been closed (but animation is still pending)
          return
        }

        const
          width = this.size,
          dir = evt.direction === this.side,
          position = (this.$q.lang.rtl === true ? dir !== true : dir)
            ? between(evt.distance.x, 0, width)
            : 0;

        if (evt.isFinal === true) {
          const opened = Math.abs(position) < Math.min(75, width);
          this.$refs.content.classList.remove('no-transition');

          if (opened === true) {
            this.layout.__animate();
            this.__applyBackdrop(1);
            this.__applyPosition(0);
          }
          else {
            this.hide();
          }

          return
        }

        this.__applyPosition(this.stateDirection * position);
        this.__applyBackdrop(between(1 - position / width, 0, 1));

        if (evt.isFirst === true) {
          this.$refs.content.classList.add('no-transition');
        }
      },

      __show (evt, noEvent) {
        this.__addHistory();

        this.__setBackdropVisible(true);
        evt !== false && this.layout.__animate();
        this.__applyPosition(0);

        if (this.belowBreakpoint === true) {
          const otherSide = this.layout.instances[this.otherSide];
          if (otherSide !== void 0 && otherSide.belowBreakpoint === true) {
            otherSide.hide(false);
          }

          this.__applyBackdrop(1);
          this.layout.container !== true && this.__preventScroll(true);
        }
        else {
          this.__applyBackdrop(0);
          evt !== false && this.__setScrollable(false);
        }

        this.__setTimeout(() => {
          evt !== false && this.__setScrollable(true);
          noEvent !== true && this.$emit('show', evt);
        }, duration);
      },

      __hide (evt, noEvent) {
        this.__removeHistory();

        evt !== false && this.layout.__animate();

        this.__applyBackdrop(0);
        this.__applyPosition(this.stateDirection * this.size);
        this.__setBackdropVisible(false);

        this.__cleanup();

        noEvent !== true && this.__setTimeout(() => {
          this.$emit('hide', evt);
        }, duration);
      },

      __cleanup () {
        this.__preventScroll(false);
        this.__setScrollable(true);
      },

      __update (prop, val) {
        if (this.layout[this.side][prop] !== val) {
          this.layout[this.side][prop] = val;
        }
      },

      __updateLocal (prop, val) {
        if (this[prop] !== val) {
          this[prop] = val;
        }
      },

      __updateSizeOnLayout (miniToOverlay, size) {
        this.__update('size', miniToOverlay === true ? this.miniWidth : size);
      },

      __updateBelowBreakpoint () {
        this.__updateLocal('belowBreakpoint', (
          this.behavior === 'mobile' ||
          (this.behavior !== 'desktop' && this.layout.totalWidth <= this.breakpoint)
        ));
      }
    },

    created () {
      this.layout.instances[this.side] = this;
      this.__updateSizeOnLayout(this.miniToOverlay, this.size);
      this.__update('space', this.onLayout);
      this.__update('offset', this.offset);

      if (
        this.showIfAbove === true &&
        this.value !== true &&
        this.showing === true &&
        this.qListeners.input !== void 0
      ) {
        this.$emit('input', true);
      }
    },

    mounted () {
      this.$emit('on-layout', this.onLayout);
      this.$emit('mini-state', this.isMini);

      this.lastDesktopState = this.showIfAbove === true;

      const fn = () => {
        const action = this.showing === true ? 'show' : 'hide';
        this[`__${action}`](false, true);
      };

      if (this.layout.totalWidth !== 0) {
        // make sure that all computed properties
        // have been updated before calling __show/__hide()
        this.$nextTick(fn);
        return
      }

      this.watcher = this.$watch('layout.totalWidth', () => {
        this.watcher();
        this.watcher = void 0;

        if (this.showing === false && this.showIfAbove === true && this.belowBreakpoint === false) {
          this.show(false);
        }
        else {
          fn();
        }
      });
    },

    beforeDestroy () {
      this.watcher !== void 0 && this.watcher();
      clearTimeout(this.timerMini);

      this.showing === true && this.__cleanup();

      if (this.layout.instances[this.side] === this) {
        this.layout.instances[this.side] = void 0;
        this.__update('size', 0);
        this.__update('offset', 0);
        this.__update('space', false);
      }
    },

    render (h) {
      const child = [];

      if (this.belowBreakpoint === true) {
        this.noSwipeOpen !== true && child.push(
          h('div', {
            staticClass: `q-drawer__opener fixed-${this.side}`,
            attrs: ariaHidden,
            directives: this.openDirective
          })
        );

        child.push(
          h('div', {
            ref: 'backdrop',
            staticClass: 'fullscreen q-drawer__backdrop',
            class: this.backdropClass,
            attrs: ariaHidden,
            style: this.lastBackdropBg !== void 0
              ? { backgroundColor: this.lastBackdropBg }
              : null,
            on: cache(this, 'bkdrop', { click: this.hide }),
            directives: this.showing === false
              ? void 0
              : this.backdropCloseDirective
          })
        );
      }

      const content = [
        h('div', {
          staticClass: 'q-drawer__content fit ' + (this.layout.container === true ? 'overflow-auto' : 'scroll'),
          class: this.contentClass,
          style: this.contentStyle
        }, this.isMini === true && this.$scopedSlots.mini !== void 0
          ? this.$scopedSlots.mini()
          : slot(this, 'default')
        )
      ];

      if (this.elevated === true && this.showing === true) {
        content.push(
          h('div', {
            staticClass: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'
          })
        );
      }

      child.push(
        h('aside', {
          ref: 'content',
          staticClass: 'q-drawer',
          class: this.classes,
          style: this.style,
          on: this.onNativeEvents,
          directives: this.belowBreakpoint === true
            ? this.contentCloseDirective
            : void 0
        }, content)
      );

      return h('div', { staticClass: 'q-drawer-container' }, child)
    }
  });

  var QTooltip = Vue.extend({
    name: 'QTooltip',

    mixins: [ AnchorMixin, ModelToggleMixin, Portal, TransitionMixin ],

    props: {
      maxHeight: {
        type: String,
        default: null
      },
      maxWidth: {
        type: String,
        default: null
      },

      transitionShow: {
        default: 'jump-down'
      },
      transitionHide: {
        default: 'jump-up'
      },

      anchor: {
        type: String,
        default: 'bottom middle',
        validator: validatePosition
      },
      self: {
        type: String,
        default: 'top middle',
        validator: validatePosition
      },
      offset: {
        type: Array,
        default: () => [14, 14],
        validator: validateOffset
      },

      scrollTarget: {
        default: void 0
      },

      delay: {
        type: Number,
        default: 0
      },

      hideDelay: {
        type: Number,
        default: 0
      }
    },

    computed: {
      anchorOrigin () {
        return parsePosition(this.anchor, this.$q.lang.rtl)
      },

      selfOrigin () {
        return parsePosition(this.self, this.$q.lang.rtl)
      },

      hideOnRouteChange () {
        return this.persistent !== true
      }
    },

    methods: {
      __show (evt) {
        this.__showPortal();

        this.__nextTick(() => {
          this.observer = new MutationObserver(() => this.updatePosition());
          this.observer.observe(this.__portal.$el, { attributes: false, childList: true, characterData: true, subtree: true });
          this.updatePosition();
          this.__configureScrollTarget();
        });

        if (this.unwatch === void 0) {
          this.unwatch = this.$watch(
            () => this.$q.screen.width + '|' + this.$q.screen.height + '|' + this.self + '|' + this.anchor + '|' + this.$q.lang.rtl,
            this.updatePosition
          );
        }

        this.__setTimeout(() => {
          this.__showPortal(true);
          this.$emit('show', evt);
        }, 300);
      },

      __hide (evt) {
        this.__anchorCleanup();
        this.__hidePortal();

        this.__setTimeout(() => {
          this.__hidePortal(true); // done hiding, now destroy
          this.$emit('hide', evt);
        }, 300);
      },

      __anchorCleanup () {
        if (this.observer !== void 0) {
          this.observer.disconnect();
          this.observer = void 0;
        }

        if (this.unwatch !== void 0) {
          this.unwatch();
          this.unwatch = void 0;
        }

        this.__unconfigureScrollTarget();
        cleanEvt(this, 'tooltipTemp');
      },

      updatePosition () {
        if (this.anchorEl === void 0 || this.__portal === void 0) {
          return
        }

        const el = this.__portal.$el;

        if (el.nodeType === 8) { // IE replaces the comment with delay
          setTimeout(this.updatePosition, 25);
          return
        }

        setPosition({
          el,
          offset: this.offset,
          anchorEl: this.anchorEl,
          anchorOrigin: this.anchorOrigin,
          selfOrigin: this.selfOrigin,
          maxHeight: this.maxHeight,
          maxWidth: this.maxWidth
        });
      },

      __delayShow (evt) {
        if (this.$q.platform.is.mobile === true) {
          clearSelection();
          document.body.classList.add('non-selectable');

          const target = this.anchorEl;
          const evts = ['touchmove', 'touchcancel', 'touchend', 'click']
            .map(e => ([ target, e, '__delayHide', 'passiveCapture' ]));

          addEvt(this, 'tooltipTemp', evts);
        }

        this.__setTimeout(() => {
          this.show(evt);
        }, this.delay);
      },

      __delayHide (evt) {
        this.__clearTimeout();

        if (this.$q.platform.is.mobile === true) {
          cleanEvt(this, 'tooltipTemp');
          clearSelection();
          // delay needed otherwise selection still occurs
          setTimeout(() => {
            document.body.classList.remove('non-selectable');
          }, 10);
        }

        this.__setTimeout(() => {
          this.hide(evt);
        }, this.hideDelay);
      },

      __configureAnchorEl () {
        if (this.noParentEvent === true || this.anchorEl === void 0) { return }

        const evts = this.$q.platform.is.mobile === true
          ? [
            [ this.anchorEl, 'touchstart', '__delayShow', 'passive' ]
          ]
          : [
            [ this.anchorEl, 'mouseenter', '__delayShow', 'passive' ],
            [ this.anchorEl, 'mouseleave', '__delayHide', 'passive' ]
          ];

        addEvt(this, 'anchor', evts);
      },

      __unconfigureScrollTarget () {
        if (this.__scrollTarget !== void 0) {
          this.__changeScrollEvent(this.__scrollTarget);
          this.__scrollTarget = void 0;
        }
      },

      __configureScrollTarget () {
        if (this.anchorEl !== void 0 || this.scrollTarget !== void 0) {
          this.__scrollTarget = getScrollTarget(this.anchorEl, this.scrollTarget);
          const fn = this.noParentEvent === true
            ? this.updatePosition
            : this.hide;

          this.__changeScrollEvent(this.__scrollTarget, fn);
        }
      },

      __renderPortal (h) {
        return h('transition', {
          props: { name: this.transition }
        }, [
          this.showing === true ? h('div', {
            staticClass: 'q-tooltip q-tooltip--style q-position-engine no-pointer-events',
            class: this.contentClass,
            style: this.contentStyle,
            attrs: {
              role: 'complementary'
            }
          }, slot(this, 'default')) : null
        ])
      }
    },

    mounted () {
      this.__processModelChange(this.value);
    }
  });

  var QList = Vue.extend({
    name: 'QList',

    mixins: [ ListenersMixin, DarkMixin ],

    props: {
      bordered: Boolean,
      dense: Boolean,
      separator: Boolean,
      padding: Boolean
    },

    computed: {
      classes () {
        return 'q-list' +
          (this.bordered === true ? ' q-list--bordered' : '') +
          (this.dense === true ? ' q-list--dense' : '') +
          (this.separator === true ? ' q-list--separator' : '') +
          (this.isDark === true ? ' q-list--dark' : '') +
          (this.padding === true ? ' q-list--padding' : '')
      }
    },

    render (h) {
      return h('div', {
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var QItem = Vue.extend({
    name: 'QItem',

    mixins: [ DarkMixin, RouterLinkMixin, TagMixin, ListenersMixin ],

    props: {
      active: Boolean,

      clickable: Boolean,
      dense: Boolean,
      insetLevel: Number,

      tabindex: [ String, Number ],

      focused: Boolean,
      manualFocus: Boolean
    },

    computed: {
      isActionable () {
        return this.clickable === true ||
          this.hasLink === true ||
          this.tag === 'label'
      },

      isClickable () {
        return this.disable !== true && this.isActionable === true
      },

      classes () {
        return {
          'q-item--clickable q-link cursor-pointer': this.isClickable,
          'q-focusable q-hoverable': this.isClickable === true && this.manualFocus === false,

          'q-manual-focusable': this.isClickable === true && this.manualFocus === true,
          'q-manual-focusable--focused': this.isClickable === true && this.focused === true,

          'q-item--dense': this.dense,
          'q-item--dark': this.isDark,
          'q-item--active': this.active,
          [this.activeClass]: this.active === true && this.hasRouterLink !== true && this.activeClass !== void 0,

          'disabled': this.disable
        }
      },

      style () {
        if (this.insetLevel !== void 0) {
          const dir = this.$q.lang.rtl === true ? 'Right' : 'Left';
          return {
            ['padding' + dir]: (16 + this.insetLevel * 56) + 'px'
          }
        }
      },

      onEvents () {
        return {
          ...this.qListeners,
          click: this.__onClick,
          keyup: this.__onKeyup
        }
      }
    },

    methods: {
      __getContent (h) {
        const child = uniqueSlot(this, 'default', []);
        this.isClickable === true && child.unshift(
          h('div', { staticClass: 'q-focus-helper', attrs: { tabindex: -1 }, ref: 'blurTarget' })
        );
        return child
      },

      __onClick (e) {
        if (this.isClickable === true) {
          if (this.$refs.blurTarget !== void 0) {
            if (e.qKeyEvent !== true && document.activeElement === this.$el) {
              this.$refs.blurTarget.focus();
            }
            else if (document.activeElement === this.$refs.blurTarget) {
              this.$el.focus();
            }
          }

          this.$emit('click', e);
        }
      },

      __onKeyup (e) {
        if (this.isClickable === true && isKeyCode(e, 13) === true) {
          stopAndPrevent(e);

          // for ripple
          e.qKeyEvent = true;

          // for click trigger
          const evt = new MouseEvent('click', e);
          evt.qKeyEvent = true;
          this.$el.dispatchEvent(evt);
        }

        this.$emit('keyup', e);
      }
    },

    render (h) {
      const data = {
        staticClass: 'q-item q-item-type row no-wrap',
        class: this.classes,
        style: this.style,
        attrs: {},
        [ this.hasRouterLink === true ? 'nativeOn' : 'on' ]: this.onEvents
      };

      if (this.isClickable === true) {
        data.attrs.tabindex = this.tabindex || '0';
      }
      else if (this.isActionable === true) {
        data.attrs['aria-disabled'] = 'true';
      }

      if (this.hasLink === true) {
        data.props = this.linkProps.props;
        Object.assign(data.attrs, this.linkProps.attrs);
      }

      return h(
        this.linkTag,
        data,
        this.__getContent(h)
      )
    }
  });

  var QItemSection = Vue.extend({
    name: 'QItemSection',

    mixins: [ ListenersMixin ],

    props: {
      avatar: Boolean,
      thumbnail: Boolean,
      side: Boolean,
      top: Boolean,
      noWrap: Boolean
    },

    computed: {
      classes () {
        const side = this.avatar || this.side || this.thumbnail;

        return {
          'q-item__section--top': this.top,
          'q-item__section--avatar': this.avatar,
          'q-item__section--thumbnail': this.thumbnail,
          'q-item__section--side': side,
          'q-item__section--nowrap': this.noWrap,
          'q-item__section--main': !side,
          [`justify-${this.top ? 'start' : 'center'}`]: true
        }
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-item__section column',
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  function run (e, btn, vm) {
    if (btn.handler) {
      btn.handler(e, vm, vm.caret);
    }
    else {
      vm.runCmd(btn.cmd, btn.param);
    }
  }

  function __getGroup (h, children) {
    return h('div', {
      staticClass: 'q-editor__toolbar-group'
    }, children)
  }

  function getBtn (h, vm, btn, clickHandler, active = false) {
    const
      toggled = active || (btn.type === 'toggle'
        ? (btn.toggled ? btn.toggled(vm) : btn.cmd && vm.caret.is(btn.cmd, btn.param))
        : false),
      child = [],
      events = {
        click (e) {
          clickHandler && clickHandler();
          run(e, btn, vm);
        }
      };

    if (btn.tip && vm.$q.platform.is.desktop) {
      const Key = btn.key
        ? h('div', [h('small', `(CTRL + ${String.fromCharCode(btn.key)})`)])
        : null;
      child.push(
        h(QTooltip, { props: { delay: 1000 } }, [
          h('div', { domProps: { innerHTML: btn.tip } }),
          Key
        ])
      );
    }

    return h(QBtn, {
      props: {
        ...vm.buttonProps,
        icon: btn.icon !== null ? btn.icon : void 0,
        color: toggled ? btn.toggleColor || vm.toolbarToggleColor : btn.color || vm.toolbarColor,
        textColor: toggled && !vm.toolbarPush ? null : btn.textColor || vm.toolbarTextColor,
        label: btn.label,
        disable: btn.disable ? (typeof btn.disable === 'function' ? btn.disable(vm) : true) : false,
        size: 'sm'
      },
      on: events
    }, child)
  }

  function getDropdown (h, vm, btn) {
    const onlyIcons = btn.list === 'only-icons';
    let
      label = btn.label,
      icon = btn.icon !== null ? btn.icon : void 0,
      contentClass,
      Items;

    function closeDropdown () {
      Dropdown.componentInstance.hide();
    }

    if (onlyIcons) {
      Items = btn.options.map(btn => {
        const active = btn.type === void 0
          ? vm.caret.is(btn.cmd, btn.param)
          : false;

        if (active) {
          label = btn.tip;
          icon = btn.icon !== null ? btn.icon : void 0;
        }
        return getBtn(h, vm, btn, closeDropdown, active)
      });
      contentClass = vm.toolbarBackgroundClass;
      Items = [
        __getGroup(h, Items)
      ];
    }
    else {
      const activeClass = vm.toolbarToggleColor !== void 0
        ? `text-${vm.toolbarToggleColor}`
        : null;
      const inactiveClass = vm.toolbarTextColor !== void 0
        ? `text-${vm.toolbarTextColor}`
        : null;

      const noIcons = btn.list === 'no-icons';

      Items = btn.options.map(btn => {
        const disable = btn.disable ? btn.disable(vm) : false;
        const active = btn.type === void 0
          ? vm.caret.is(btn.cmd, btn.param)
          : false;

        if (active) {
          label = btn.tip;
          icon = btn.icon !== null ? btn.icon : void 0;
        }

        const htmlTip = btn.htmlTip;

        return h(
          QItem,
          {
            props: { active, activeClass, clickable: true, disable: disable, dense: true },
            on: {
              click (e) {
                closeDropdown();
                vm.$refs.content && vm.$refs.content.focus();
                vm.caret.restore();
                run(e, btn, vm);
              }
            }
          },
          [
            noIcons === true
              ? null
              : h(QItemSection, {
                class: active ? activeClass : inactiveClass,
                props: { side: true }
              }, [
                h(QIcon, { props: { name: btn.icon !== null ? btn.icon : void 0 } })
              ]),

            h(QItemSection, [
              htmlTip
                ? h('div', {
                  staticClass: 'text-no-wrap',
                  domProps: { innerHTML: btn.htmlTip }
                })
                : (
                  btn.tip
                    ? h('div', { staticClass: 'text-no-wrap' }, [ btn.tip ])
                    : null
                )
            ])
          ]
        )
      });
      contentClass = [vm.toolbarBackgroundClass, inactiveClass];
      Items = [
        h(QList, [ Items ])
      ];
    }

    const highlight = btn.highlight && label !== btn.label;
    const Dropdown = h(
      QBtnDropdown,
      {
        props: {
          ...vm.buttonProps,
          noCaps: true,
          noWrap: true,
          color: highlight ? vm.toolbarToggleColor : vm.toolbarColor,
          textColor: highlight && !vm.toolbarPush ? null : vm.toolbarTextColor,
          label: btn.fixedLabel ? btn.label : label,
          icon: btn.fixedIcon ? (btn.icon !== null ? btn.icon : void 0) : icon,
          contentClass
        }
      },
      Items
    );
    return Dropdown
  }

  function getToolbar (h, vm) {
    if (vm.caret) {
      return vm.buttons
        .filter(f => {
          return !vm.isViewingSource || f.find(fb => fb.cmd === 'viewsource')
        })
        .map(group => __getGroup(
          h,
          group.map(btn => {
            if (vm.isViewingSource && btn.cmd !== 'viewsource') {
              return false
            }

            if (btn.type === 'slot') {
              return slot(vm, btn.slot)
            }

            if (btn.type === 'dropdown') {
              return getDropdown(h, vm, btn)
            }

            return getBtn(h, vm, btn)
          })
        ))
    }
  }

  function getFonts (defaultFont, defaultFontLabel, defaultFontIcon, fonts = {}) {
    const aliases = Object.keys(fonts);
    if (aliases.length === 0) {
      return {}
    }

    const def = {
      default_font: {
        cmd: 'fontName',
        param: defaultFont,
        icon: defaultFontIcon,
        tip: defaultFontLabel
      }
    };

    aliases.forEach(alias => {
      const name = fonts[alias];
      def[alias] = {
        cmd: 'fontName',
        param: name,
        icon: defaultFontIcon,
        tip: name,
        htmlTip: `<font face="${name}">${name}</font>`
      };
    });

    return def
  }

  function getLinkEditor (h, vm, ie11) {
    if (vm.caret) {
      const color = vm.toolbarColor || vm.toolbarTextColor;
      let link = vm.editLinkUrl;
      const updateLink = () => {
        vm.caret.restore();

        if (link !== vm.editLinkUrl) {
          document.execCommand('createLink', false, link === '' ? ' ' : link);
        }

        vm.editLinkUrl = null;

        ie11 === true && vm.$nextTick(vm.__onInput);
      };

      return [
        h('div', { staticClass: 'q-mx-xs', 'class': `text-${color}` }, [`${vm.$q.lang.editor.url}: `]),
        h('input', {
          key: 'qedt_btm_input',
          staticClass: 'col q-editor__link-input',
          domProps: {
            value: link
          },
          on: {
            input: e => {
              stop(e);
              link = e.target.value;
            },
            keydown: event => {
              if (shouldIgnoreKey(event) === true) {
                return
              }

              switch (event.keyCode) {
                case 13: // ENTER key
                  prevent(event);
                  return updateLink()
                case 27: // ESCAPE key
                  prevent(event);
                  vm.caret.restore();
                  if (!vm.editLinkUrl || vm.editLinkUrl === 'https://') {
                    document.execCommand('unlink');
                  }
                  vm.editLinkUrl = null;
                  break
              }
            }
          }
        }),
        __getGroup(h, [
          h(QBtn, {
            key: 'qedt_btm_rem',
            attrs: { tabindex: -1 },
            props: {
              ...vm.buttonProps,
              label: vm.$q.lang.label.remove,
              noCaps: true
            },
            on: {
              click: () => {
                vm.caret.restore();
                document.execCommand('unlink');
                vm.editLinkUrl = null;

                ie11 === true && vm.$nextTick(vm.__onInput);
              }
            }
          }),
          h(QBtn, {
            key: 'qedt_btm_upd',
            props: {
              ...vm.buttonProps,
              label: vm.$q.lang.label.update,
              noCaps: true
            },
            on: {
              click: updateLink
            }
          })
        ])
      ]
    }
  }

  function getBlockElement (el, parent) {
    if (parent && el === parent) {
      return null
    }

    const nodeName = el.nodeName.toLowerCase();

    if (['div', 'li', 'ul', 'ol', 'blockquote'].includes(nodeName) === true) {
      return el
    }

    const
      style = window.getComputedStyle
        ? window.getComputedStyle(el)
        : el.currentStyle,
      display = style.display;

    if (display === 'block' || display === 'table') {
      return el
    }

    return getBlockElement(el.parentNode)
  }

  function isChildOf (el, parent, orSame) {
    return !el || el === document.body
      ? false
      : (orSame === true && el === parent) || (parent === document ? document.body : parent).contains(el.parentNode)
  }

  function createRange (node, chars, range) {
    if (!range) {
      range = document.createRange();
      range.selectNode(node);
      range.setStart(node, 0);
    }

    if (chars.count === 0) {
      range.setEnd(node, chars.count);
    }
    else if (chars.count > 0) {
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent.length < chars.count) {
          chars.count -= node.textContent.length;
        }
        else {
          range.setEnd(node, chars.count);
          chars.count = 0;
        }
      }
      else {
        for (let lp = 0; chars.count !== 0 && lp < node.childNodes.length; lp++) {
          range = createRange(node.childNodes[lp], chars, range);
        }
      }
    }

    return range
  }

  const urlRegex = /^https?:\/\//;

  class Caret {
    constructor (el, vm) {
      this.el = el;
      this.vm = vm;
      this._range = null;
    }

    get selection () {
      if (this.el) {
        const sel = document.getSelection();

        // only when the selection in element
        if (isChildOf(sel.anchorNode, this.el, true) && isChildOf(sel.focusNode, this.el, true)) {
          return sel
        }
      }

      return null
    }

    get hasSelection () {
      return this.selection !== null
        ? this.selection.toString().length > 0
        : false
    }

    get range () {
      const sel = this.selection;

      if (sel !== null && sel.rangeCount) {
        return sel.getRangeAt(0)
      }

      return this._range
    }

    get parent () {
      const range = this.range;

      if (range !== null) {
        const node = range.startContainer;

        return node.nodeType === document.ELEMENT_NODE
          ? node
          : node.parentNode
      }

      return null
    }

    get blockParent () {
      const parent = this.parent;

      if (parent !== null) {
        return getBlockElement(parent, this.el)
      }

      return null
    }

    save (range = this.range) {
      if (range !== null) {
        this._range = range;
      }
    }

    restore (range = this._range) {
      const
        r = document.createRange(),
        sel = document.getSelection();

      if (range !== null) {
        r.setStart(range.startContainer, range.startOffset);
        r.setEnd(range.endContainer, range.endOffset);
        sel.removeAllRanges();
        sel.addRange(r);
      }
      else {
        sel.selectAllChildren(this.el);
        sel.collapseToEnd();
      }
    }

    savePosition () {
      let charCount = -1, node;
      const
        selection = document.getSelection(),
        parentEl = this.el.parentNode;

      if (selection.focusNode && isChildOf(selection.focusNode, parentEl)) {
        node = selection.focusNode;
        charCount = selection.focusOffset;

        while (node && node !== parentEl) {
          if (node !== this.el && node.previousSibling) {
            node = node.previousSibling;
            charCount += node.textContent.length;
          }
          else {
            node = node.parentNode;
          }
        }
      }

      this.savedPos = charCount;
    }

    restorePosition (length = 0) {
      if (this.savedPos > 0 && this.savedPos < length) {
        const
          selection = window.getSelection(),
          range = createRange(this.el, { count: this.savedPos });

        if (range) {
          range.collapse(false);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    }

    hasParent (name, spanLevel) {
      const el = spanLevel
        ? this.parent
        : this.blockParent;

      return el !== null
        ? el.nodeName.toLowerCase() === name.toLowerCase()
        : false
    }

    hasParents (list, recursive, el = this.parent) {
      if (el === null) {
        return false
      }

      if (list.includes(el.nodeName.toLowerCase()) === true) {
        return true
      }

      return recursive === true
        ? this.hasParents(list, recursive, el.parentNode)
        : false
    }

    is (cmd, param) {
      if (this.selection === null) {
        return false
      }

      switch (cmd) {
        case 'formatBlock':
          if (param === 'DIV' && this.parent === this.el) {
            return true
          }
          return this.hasParent(param, param === 'PRE')
        case 'link':
          return this.hasParent('A', true)
        case 'fontSize':
          return document.queryCommandValue(cmd) === param
        case 'fontName':
          const res = document.queryCommandValue(cmd);
          return res === `"${param}"` || res === param
        case 'fullscreen':
          return this.vm.inFullscreen
        case 'viewsource':
          return this.vm.isViewingSource
        case void 0:
          return false
        default:
          const state = document.queryCommandState(cmd);
          return param !== void 0 ? state === param : state
      }
    }

    getParentAttribute (attrib) {
      if (this.parent !== null) {
        return this.parent.getAttribute(attrib)
      }

      return null
    }

    can (name) {
      if (name === 'outdent') {
        return this.hasParents(['blockquote', 'li'], true)
      }

      if (name === 'indent') {
        return this.hasParents(['li'], true)
      }

      if (name === 'link') {
        return this.selection !== null || this.is('link')
      }
    }

    apply (cmd, param, done = noop) {
      if (cmd === 'formatBlock') {
        if (['BLOCKQUOTE', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(param) && this.is(cmd, param)) {
          cmd = 'outdent';
          param = null;
        }

        if (param === 'PRE' && this.is(cmd, 'PRE')) {
          param = 'P';
        }
      }
      else if (cmd === 'print') {
        done();

        const win = window.open();

        win.document.write(`
        <!doctype html>
        <html>
          <head>
            <title>Print - ${document.title}</title>
          </head>
          <body>
            <div>${this.el.innerHTML}</div>
          </body>
        </html>
      `);
        win.print();
        win.close();

        return
      }
      else if (cmd === 'link') {
        const link = this.getParentAttribute('href');

        if (link === null) {
          const selection = this.selectWord(this.selection);
          const url = selection ? selection.toString() : '';

          if (!url.length) {
            if (!this.range || !this.range.cloneContents().querySelector('img')) {
              return
            }
          }

          this.vm.editLinkUrl = urlRegex.test(url) ? url : 'https://';
          document.execCommand('createLink', false, this.vm.editLinkUrl);

          this.save(selection.getRangeAt(0));
        }
        else {
          this.vm.editLinkUrl = link;

          this.range.selectNodeContents(this.parent);
          this.save();
        }

        return
      }
      else if (cmd === 'fullscreen') {
        this.vm.toggleFullscreen();
        done();

        return
      }
      else if (cmd === 'viewsource') {
        this.vm.isViewingSource = this.vm.isViewingSource === false;
        this.vm.__setContent(this.vm.value);
        done();

        return
      }

      document.execCommand(cmd, false, param);

      done();
    }

    selectWord (sel) {
      if (sel === null || sel.isCollapsed !== true || /* IE 11 */ sel.modify === void 0) {
        return sel
      }

      // Detect if selection is backwards
      const range = document.createRange();
      range.setStart(sel.anchorNode, sel.anchorOffset);
      range.setEnd(sel.focusNode, sel.focusOffset);
      const direction = range.collapsed ? ['backward', 'forward'] : ['forward', 'backward'];
      range.detach();

      // modify() works on the focus of the selection
      const
        endNode = sel.focusNode,
        endOffset = sel.focusOffset;
      sel.collapse(sel.anchorNode, sel.anchorOffset);
      sel.modify('move', direction[0], 'character');
      sel.modify('move', direction[1], 'word');
      sel.extend(endNode, endOffset);
      sel.modify('extend', direction[1], 'character');
      sel.modify('extend', direction[0], 'word');

      return sel
    }
  }

  const
    toString = Object.prototype.toString,
    hasOwn = Object.prototype.hasOwnProperty,
    class2type = {};

  'Boolean Number String Function Array Date RegExp Object'.split(' ').forEach(name => {
    class2type['[object ' + name + ']'] = name.toLowerCase();
  });

  function type (obj) {
    return obj === null ? String(obj) : class2type[toString.call(obj)] || 'object'
  }

  function isPlainObject (obj) {
    if (!obj || type(obj) !== 'object') {
      return false
    }

    if (obj.constructor &&
      !hasOwn.call(obj, 'constructor') &&
      !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
      return false
    }

    let key;
    for (key in obj) {}

    return key === void 0 || hasOwn.call(obj, key)
  }

  function extend () {
    let
      options, name, src, copy, copyIsArray, clone,
      target = arguments[0] || {},
      i = 1,
      deep = false;
    const length = arguments.length;

    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }

    if (Object(target) !== target && type(target) !== 'function') {
      target = {};
    }

    if (length === i) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      if ((options = arguments[i]) !== null) {
        for (name in options) {
          src = target[name];
          copy = options[name];

          if (target === copy) {
            continue
          }

          if (deep && copy && (isPlainObject(copy) === true || (copyIsArray = type(copy) === 'array'))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && type(src) === 'array' ? src : [];
            }
            else {
              clone = src && isPlainObject(src) === true ? src : {};
            }

            target[name] = extend(deep, clone, copy);
          }
          else if (copy !== void 0) {
            target[name] = copy;
          }
        }
      }
    }

    return target
  }

  var QEditor = Vue.extend({
    name: 'QEditor',

    mixins: [ ListenersMixin, FullscreenMixin, DarkMixin ],

    props: {
      value: {
        type: String,
        required: true
      },
      readonly: Boolean,
      disable: Boolean,
      minHeight: {
        type: String,
        default: '10rem'
      },
      maxHeight: String,
      height: String,
      definitions: Object,
      fonts: Object,
      placeholder: String,

      toolbar: {
        type: Array,
        validator: v => v.length === 0 || v.every(group => group.length),
        default () {
          return [
            ['left', 'center', 'right', 'justify'],
            ['bold', 'italic', 'underline', 'strike'],
            ['undo', 'redo']
          ]
        }
      },
      toolbarColor: String,
      toolbarBg: String,
      toolbarTextColor: String,
      toolbarToggleColor: {
        type: String,
        default: 'primary'
      },
      toolbarOutline: Boolean,
      toolbarPush: Boolean,
      toolbarRounded: Boolean,

      paragraphTag: {
        type: String,
        validator: v => ['div', 'p'].includes(v),
        default: 'div'
      },

      contentStyle: Object,
      contentClass: [Object, Array, String],

      square: Boolean,
      flat: Boolean,
      dense: Boolean
    },

    computed: {
      editable () {
        return !this.readonly && !this.disable
      },

      hasToolbar () {
        return this.toolbar && this.toolbar.length > 0
      },

      toolbarBackgroundClass () {
        if (this.toolbarBg) {
          return `bg-${this.toolbarBg}`
        }
      },

      buttonProps () {
        const flat = this.toolbarOutline !== true &&
          this.toolbarPush !== true;

        return {
          type: 'a',
          flat,
          noWrap: true,
          outline: this.toolbarOutline,
          push: this.toolbarPush,
          rounded: this.toolbarRounded,
          dense: true,
          color: this.toolbarColor,
          disable: !this.editable,
          size: 'sm'
        }
      },

      buttonDef () {
        const
          e = this.$q.lang.editor,
          i = this.$q.iconSet.editor;

        return {
          bold: { cmd: 'bold', icon: i.bold, tip: e.bold, key: 66 },
          italic: { cmd: 'italic', icon: i.italic, tip: e.italic, key: 73 },
          strike: { cmd: 'strikeThrough', icon: i.strikethrough, tip: e.strikethrough, key: 83 },
          underline: { cmd: 'underline', icon: i.underline, tip: e.underline, key: 85 },
          unordered: { cmd: 'insertUnorderedList', icon: i.unorderedList, tip: e.unorderedList },
          ordered: { cmd: 'insertOrderedList', icon: i.orderedList, tip: e.orderedList },
          subscript: { cmd: 'subscript', icon: i.subscript, tip: e.subscript, htmlTip: 'x<subscript>2</subscript>' },
          superscript: { cmd: 'superscript', icon: i.superscript, tip: e.superscript, htmlTip: 'x<superscript>2</superscript>' },
          link: { cmd: 'link', disable: vm => vm.caret && !vm.caret.can('link'), icon: i.hyperlink, tip: e.hyperlink, key: 76 },
          fullscreen: { cmd: 'fullscreen', icon: i.toggleFullscreen, tip: e.toggleFullscreen, key: 70 },
          viewsource: { cmd: 'viewsource', icon: i.viewSource, tip: e.viewSource },

          quote: { cmd: 'formatBlock', param: 'BLOCKQUOTE', icon: i.quote, tip: e.quote, key: 81 },
          left: { cmd: 'justifyLeft', icon: i.left, tip: e.left },
          center: { cmd: 'justifyCenter', icon: i.center, tip: e.center },
          right: { cmd: 'justifyRight', icon: i.right, tip: e.right },
          justify: { cmd: 'justifyFull', icon: i.justify, tip: e.justify },

          print: { type: 'no-state', cmd: 'print', icon: i.print, tip: e.print, key: 80 },
          outdent: { type: 'no-state', disable: vm => vm.caret && !vm.caret.can('outdent'), cmd: 'outdent', icon: i.outdent, tip: e.outdent },
          indent: { type: 'no-state', disable: vm => vm.caret && !vm.caret.can('indent'), cmd: 'indent', icon: i.indent, tip: e.indent },
          removeFormat: { type: 'no-state', cmd: 'removeFormat', icon: i.removeFormat, tip: e.removeFormat },
          hr: { type: 'no-state', cmd: 'insertHorizontalRule', icon: i.hr, tip: e.hr },
          undo: { type: 'no-state', cmd: 'undo', icon: i.undo, tip: e.undo, key: 90 },
          redo: { type: 'no-state', cmd: 'redo', icon: i.redo, tip: e.redo, key: 89 },

          h1: { cmd: 'formatBlock', param: 'H1', icon: i.heading1 || i.heading, tip: e.heading1, htmlTip: `<h1 class="q-ma-none">${e.heading1}</h1>` },
          h2: { cmd: 'formatBlock', param: 'H2', icon: i.heading2 || i.heading, tip: e.heading2, htmlTip: `<h2 class="q-ma-none">${e.heading2}</h2>` },
          h3: { cmd: 'formatBlock', param: 'H3', icon: i.heading3 || i.heading, tip: e.heading3, htmlTip: `<h3 class="q-ma-none">${e.heading3}</h3>` },
          h4: { cmd: 'formatBlock', param: 'H4', icon: i.heading4 || i.heading, tip: e.heading4, htmlTip: `<h4 class="q-ma-none">${e.heading4}</h4>` },
          h5: { cmd: 'formatBlock', param: 'H5', icon: i.heading5 || i.heading, tip: e.heading5, htmlTip: `<h5 class="q-ma-none">${e.heading5}</h5>` },
          h6: { cmd: 'formatBlock', param: 'H6', icon: i.heading6 || i.heading, tip: e.heading6, htmlTip: `<h6 class="q-ma-none">${e.heading6}</h6>` },
          p: { cmd: 'formatBlock', param: this.paragraphTag.toUpperCase(), icon: i.heading, tip: e.paragraph },
          code: { cmd: 'formatBlock', param: 'PRE', icon: i.code, htmlTip: `<code>${e.code}</code>` },

          'size-1': { cmd: 'fontSize', param: '1', icon: i.size1 || i.size, tip: e.size1, htmlTip: `<font size="1">${e.size1}</font>` },
          'size-2': { cmd: 'fontSize', param: '2', icon: i.size2 || i.size, tip: e.size2, htmlTip: `<font size="2">${e.size2}</font>` },
          'size-3': { cmd: 'fontSize', param: '3', icon: i.size3 || i.size, tip: e.size3, htmlTip: `<font size="3">${e.size3}</font>` },
          'size-4': { cmd: 'fontSize', param: '4', icon: i.size4 || i.size, tip: e.size4, htmlTip: `<font size="4">${e.size4}</font>` },
          'size-5': { cmd: 'fontSize', param: '5', icon: i.size5 || i.size, tip: e.size5, htmlTip: `<font size="5">${e.size5}</font>` },
          'size-6': { cmd: 'fontSize', param: '6', icon: i.size6 || i.size, tip: e.size6, htmlTip: `<font size="6">${e.size6}</font>` },
          'size-7': { cmd: 'fontSize', param: '7', icon: i.size7 || i.size, tip: e.size7, htmlTip: `<font size="7">${e.size7}</font>` }
        }
      },

      buttons () {
        const userDef = this.definitions || {};
        const def = this.definitions || this.fonts
          ? extend(
            true,
            {},
            this.buttonDef,
            userDef,
            getFonts(
              this.defaultFont,
              this.$q.lang.editor.defaultFont,
              this.$q.iconSet.editor.font,
              this.fonts
            )
          )
          : this.buttonDef;

        return this.toolbar.map(
          group => group.map(token => {
            if (token.options) {
              return {
                type: 'dropdown',
                icon: token.icon,
                label: token.label,
                size: 'sm',
                dense: true,
                fixedLabel: token.fixedLabel,
                fixedIcon: token.fixedIcon,
                highlight: token.highlight,
                list: token.list,
                options: token.options.map(item => def[item])
              }
            }

            const obj = def[token];

            if (obj) {
              return obj.type === 'no-state' || (userDef[token] && (
                obj.cmd === void 0 || (this.buttonDef[obj.cmd] && this.buttonDef[obj.cmd].type === 'no-state')
              ))
                ? obj
                : Object.assign({ type: 'toggle' }, obj)
            }
            else {
              return {
                type: 'slot',
                slot: token
              }
            }
          })
        )
      },

      keys () {
        const
          k = {},
          add = btn => {
            if (btn.key) {
              k[btn.key] = {
                cmd: btn.cmd,
                param: btn.param
              };
            }
          };

        this.buttons.forEach(group => {
          group.forEach(token => {
            if (token.options) {
              token.options.forEach(add);
            }
            else {
              add(token);
            }
          });
        });
        return k
      },

      innerStyle () {
        return this.inFullscreen
          ? this.contentStyle
          : [
            {
              minHeight: this.minHeight,
              height: this.height,
              maxHeight: this.maxHeight
            },
            this.contentStyle
          ]
      },

      classes () {
        return `q-editor q-editor--${this.isViewingSource === true ? 'source' : 'default'}` +
          (this.disable === true ? ' disabled' : '') +
          (this.inFullscreen === true ? ' fullscreen column' : '') +
          (this.square === true ? ' q-editor--square no-border-radius' : '') +
          (this.flat === true ? ' q-editor--flat' : '') +
          (this.dense === true ? ' q-editor--dense' : '') +
          (this.isDark === true ? ' q-editor--dark q-dark' : '')
      },

      innerClass () {
        return [
          this.contentClass,
          { col: this.inFullscreen, 'overflow-auto': this.inFullscreen || this.maxHeight }
        ]
      },

      attrs () {
        if (this.disable === true) {
          return { 'aria-disabled': 'true' }
        }
        if (this.readonly === true) {
          return { 'aria-readonly': 'true' }
        }
      },

      onEditor () {
        return {
          focusin: this.__onFocusin,
          focusout: this.__onFocusout
        }
      }
    },

    data () {
      return {
        lastEmit: this.value,
        editLinkUrl: null,
        isViewingSource: false
      }
    },

    watch: {
      value (v) {
        if (this.lastEmit !== v) {
          this.lastEmit = v;
          this.__setContent(v, true);
        }
      }
    },

    methods: {
      __onInput () {
        if (this.$refs.content !== void 0) {
          const val = this.isViewingSource === true
            ? this.$refs.content.innerText
            : this.$refs.content.innerHTML;

          if (val !== this.value) {
            this.lastEmit = val;
            this.$emit('input', val);
          }
        }
      },

      __onKeydown (e) {
        this.$emit('keydown', e);

        if (e.ctrlKey !== true || shouldIgnoreKey(e) === true) {
          this.refreshToolbar();
          this.$q.platform.is.ie && this.$nextTick(this.__onInput);
          return
        }

        const key = e.keyCode;
        const target = this.keys[key];
        if (target !== void 0) {
          const { cmd, param } = target;
          stopAndPrevent(e);
          this.runCmd(cmd, param, false);
        }
      },

      __onClick (e) {
        this.refreshToolbar();
        this.$emit('click', e);
      },

      __onBlur (e) {
        if (this.$refs.content !== void 0) {
          const { scrollTop, scrollHeight } = this.$refs.content;
          this.__offsetBottom = scrollHeight - scrollTop;
        }
        this.$q.platform.is.ie !== true && this.caret.save();
        this.$emit('blur', e);
      },

      __onFocus (e) {
        this.$nextTick(() => {
          if (this.$refs.content !== void 0 && this.__offsetBottom !== void 0) {
            this.$refs.content.scrollTop = this.$refs.content.scrollHeight - this.__offsetBottom;
          }
        });
        this.$emit('focus', e);
      },

      __onFocusin (e) {
        if (
          this.$el.contains(e.target) === true &&
          (
            e.relatedTarget === null ||
            this.$el.contains(e.relatedTarget) !== true
          )
        ) {
          const prop = `inner${this.isViewingSource === true ? 'Text' : 'HTML'}`;
          this.caret.restorePosition(this.$refs.content[prop].length);
          this.refreshToolbar();
        }
      },

      __onFocusout (e) {
        if (
          this.$el.contains(e.target) === true &&
          (
            e.relatedTarget === null ||
            this.$el.contains(e.relatedTarget) !== true
          )
        ) {
          this.caret.savePosition();
          this.refreshToolbar();
        }
      },

      // mousedown, touchstart
      __onPointerStart (e) {
        this.__offsetBottom = void 0;
        this.qListeners[e.type] !== void 0 && this.$emit(e.type, e);
      },

      __onSelectionchange () {
        this.caret.save();
      },

      runCmd (cmd, param, update = true) {
        this.focus();
        this.caret.restore();
        this.caret.apply(cmd, param, () => {
          this.focus();
          this.caret.save();
          if (this.$q.platform.is.ie === true || this.$q.platform.is.edge === true) {
            this.$nextTick(this.__onInput);
          }
          if (update) {
            this.refreshToolbar();
          }
        });
      },

      refreshToolbar () {
        setTimeout(() => {
          this.editLinkUrl = null;
          this.$forceUpdate();
        }, 1);
      },

      focus () {
        addFocusFn(() => {
          this.$refs.content !== void 0 && this.$refs.content.focus({ preventScroll: true });
        });
      },

      getContentEl () {
        return this.$refs.content
      },

      __setContent (v, restorePosition) {
        if (this.$refs.content !== void 0) {
          if (restorePosition === true) {
            this.caret.savePosition();
          }

          const prop = `inner${this.isViewingSource === true ? 'Text' : 'HTML'}`;
          this.$refs.content[prop] = v;

          if (restorePosition === true) {
            this.caret.restorePosition(this.$refs.content[prop].length);
            this.refreshToolbar();
          }
        }
      }
    },

    created () {
      if (isSSR === false) {
        document.execCommand('defaultParagraphSeparator', false, this.paragraphTag);
        this.defaultFont = window.getComputedStyle(document.body).fontFamily;
      }
    },

    mounted () {
      this.caret = new Caret(this.$refs.content, this);
      this.__setContent(this.value);
      this.refreshToolbar();

      document.addEventListener('selectionchange', this.__onSelectionchange);
    },

    beforeDestroy () {
      document.removeEventListener('selectionchange', this.__onSelectionchange);
    },

    render (h) {
      let toolbars;

      if (this.hasToolbar) {
        const bars = [
          h('div', {
            key: 'qedt_top',
            staticClass: 'q-editor__toolbar row no-wrap scroll-x',
            class: this.toolbarBackgroundClass
          }, getToolbar(h, this))
        ];

        this.editLinkUrl !== null && bars.push(
          h('div', {
            key: 'qedt_btm',
            staticClass: 'q-editor__toolbar row no-wrap items-center scroll-x',
            class: this.toolbarBackgroundClass
          }, getLinkEditor(h, this, this.$q.platform.is.ie))
        );

        toolbars = h('div', {
          key: 'toolbar_ctainer',
          staticClass: 'q-editor__toolbars-container'
        }, bars);
      }

      const on = {
        ...this.qListeners,
        input: this.__onInput,
        keydown: this.__onKeydown,
        click: this.__onClick,
        blur: this.__onBlur,
        focus: this.__onFocus,

        // clean saved scroll position
        mousedown: this.__onPointerStart,
        touchstart: this.__onPointerStart
      };

      return h('div', {
        style: {
          height: this.inFullscreen === true ? '100%' : null
        },
        class: this.classes,
        attrs: this.attrs,
        on: this.onEditor
      }, [
        toolbars,

        h(
          'div',
          {
            ref: 'content',
            staticClass: 'q-editor__content',
            style: this.innerStyle,
            class: this.innerClass,
            attrs: {
              contenteditable: this.editable,
              placeholder: this.placeholder
            },
            domProps: isSSR
              ? { innerHTML: this.value }
              : void 0,
            on
          }
        )
      ])
    }
  });

  var QItemLabel = Vue.extend({
    name: 'QItemLabel',

    mixins: [ ListenersMixin ],

    props: {
      overline: Boolean,
      caption: Boolean,
      header: Boolean,
      lines: [ Number, String ]
    },

    computed: {
      classes () {
        return {
          'q-item__label--overline text-overline': this.overline,
          'q-item__label--caption text-caption': this.caption,
          'q-item__label--header': this.header,
          'ellipsis': parseInt(this.lines, 10) === 1
        }
      },

      style () {
        if (this.lines !== void 0 && parseInt(this.lines, 10) > 1) {
          return {
            overflow: 'hidden',
            display: '-webkit-box',
            '-webkit-box-orient': 'vertical',
            '-webkit-line-clamp': this.lines
          }
        }
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-item__label',
        style: this.style,
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var QSlideTransition = Vue.extend({
    name: 'QSlideTransition',

    props: {
      appear: Boolean,
      duration: {
        type: Number,
        default: 300
      }
    },

    methods: {
      __begin (el, height, done) {
        el.style.overflowY = 'hidden';
        if (height !== void 0) {
          el.style.height = `${height}px`;
        }
        el.style.transition = `height ${this.duration}ms cubic-bezier(.25, .8, .50, 1)`;

        this.animating = true;
        this.done = done;
      },

      __end (el, event) {
        el.style.overflowY = null;
        el.style.height = null;
        el.style.transition = null;
        this.__cleanup();
        event !== this.lastEvent && this.$emit(event);
      },

      __cleanup () {
        this.done && this.done();
        this.done = null;
        this.animating = false;

        clearTimeout(this.timer);
        clearTimeout(this.timerFallback);
        this.el !== void 0 && this.el.removeEventListener('transitionend', this.animListener);
        this.animListener = null;
      }
    },

    beforeDestroy () {
      this.animating && this.__cleanup();
    },

    render (h) {
      return h('transition', {
        props: {
          css: false,
          appear: this.appear
        },
        on: cache(this, 'tr', {
          enter: (el, done) => {
            let pos = 0;
            this.el = el;

            if (this.animating === true) {
              this.__cleanup();
              pos = el.offsetHeight === el.scrollHeight ? 0 : void 0;
            }
            else {
              this.lastEvent = 'hide';
            }

            this.__begin(el, pos, done);

            this.timer = setTimeout(() => {
              el.style.height = `${el.scrollHeight}px`;
              this.animListener = evt => {
                if (Object(evt) !== evt || evt.target === el) {
                  this.__end(el, 'show');
                }
              };
              el.addEventListener('transitionend', this.animListener);
              this.timerFallback = setTimeout(this.animListener, this.duration * 1.1);
            }, 100);
          },

          leave: (el, done) => {
            let pos;
            this.el = el;

            if (this.animating === true) {
              this.__cleanup();
            }
            else {
              this.lastEvent = 'show';
              pos = el.scrollHeight;
            }

            this.__begin(el, pos, done);

            this.timer = setTimeout(() => {
              el.style.height = 0;
              this.animListener = evt => {
                if (Object(evt) !== evt || evt.target === el) {
                  this.__end(el, 'hide');
                }
              };
              el.addEventListener('transitionend', this.animListener);
              this.timerFallback = setTimeout(this.animListener, this.duration * 1.1);
            }, 100);
          }
        })
      }, slot(this, 'default'))
    }
  });

  const insetMap = {
    true: 'inset',
    item: 'item-inset',
    'item-thumbnail': 'item-thumbnail-inset'
  };

  const margins = {
    xs: 2,
    sm: 4,
    md: 8,
    lg: 16,
    xl: 24
  };

  var QSeparator = Vue.extend({
    name: 'QSeparator',

    mixins: [ DarkMixin, ListenersMixin ],

    props: {
      spaced: [ Boolean, String ],
      inset: [ Boolean, String ],
      vertical: Boolean,
      color: String,
      size: String
    },

    computed: {
      orientation () {
        return this.vertical === true
          ? 'vertical'
          : 'horizontal'
      },

      classPrefix () {
        return ` q-separator--${this.orientation}`
      },

      insetClass () {
        return this.inset !== false
          ? `${this.classPrefix}-${insetMap[this.inset]}`
          : ''
      },

      classes () {
        return `q-separator${this.classPrefix}${this.insetClass}` +
          (this.color !== void 0 ? ` bg-${this.color}` : '') +
          (this.isDark === true ? ' q-separator--dark' : '')
      },

      style () {
        const style = {};

        if (this.size !== void 0) {
          style[ this.vertical === true ? 'width' : 'height' ] = this.size;
        }

        if (this.spaced !== false) {
          const size = this.spaced === true
            ? `${margins.md}px`
            : this.spaced in margins ? `${margins[this.spaced]}px` : this.spaced;

          const props = this.vertical === true
            ? [ 'Left', 'Right' ]
            : [ 'Top', 'Bottom' ];

          style[`margin${props[0]}`] = style[`margin${props[1]}`] = size;
        }

        return style
      },

      attrs () {
        return {
          'aria-orientation': this.orientation
        }
      }
    },

    render (h) {
      return h('hr', {
        staticClass: 'q-separator',
        class: this.classes,
        style: this.style,
        attrs: this.attrs,
        on: { ...this.qListeners }
      })
    }
  });

  const eventName = 'q:expansion-item:close';

  var QExpansionItem = Vue.extend({
    name: 'QExpansionItem',

    mixins: [ DarkMixin, RouterLinkMixin, ModelToggleMixin ],

    props: {
      icon: String,

      label: String,
      labelLines: [ Number, String ],

      caption: String,
      captionLines: [ Number, String ],

      dense: Boolean,

      expandIcon: String,
      expandedIcon: String,
      expandIconClass: [ Array, String, Object ],
      duration: Number,

      headerInsetLevel: Number,
      contentInsetLevel: Number,

      expandSeparator: Boolean,
      defaultOpened: Boolean,
      expandIconToggle: Boolean,
      switchToggleSide: Boolean,
      denseToggle: Boolean,
      group: String,
      popup: Boolean,

      headerStyle: [Array, String, Object],
      headerClass: [Array, String, Object]
    },

    data () {
      return {
        showing: this.value !== void 0
          ? this.value
          : this.defaultOpened
      }
    },

    watch: {
      showing (val) {
        val === true && this.group !== void 0 && this.$root.$emit(eventName, this);
      },

      group (newVal, oldVal) {
        if (newVal !== void 0 && oldVal === void 0) {
          this.$root.$on(eventName, this.__eventHandler);
        }
        else if (newVal === void 0 && oldVal !== void 0) {
          this.$root.$off(eventName, this.__eventHandler);
        }
      }
    },

    computed: {
      classes () {
        return `q-expansion-item--${this.showing === true ? 'expanded' : 'collapsed'}` +
          ` q-expansion-item--${this.popup === true ? 'popup' : 'standard'}`
      },

      contentStyle () {
        if (this.contentInsetLevel !== void 0) {
          const dir = this.$q.lang.rtl === true ? 'Right' : 'Left';
          return {
            ['padding' + dir]: (this.contentInsetLevel * 56) + 'px'
          }
        }
      },

      isClickable () {
        return this.hasLink === true || this.expandIconToggle !== true
      },

      expansionIcon () {
        return this.expandedIcon !== void 0 && this.showing === true
          ? this.expandedIcon
          : this.expandIcon || this.$q.iconSet.expansionItem[this.denseToggle === true ? 'denseIcon' : 'icon']
      },

      activeToggleIcon () {
        return this.disable !== true && (this.hasLink === true || this.expandIconToggle === true)
      }
    },

    methods: {
      __onHeaderClick (e) {
        this.hasLink !== true && this.toggle(e);
        this.$emit('click', e);
      },

      __toggleIconKeyboard (e) {
        e.keyCode === 13 && this.__toggleIcon(e, true);
      },

      __toggleIcon (e, keyboard) {
        keyboard !== true && this.$refs.blurTarget !== void 0 && this.$refs.blurTarget.focus();
        this.toggle(e);
        stopAndPrevent(e);
      },

      __eventHandler (comp) {
        this !== comp && this.group === comp.group && this.hide();
      },

      __getToggleIcon (h) {
        const data = {
          staticClass: `q-focusable relative-position cursor-pointer${this.denseToggle === true && this.switchToggleSide === true ? ' items-end' : ''}`,
          class: this.expandIconClass,
          props: {
            side: this.switchToggleSide !== true,
            avatar: this.switchToggleSide
          }
        };

        const child = [
          h(QIcon, {
            staticClass: 'q-expansion-item__toggle-icon',
            class: this.expandedIcon === void 0 && this.showing === true
              ? 'q-expansion-item__toggle-icon--rotated'
              : void 0,
            props: { name: this.expansionIcon }
          })
        ];

        if (this.activeToggleIcon === true) {
          Object.assign(data, {
            attrs: { tabindex: 0 },
            on: cache(this, 'inpExt', {
              click: this.__toggleIcon,
              keyup: this.__toggleIconKeyboard
            })
          });

          child.unshift(
            h('div', {
              ref: 'blurTarget',
              staticClass: 'q-expansion-item__toggle-focus q-icon q-focus-helper q-focus-helper--rounded',
              attrs: { tabindex: -1 }
            })
          );
        }

        return h(QItemSection, data, child)
      },

      __getHeader (h) {
        let child;

        if (this.$scopedSlots.header !== void 0) {
          child = [].concat(this.$scopedSlots.header({ expanded: this.showing === true }));
        }
        else {
          child = [
            h(QItemSection, [
              h(QItemLabel, {
                props: { lines: this.labelLines }
              }, [ this.label || '' ]),

              this.caption
                ? h(QItemLabel, {
                  props: { lines: this.captionLines, caption: true }
                }, [ this.caption ])
                : null
            ])
          ];

          this.icon && child[this.switchToggleSide === true ? 'push' : 'unshift'](
            h(QItemSection, {
              props: {
                side: this.switchToggleSide === true,
                avatar: this.switchToggleSide !== true
              }
            }, [
              h(QIcon, {
                props: { name: this.icon }
              })
            ])
          );
        }

        this.disable !== true && child[this.switchToggleSide === true ? 'unshift' : 'push'](
          this.__getToggleIcon(h)
        );

        const data = {
          ref: 'item',
          style: this.headerStyle,
          class: this.headerClass,
          props: {
            dark: this.isDark,
            disable: this.disable,
            dense: this.dense,
            insetLevel: this.headerInsetLevel
          }
        };

        if (this.isClickable === true) {
          data.props.clickable = true;
          data[this.hasRouterLink === true ? 'nativeOn' : 'on'] = {
            ...this.qListeners,
            click: this.__onHeaderClick
          };

          if (this.hasLink === true) {
            Object.assign(
              data.props,
              this.linkProps.props
            );

            data.attrs = this.linkProps.attrs;
          }
        }

        return h(QItem, data, child)
      },

      __getContent (h) {
        const node = [
          this.__getHeader(h),

          h(QSlideTransition, {
            props: { duration: this.duration },
            on: cache(this, 'slide', {
              show: () => { this.$emit('after-show'); },
              hide: () => { this.$emit('after-hide'); }
            })
          }, [
            h('div', {
              staticClass: 'q-expansion-item__content relative-position',
              style: this.contentStyle,
              directives: [{ name: 'show', value: this.showing }]
            }, slot(this, 'default'))
          ])
        ];

        if (this.expandSeparator) {
          node.push(
            h(QSeparator, {
              staticClass: 'q-expansion-item__border q-expansion-item__border--top absolute-top',
              props: { dark: this.isDark }
            }),
            h(QSeparator, {
              staticClass: 'q-expansion-item__border q-expansion-item__border--bottom absolute-bottom',
              props: { dark: this.isDark }
            })
          );
        }

        return node
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-expansion-item q-item-type',
        class: this.classes
      }, [
        h(
          'div',
          { staticClass: 'q-expansion-item__container relative-position' },
          this.__getContent(h)
        )
      ])
    },

    created () {
      this.group !== void 0 && this.$root.$on(eventName, this.__eventHandler);
    },

    beforeDestroy () {
      this.group !== void 0 && this.$root.$off(eventName, this.__eventHandler);
    }
  });

  const labelPositions = ['top', 'right', 'bottom', 'left'];

  var FabMixin = {
    mixins: [ ListenersMixin ],

    props: {
      type: {
        type: String,
        default: 'a'
      },

      outline: Boolean,
      push: Boolean,
      flat: Boolean,
      unelevated: Boolean,

      color: String,
      textColor: String,
      glossy: Boolean,

      square: Boolean,
      padding: String,

      label: {
        type: [ String, Number ],
        default: ''
      },
      labelPosition: {
        type: String,
        default: 'right',
        validator: v => labelPositions.includes(v)
      },
      externalLabel: Boolean,
      hideLabel: {
        type: Boolean
      },
      labelClass: [ Array, String, Object ],
      labelStyle: [ Array, String, Object ],

      disable: Boolean,

      tabindex: [ Number, String ]
    },

    computed: {
      formClass () {
        return `q-fab--form-${this.square === true ? 'square' : 'rounded'}`
      },

      stacked () {
        return this.externalLabel === false && ['top', 'bottom'].includes(this.labelPosition)
      },

      labelProps () {
        if (this.externalLabel === true) {
          const hideLabel = this.hideLabel === null
            ? this.showing === false
            : this.hideLabel;

          return {
            action: 'push',
            data: {
              staticClass: 'q-fab__label q-tooltip--style q-fab__label--external' +
                ` q-fab__label--external-${this.labelPosition}` +
                (hideLabel === true ? ' q-fab__label--external-hidden' : ''),
              style: this.labelStyle,
              class: this.labelClass
            }
          }
        }

        return {
          action: [ 'left', 'top' ].includes(this.labelPosition)
            ? 'unshift'
            : 'push',
          data: {
            staticClass: `q-fab__label q-fab__label--internal q-fab__label--internal-${this.labelPosition}` +
              (this.hideLabel === true ? ' q-fab__label--internal-hidden' : ''),
            style: this.labelStyle,
            class: this.labelClass
          }
        }
      }
    }
  };

  const directions$1 = ['up', 'right', 'down', 'left'];
  const alignValues$1 = [ 'left', 'center', 'right' ];

  var QFab = Vue.extend({
    name: 'QFab',

    inheritAttrs: false,

    mixins: [ FabMixin, AttrsMixin, ModelToggleMixin ],

    provide () {
      return {
        __qFab: this
      }
    },

    props: {
      icon: String,
      activeIcon: String,

      hideIcon: Boolean,
      hideLabel: {
        default: null
      },

      direction: {
        type: String,
        default: 'right',
        validator: v => directions$1.includes(v)
      },

      persistent: Boolean,

      verticalActionsAlign: {
        type: String,
        default: 'center',
        validator: v => alignValues$1.includes(v)
      }
    },

    data () {
      return {
        showing: this.value === true
      }
    },

    computed: {
      hideOnRouteChange () {
        return this.persistent !== true
      },

      classes () {
        return `q-fab--align-${this.verticalActionsAlign} ${this.formClass}` +
          (this.showing === true ? ' q-fab--opened' : '')
      },

      actionsClasses () {
        return `q-fab__actions--${this.direction}` + (this.showing === true ? ' q-fab__actions--opened' : '')
      },

      iconHolderClasses () {
        return this.showing === true ? 'q-fab__icon-holder--opened' : ''
      },

      attrs () {
        return {
          'aria-expanded': this.showing === true ? 'true' : 'false',
          'aria-haspopup': 'true',
          ...this.qAttrs
        }
      },

      slotScope () {
        return { opened: this.showing }
      }
    },

    methods: {
      __onChildClick (evt) {
        this.hide(evt);

        if (this.$refs.trigger && this.$refs.trigger.$el) {
          this.$refs.trigger.$el.focus();
        }
      },

      __getIcon (h, kebab, camel) {
        const slotFn = this.$scopedSlots[kebab];
        const staticClass = `q-fab__${kebab} absolute-full`;

        return slotFn === void 0
          ? h(QIcon, { staticClass, props: { name: this[camel] || this.$q.iconSet.fab[camel] } })
          : h('div', { staticClass }, slotFn(this.slotScope))
      }
    },

    render (h) {
      const child = [];

      this.hideIcon !== true && child.push(
        h('div', { staticClass: 'q-fab__icon-holder', class: this.iconHolderClasses }, [
          this.__getIcon(h, 'icon', 'icon'),
          this.__getIcon(h, 'active-icon', 'activeIcon')
        ])
      );

      if (this.label !== '' || this.$scopedSlots.label !== void 0) {
        child[this.labelProps.action](
          h('div', this.labelProps.data, this.$scopedSlots.label !== void 0 ? this.$scopedSlots.label(this.slotScope) : [ this.label ])
        );
      }

      return h('div', {
        staticClass: 'q-fab z-fab row inline justify-center',
        class: this.classes,
        on: { ...this.qListeners }
      }, [
        h(QBtn, {
          ref: 'trigger',
          class: this.formClass,
          props: {
            ...this.$props,
            noWrap: true,
            stack: this.stacked,
            align: void 0,
            icon: void 0,
            label: void 0,
            noCaps: true,
            fab: true
          },
          attrs: this.attrs,
          on: cache(this, 'tog', {
            click: this.toggle
          })
        }, mergeSlot(child, this, 'tooltip')),

        h('div', {
          staticClass: 'q-fab__actions flex no-wrap inline',
          class: this.actionsClasses
        }, slot(this, 'default'))
      ])
    }
  });

  const anchorMap = {
    start: 'self-end',
    center: 'self-center',
    end: 'self-start'
  };

  const anchorValues = Object.keys(anchorMap);

  var QFabAction = Vue.extend({
    name: 'QFabAction',

    mixins: [ FabMixin ],

    props: {
      icon: {
        type: String,
        default: ''
      },

      anchor: {
        type: String,
        validator: v => anchorValues.includes(v)
      },

      to: [ String, Object ],
      replace: Boolean
    },

    inject: {
      __qFab: {
        default () {
          return {
            showing: true,
            __onChildClick: noop
          }
        }
      }
    },

    computed: {
      classes () {
        const align = anchorMap[this.anchor];
        return this.formClass + (align !== void 0 ? ` ${align}` : '')
      },

      onEvents () {
        return {
          ...this.qListeners,
          click: this.click
        }
      },

      isDisabled () {
        return this.__qFab.showing !== true || this.disable === true
      }
    },

    methods: {
      click (e) {
        this.__qFab.__onChildClick(e);
        this.$emit('click', e);
      }
    },

    render (h) {
      const child = [];

      if (this.$scopedSlots.icon !== void 0) {
        child.push(this.$scopedSlots.icon());
      }
      else if (this.icon !== '') {
        child.push(
          h(QIcon, {
            props: { name: this.icon }
          })
        );
      }

      if (this.label !== '' || this.$scopedSlots.label !== void 0) {
        child[this.labelProps.action](
          h('div', this.labelProps.data, this.$scopedSlots.label !== void 0 ? this.$scopedSlots.label() : [ this.label ])
        );
      }

      return h(QBtn, {
        class: this.classes,
        props: {
          ...this.$props,
          noWrap: true,
          stack: this.stacked,
          icon: void 0,
          label: void 0,
          noCaps: true,
          fabMini: true,
          disable: this.isDisabled
        },
        on: this.onEvents
      }, mergeSlot(child, this, 'default'))
    }
  });

  const lazyRulesValues = [ true, false, 'ondemand' ];

  var ValidateMixin = {
    props: {
      value: {},

      error: {
        type: Boolean,
        default: null
      },
      errorMessage: String,
      noErrorIcon: Boolean,

      rules: Array,
      reactiveRules: Boolean,
      lazyRules: {
        type: [ Boolean, String ],
        validator: v => lazyRulesValues.includes(v)
      }
    },

    data () {
      return {
        isDirty: null,
        innerError: false,
        innerErrorMessage: void 0
      }
    },

    watch: {
      value () {
        this.__validateIfNeeded();
      },

      disable (val) {
        if (val === true) {
          this.__resetValidation();
        }
        else {
          this.__validateIfNeeded(true);
        }
      },

      reactiveRules: {
        handler (val) {
          if (val === true) {
            if (this.unwatchRules === void 0) {
              this.unwatchRules = this.$watch('rules', () => {
                this.__validateIfNeeded(true);
              });
            }
          }
          else if (this.unwatchRules !== void 0) {
            this.unwatchRules();
            this.unwatchRules = void 0;
          }
        },
        immediate: true
      },

      focused (focused) {
        if (focused === true) {
          if (this.isDirty === null) {
            this.isDirty = false;
          }
        }
        else if (this.isDirty === false) {
          this.isDirty = true;

          if (
            this.hasActiveRules === true &&
            this.lazyRules !== 'ondemand' &&
            // Don't re-trigger if it's already in progress;
            // It might mean that focus switched to submit btn and
            // QForm's submit() has been called already (ENTER key)
            this.innerLoading === false
          ) {
            this.debouncedValidate();
          }
        }
      },

      hasError (invalid) {
        const targetEl = document.getElementById(this.targetUid);
        targetEl !== null && targetEl.setAttribute('aria-invalid', invalid === true);
      }
    },

    computed: {
      hasRules () {
        return this.rules !== void 0 &&
          this.rules !== null &&
          this.rules.length > 0
      },

      hasActiveRules () {
        return this.disable !== true && this.hasRules === true
      },

      hasError () {
        return this.error === true || this.innerError === true
      },

      computedErrorMessage () {
        return typeof this.errorMessage === 'string' && this.errorMessage.length > 0
          ? this.errorMessage
          : this.innerErrorMessage
      }
    },

    created () {
      this.debouncedValidate = debounce(this.validate, 0);
    },

    mounted () {
      this.validateIndex = 0;
    },

    beforeDestroy () {
      this.unwatchRules !== void 0 && this.unwatchRules();
      this.debouncedValidate.cancel();
    },

    methods: {
      resetValidation () {
        this.isDirty = null;
        this.__resetValidation();
      },

      /*
       * Return value
       *   - true (validation succeeded)
       *   - false (validation failed)
       *   - Promise (pending async validation)
       */
      validate (val = this.value) {
        if (this.hasActiveRules !== true) {
          return true
        }

        const index = ++this.validateIndex;

        if (this.innerLoading !== true && this.lazyRules !== true) {
          this.isDirty = true;
        }

        const update = (err, msg) => {
          if (this.innerError !== err) {
            this.innerError = err;
          }

          const m = msg || void 0;

          if (this.innerErrorMessage !== m) {
            this.innerErrorMessage = m;
          }

          if (this.innerLoading !== false) {
            this.innerLoading = false;
          }
        };

        const promises = [];

        for (let i = 0; i < this.rules.length; i++) {
          const rule = this.rules[i];
          let res;

          if (typeof rule === 'function') {
            res = rule(val);
          }
          else if (typeof rule === 'string' && testPattern[rule] !== void 0) {
            res = testPattern[rule](val);
          }

          if (res === false || typeof res === 'string') {
            update(true, res);
            return false
          }
          else if (res !== true && res !== void 0) {
            promises.push(res);
          }
        }

        if (promises.length === 0) {
          update(false);
          return true
        }

        if (this.innerLoading !== true) {
          this.innerLoading = true;
        }

        return Promise.all(promises).then(
          res => {
            if (res === void 0 || Array.isArray(res) === false || res.length === 0) {
              index === this.validateIndex && update(false);
              return true
            }

            const msg = res.find(r => r === false || typeof r === 'string');
            index === this.validateIndex && update(msg !== void 0, msg);
            return msg === void 0
          },
          e => {
            if (index === this.validateIndex) {
              console.error(e);
              update(true);
            }

            return false
          }
        )
      },

      __resetValidation () {
        this.debouncedValidate.cancel();
        this.validateIndex++;
        this.innerLoading = false;
        this.innerError = false;
        this.innerErrorMessage = void 0;
      },

      __validateIfNeeded (changedRules) {
        if (
          this.hasActiveRules === true &&
          this.lazyRules !== 'ondemand' &&
          (this.isDirty === true || (this.lazyRules !== true && changedRules !== true))
        ) {
          this.debouncedValidate();
        }
      }
    }
  };

  /**
   * Based on the work of https://github.com/jchook/uuid-random
   */

  let
    buf,
    bufIdx = 0;
  const hexBytes = new Array(256);

  // Pre-calculate toString(16) for speed
  for (let i = 0; i < 256; i++) {
    hexBytes[i] = (i + 0x100).toString(16).substr(1);
  }

  // Use best available PRNG
  const randomBytes = (() => {
    // Node & Browser support
    const lib = typeof crypto !== 'undefined'
      ? crypto
      : (
        typeof window !== 'undefined'
          ? window.msCrypto // IE11
          : void 0
      );

    if (lib !== void 0) {
      if (lib.randomBytes !== void 0) {
        return lib.randomBytes
      }
      if (lib.getRandomValues !== void 0) {
        return n => {
          var bytes = new Uint8Array(n);
          lib.getRandomValues(bytes);
          return bytes
        }
      }
    }

    return n => {
      const r = [];
      for (let i = n; i > 0; i--) {
        r.push(Math.floor(Math.random() * 256));
      }
      return r
    }
  })();

  // Buffer random numbers for speed
  // Reduce memory usage by decreasing this number (min 16)
  // or improve speed by increasing this number (try 16384)
  const BUFFER_SIZE = 4096;

  function uid$2 () {
    // Buffer some random bytes for speed
    if (buf === void 0 || (bufIdx + 16 > BUFFER_SIZE)) {
      bufIdx = 0;
      buf = randomBytes(BUFFER_SIZE);
    }

    const b = Array.prototype.slice.call(buf, bufIdx, (bufIdx += 16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;

    return hexBytes[b[0]] + hexBytes[b[1]] +
      hexBytes[b[2]] + hexBytes[b[3]] + '-' +
      hexBytes[b[4]] + hexBytes[b[5]] + '-' +
      hexBytes[b[6]] + hexBytes[b[7]] + '-' +
      hexBytes[b[8]] + hexBytes[b[9]] + '-' +
      hexBytes[b[10]] + hexBytes[b[11]] +
      hexBytes[b[12]] + hexBytes[b[13]] +
      hexBytes[b[14]] + hexBytes[b[15]]
  }

  function getTargetUid (val) {
    return val === void 0 ? `f_${uid$2()}` : val
  }

  var QField = Vue.extend({
    name: 'QField',

    mixins: [ DarkMixin, ValidateMixin, AttrsMixin ],

    inheritAttrs: false,

    props: {
      label: String,
      stackLabel: Boolean,
      hint: String,
      hideHint: Boolean,
      prefix: String,
      suffix: String,

      labelColor: String,
      color: String,
      bgColor: String,

      filled: Boolean,
      outlined: Boolean,
      borderless: Boolean,
      standout: [Boolean, String],

      square: Boolean,

      loading: Boolean,

      labelSlot: Boolean,

      bottomSlots: Boolean,
      hideBottomSpace: Boolean,

      rounded: Boolean,
      dense: Boolean,
      itemAligned: Boolean,

      counter: Boolean,

      clearable: Boolean,
      clearIcon: String,

      disable: Boolean,
      readonly: Boolean,

      autofocus: Boolean,

      for: String,

      maxlength: [Number, String],
      maxValues: [Number, String] // private, do not add to JSON; internally needed by QSelect
    },

    data () {
      return {
        focused: false,
        targetUid: getTargetUid(this.for),

        // used internally by validation for QInput
        // or menu handling for QSelect
        innerLoading: false
      }
    },

    watch: {
      for (val) {
        // don't transform targetUid into a computed
        // prop as it will break SSR
        this.targetUid = getTargetUid(val);
      }
    },

    computed: {
      editable () {
        return this.disable !== true && this.readonly !== true
      },

      hasValue () {
        const value = this.__getControl === void 0 ? this.value : this.innerValue;

        return value !== void 0 &&
          value !== null &&
          ('' + value).length > 0
      },

      computedCounter () {
        if (this.counter !== false) {
          const len = typeof this.value === 'string' || typeof this.value === 'number'
            ? ('' + this.value).length
            : (Array.isArray(this.value) === true ? this.value.length : 0);

          const max = this.maxlength !== void 0
            ? this.maxlength
            : this.maxValues;

          return len + (max !== void 0 ? ' / ' + max : '')
        }
      },

      floatingLabel () {
        return this.stackLabel === true ||
          this.focused === true ||
          typeof this.inputValue === 'number' ||
          (typeof this.inputValue === 'string' && this.inputValue.length > 0) ||
          (this.hideSelected !== true && this.hasValue === true) ||
          (
            this.displayValue !== void 0 &&
            this.displayValue !== null &&
            ('' + this.displayValue).length > 0
          )
      },

      shouldRenderBottom () {
        return this.bottomSlots === true ||
          this.hint !== void 0 ||
          this.hasRules === true ||
          this.counter === true ||
          this.error !== null
      },

      classes () {
        return {
          [this.fieldClass]: this.fieldClass !== void 0,

          [`q-field--${this.styleType}`]: true,
          'q-field--rounded': this.rounded,
          'q-field--square': this.square,

          'q-field--focused': this.focused === true,
          'q-field--highlighted': this.focused === true || this.hasError === true,
          'q-field--float': this.floatingLabel,
          'q-field--labeled': this.hasLabel,

          'q-field--dense': this.dense,
          'q-field--item-aligned q-item-type': this.itemAligned,
          'q-field--dark': this.isDark,

          'q-field--auto-height': this.__getControl === void 0,

          'q-field--with-bottom': this.hideBottomSpace !== true && this.shouldRenderBottom === true,
          'q-field--error': this.hasError,

          'q-field--readonly': this.readonly === true && this.disable !== true,
          'q-field--disabled': this.disable === true
        }
      },

      styleType () {
        if (this.filled === true) { return 'filled' }
        if (this.outlined === true) { return 'outlined' }
        if (this.borderless === true) { return 'borderless' }
        if (this.standout) { return 'standout' }
        return 'standard'
      },

      contentClass () {
        const cls = [];

        if (this.hasError === true) {
          cls.push('text-negative');
        }
        else if (typeof this.standout === 'string' && this.standout.length > 0 && this.focused === true) {
          return this.standout
        }
        else if (this.color !== void 0) {
          cls.push('text-' + this.color);
        }

        if (this.bgColor !== void 0) {
          cls.push(`bg-${this.bgColor}`);
        }

        return cls
      },

      hasLabel () {
        return this.labelSlot === true || this.label !== void 0
      },

      labelClass () {
        if (
          this.labelColor !== void 0 &&
          this.hasError !== true
        ) {
          return 'text-' + this.labelColor
        }
      },

      controlSlotScope () {
        return {
          id: this.targetUid,
          field: this.$el,
          editable: this.editable,
          focused: this.focused,
          floatingLabel: this.floatingLabel,
          value: this.value,
          emitValue: this.__emitValue
        }
      },

      bottomSlotScope () {
        return {
          id: this.targetUid,
          field: this.$el,
          editable: this.editable,
          focused: this.focused,
          value: this.value,
          errorMessage: this.computedErrorMessage
        }
      },

      attrs () {
        const attrs = {
          for: this.targetUid
        };

        if (this.disable === true) {
          attrs['aria-disabled'] = 'true';
        }
        else if (this.readonly === true) {
          attrs['aria-readonly'] = 'true';
        }

        return attrs
      }
    },

    methods: {
      focus () {
        addFocusFn(this.__focus);
      },

      blur () {
        removeFocusFn(this.__focus);
        const el = document.activeElement;
        // IE can have null document.activeElement
        if (el !== null && this.$el.contains(el)) {
          el.blur();
        }
      },

      __focus () {
        const el = document.activeElement;
        let target = this.$refs.target;
        // IE can have null document.activeElement
        if (target !== void 0 && (el === null || el.id !== this.targetUid)) {
          target.hasAttribute('tabindex') === true || (target = target.querySelector('[tabindex]'));
          target !== null && target !== el && target.focus({ preventScroll: true });
        }
      },

      __getContent (h) {
        const node = [];

        this.$scopedSlots.prepend !== void 0 && node.push(
          h('div', {
            staticClass: 'q-field__prepend q-field__marginal row no-wrap items-center',
            key: 'prepend',
            on: this.slotsEvents
          }, this.$scopedSlots.prepend())
        );

        node.push(
          h('div', {
            staticClass: 'q-field__control-container col relative-position row no-wrap q-anchor--skip'
          }, this.__getControlContainer(h))
        );

        this.hasError === true && this.noErrorIcon === false && node.push(
          this.__getInnerAppendNode(h, 'error', [
            h(QIcon, { props: { name: this.$q.iconSet.field.error, color: 'negative' } })
          ])
        );

        if (this.loading === true || this.innerLoading === true) {
          node.push(
            this.__getInnerAppendNode(
              h,
              'inner-loading-append',
              this.$scopedSlots.loading !== void 0
                ? this.$scopedSlots.loading()
                : [ h(QSpinner, { props: { color: this.color } }) ]
            )
          );
        }
        else if (this.clearable === true && this.hasValue === true && this.editable === true) {
          node.push(
            this.__getInnerAppendNode(h, 'inner-clearable-append', [
              h(QIcon, {
                staticClass: 'q-field__focusable-action',
                props: { tag: 'button', name: this.clearIcon || this.$q.iconSet.field.clear },
                attrs: iconAsButton,
                on: this.clearableEvents
              })
            ])
          );
        }

        this.$scopedSlots.append !== void 0 && node.push(
          h('div', {
            staticClass: 'q-field__append q-field__marginal row no-wrap items-center',
            key: 'append',
            on: this.slotsEvents
          }, this.$scopedSlots.append())
        );

        this.__getInnerAppend !== void 0 && node.push(
          this.__getInnerAppendNode(h, 'inner-append', this.__getInnerAppend(h))
        );

        this.__getControlChild !== void 0 && node.push(
          this.__getControlChild(h)
        );

        return node
      },

      __getControlContainer (h) {
        const node = [];

        this.prefix !== void 0 && this.prefix !== null && node.push(
          h('div', {
            staticClass: 'q-field__prefix no-pointer-events row items-center'
          }, [ this.prefix ])
        );

        if (this.hasShadow === true && this.__getShadowControl !== void 0) {
          node.push(
            this.__getShadowControl(h)
          );
        }

        if (this.__getControl !== void 0) {
          node.push(this.__getControl(h));
        }
        // internal usage only:
        else if (this.$scopedSlots.rawControl !== void 0) {
          node.push(this.$scopedSlots.rawControl());
        }
        else if (this.$scopedSlots.control !== void 0) {
          node.push(
            h('div', {
              ref: 'target',
              staticClass: 'q-field__native row',
              attrs: {
                tabindex: -1,
                ...this.qAttrs,
                'data-autofocus': this.autofocus || void 0
              }
            }, this.$scopedSlots.control(this.controlSlotScope))
          );
        }

        this.hasLabel === true && node.push(
          h('div', {
            staticClass: 'q-field__label no-pointer-events absolute ellipsis',
            class: this.labelClass
          }, [ slot(this, 'label', this.label) ])
        );

        this.suffix !== void 0 && this.suffix !== null && node.push(
          h('div', {
            staticClass: 'q-field__suffix no-pointer-events row items-center'
          }, [ this.suffix ])
        );

        return node.concat(
          this.__getDefaultSlot !== void 0
            ? this.__getDefaultSlot(h)
            : slot(this, 'default')
        )
      },

      __getBottom (h) {
        let msg, key;

        if (this.hasError === true) {
          key = 'q--slot-error';

          if (this.$scopedSlots.error !== void 0) {
            msg = this.$scopedSlots.error(this.bottomSlotScope);
          }
          else if (this.computedErrorMessage !== void 0) {
            msg = [ h('div', { attrs: { role: 'alert' } }, [ this.computedErrorMessage ]) ];
            key = this.computedErrorMessage;
          }
        }
        else if (this.hideHint !== true || this.focused === true) {
          key = 'q--slot-hint';

          if (this.$scopedSlots.hint !== void 0) {
            msg = this.$scopedSlots.hint(this.bottomSlotScope);
          }
          else if (this.hint !== void 0) {
            msg = [ h('div', [ this.hint ]) ];
            key = this.hint;
          }
        }

        const hasCounter = this.counter === true || this.$scopedSlots.counter !== void 0;

        if (this.hideBottomSpace === true && hasCounter === false && msg === void 0) {
          return
        }

        const main = h('div', {
          key,
          staticClass: 'q-field__messages col'
        }, msg);

        return h('div', {
          staticClass: 'q-field__bottom row items-start q-field__bottom--' +
            (this.hideBottomSpace !== true ? 'animated' : 'stale')
        }, [
          this.hideBottomSpace === true
            ? main
            : h('transition', { props: { name: 'q-transition--field-message' } }, [
              main
            ]),

          hasCounter === true
            ? h('div', {
              staticClass: 'q-field__counter'
            }, this.$scopedSlots.counter !== void 0 ? this.$scopedSlots.counter() : [ this.computedCounter ])
            : null
        ])
      },

      __getInnerAppendNode (h, key, content) {
        return content === null ? null : h('div', {
          staticClass: 'q-field__append q-field__marginal row no-wrap items-center q-anchor--skip',
          key
        }, content)
      },

      __onControlPopupShow (e) {
        e !== void 0 && stop(e);
        this.$emit('popup-show', e);
        this.hasPopupOpen = true;
        this.__onControlFocusin(e);
      },

      __onControlPopupHide (e) {
        e !== void 0 && stop(e);
        this.$emit('popup-hide', e);
        this.hasPopupOpen = false;
        this.__onControlFocusout(e);
      },

      __onControlFocusin (e) {
        clearTimeout(this.focusoutTimer);
        if (this.editable === true && this.focused === false) {
          this.focused = true;
          this.$emit('focus', e);
        }
      },

      __onControlFocusout (e, then) {
        clearTimeout(this.focusoutTimer);
        this.focusoutTimer = setTimeout(() => {
          if (
            document.hasFocus() === true && (
              this.hasPopupOpen === true ||
              this.$refs === void 0 ||
              this.$refs.control === void 0 ||
              this.$refs.control.contains(document.activeElement) !== false
            )
          ) {
            return
          }

          if (this.focused === true) {
            this.focused = false;
            this.$emit('blur', e);
          }

          then !== void 0 && then();
        });
      },

      __clearValue (e) {
        // prevent activating the field but keep focus on desktop
        stopAndPrevent(e);

        if (this.$q.platform.is.mobile !== true) {
          const el = this.$refs.target || this.$el;
          el.focus();
        }
        else if (this.$el.contains(document.activeElement) === true) {
          document.activeElement.blur();
        }

        if (this.type === 'file') {
          // do not let focus be triggered
          // as it will make the native file dialog
          // appear for another selection
          this.$refs.input.value = null;
        }

        this.$emit('input', null);
        this.$emit('clear', this.value);

        this.$nextTick(() => {
          this.resetValidation();

          if (this.$q.platform.is.mobile !== true) {
            this.isDirty = false;
          }
        });
      },

      __emitValue (value) {
        this.$emit('input', value);
      }
    },

    render (h) {
      this.__onPreRender !== void 0 && this.__onPreRender();
      this.__onPostRender !== void 0 && this.$nextTick(this.__onPostRender);

      const attrs = this.__getControl === void 0 && this.$scopedSlots.control === void 0
        ? {
          ...this.qAttrs,
          'data-autofocus': this.autofocus || void 0,
          ...this.attrs
        }
        : this.attrs;

      return h('label', {
        staticClass: 'q-field q-validation-component row no-wrap items-start',
        class: this.classes,
        attrs
      }, [
        this.$scopedSlots.before !== void 0 ? h('div', {
          staticClass: 'q-field__before q-field__marginal row no-wrap items-center',
          on: this.slotsEvents
        }, this.$scopedSlots.before()) : null,

        h('div', {
          staticClass: 'q-field__inner relative-position col self-stretch'
        }, [
          h('div', {
            ref: 'control',
            staticClass: 'q-field__control relative-position row no-wrap',
            class: this.contentClass,
            attrs: { tabindex: -1 },
            on: this.controlEvents
          }, this.__getContent(h)),

          this.shouldRenderBottom === true
            ? this.__getBottom(h)
            : null
        ]),

        this.$scopedSlots.after !== void 0 ? h('div', {
          staticClass: 'q-field__after q-field__marginal row no-wrap items-center',
          on: this.slotsEvents
        }, this.$scopedSlots.after()) : null
      ])
    },

    created () {
      this.__onPreRender !== void 0 && this.__onPreRender();

      this.slotsEvents = { click: prevent };

      this.clearableEvents = { click: this.__clearValue };

      this.controlEvents = this.__getControlEvents !== void 0
        ? this.__getControlEvents()
        : {
          focusin: this.__onControlFocusin,
          focusout: this.__onControlFocusout,
          'popup-show': this.__onControlPopupShow,
          'popup-hide': this.__onControlPopupHide
        };
    },

    mounted () {
      if (fromSSR === true && this.for === void 0) {
        this.targetUid = getTargetUid();
      }

      this.autofocus === true && this.focus();
    },

    activated () {
      if (this.shouldActivate !== true) { return }
      this.autofocus === true && this.focus();
    },

    deactivated () {
      this.shouldActivate = true;
    },

    beforeDestroy () {
      clearTimeout(this.focusoutTimer);
    }
  });

  function filterFiles (files, rejectedFiles, failedPropValidation, filterFn) {
    const acceptedFiles = [];

    files.forEach(file => {
      if (filterFn(file) === true) {
        acceptedFiles.push(file);
      }
      else {
        rejectedFiles.push({ failedPropValidation, file });
      }
    });

    return acceptedFiles
  }

  function stopAndPreventDrag (e) {
    e && e.dataTransfer && (e.dataTransfer.dropEffect = 'copy');
    stopAndPrevent(e);
  }

  var FileMixin = {
    props: {
      multiple: Boolean,
      accept: String,
      capture: String,
      maxFileSize: [ Number, String ],
      maxTotalSize: [ Number, String ],
      maxFiles: [ Number, String ],
      filter: Function
    },

    computed: {
      extensions () {
        if (this.accept !== void 0) {
          return this.accept.split(',').map(ext => {
            ext = ext.trim();
            if (ext === '*') { // support "*"
              return '*/'
            }
            else if (ext.endsWith('/*')) { // support "image/*" or "*/*"
              ext = ext.slice(0, ext.length - 1);
            }
            return ext.toUpperCase()
          })
        }
      },

      maxFilesNumber () {
        return parseInt(this.maxFiles, 10)
      },

      maxTotalSizeNumber () {
        return parseInt(this.maxTotalSize, 10)
      }
    },

    methods: {
      pickFiles (ev) {
        if (this.editable === true) {
          if (ev !== Object(ev)) {
            ev = { target: null };
          }

          if (ev.target !== null && ev.target.matches('input[type="file"]') === true) {
            // stop propagation if it's not a real pointer event
            ev.clientX === 0 && ev.clientY === 0 && stop(ev);
          }
          else {
            const input = this.__getFileInput();
            input && input !== ev.target && input.click(ev);
          }
        }
      },

      addFiles (files) {
        if (this.editable && files) {
          this.__addFiles(null, files);
        }
      },

      __processFiles (e, filesToProcess, currentFileList, append) {
        let files = Array.from(filesToProcess || e.target.files);
        const rejectedFiles = [];

        const done = () => {
          if (rejectedFiles.length > 0) {
            this.$emit('rejected', rejectedFiles);
          }
        };

        // filter file types
        if (this.accept !== void 0 && this.extensions.indexOf('*/') === -1) {
          files = filterFiles(files, rejectedFiles, 'accept', file => {
            return this.extensions.some(ext => (
              file.type.toUpperCase().startsWith(ext) ||
              file.name.toUpperCase().endsWith(ext)
            ))
          });

          if (files.length === 0) { return done() }
        }

        // filter max file size
        if (this.maxFileSize !== void 0) {
          const maxFileSize = parseInt(this.maxFileSize, 10);
          files = filterFiles(files, rejectedFiles, 'max-file-size', file => {
            return file.size <= maxFileSize
          });

          if (files.length === 0) { return done() }
        }

        // Cordova/iOS allows selecting multiple files even when the
        // multiple attribute is not specified. We also normalize drag'n'dropped
        // files here:
        if (this.multiple !== true && files.length > 0) {
          files = [ files[0] ];
        }

        files.forEach(file => {
          file.__key = file.webkitRelativePath + file.lastModified + file.name + file.size;
        });

        // Avoid duplicate files
        const filenameMap = currentFileList.map(entry => entry.__key);
        files = filterFiles(files, rejectedFiles, 'duplicate', file => {
          return filenameMap.includes(file.__key) === false
        });

        if (files.length === 0) { return done() }

        if (this.maxTotalSize !== void 0) {
          let size = append === true
            ? currentFileList.reduce((total, file) => total + file.size, 0)
            : 0;

          files = filterFiles(files, rejectedFiles, 'max-total-size', file => {
            size += file.size;
            return size <= this.maxTotalSizeNumber
          });

          if (files.length === 0) { return done() }
        }

        // do we have custom filter function?
        if (typeof this.filter === 'function') {
          const filteredFiles = this.filter(files);
          files = filterFiles(files, rejectedFiles, 'filter', file => {
            return filteredFiles.includes(file)
          });
        }

        if (this.maxFiles !== void 0) {
          let filesNumber = append === true
            ? currentFileList.length
            : 0;

          files = filterFiles(files, rejectedFiles, 'max-files', () => {
            filesNumber++;
            return filesNumber <= this.maxFilesNumber
          });

          if (files.length === 0) { return done() }
        }

        done();

        if (files.length > 0) {
          return files
        }
      },

      __onDragOver (e) {
        stopAndPreventDrag(e);
        this.dnd !== true && (this.dnd = true);
      },

      __onDragLeave (e) {
        stopAndPrevent(e);
        e.relatedTarget !== this.$refs.dnd && (this.dnd = false);
      },

      __onDrop (e) {
        stopAndPreventDrag(e);
        const files = e.dataTransfer.files;

        if (files.length > 0) {
          this.__addFiles(null, files);
        }

        this.dnd = false;
      },

      __getDnd (h, type) {
        if (this.dnd === true) {
          return h('div', {
            staticClass: `q-${type}__dnd absolute-full`,
            ref: 'dnd',
            on: cache(this, 'dnd', {
              dragenter: stopAndPreventDrag,
              dragover: stopAndPreventDrag,
              dragleave: this.__onDragLeave,
              drop: this.__onDrop
            })
          })
        }
      }
    }
  };

  const FileValueMixin = {
    computed: {
      formDomProps () {
        if (this.type !== 'file') {
          return
        }

        try {
          const dt = 'DataTransfer' in window
            ? new DataTransfer()
            : ('ClipboardEvent' in window
              ? new ClipboardEvent('').clipboardData
              : void 0
            );

          if (Object(this.value) === this.value) {
            ('length' in this.value
              ? Array.from(this.value)
              : [ this.value ]
            ).forEach(file => {
              dt.items.add(file);
            });
          }

          return {
            files: dt.files
          }
        }
        catch (e) {
          return {
            files: void 0
          }
        }
      }
    }
  };

  var QFile = Vue.extend({
    name: 'QFile',

    mixins: [ QField, FileMixin, FormFieldMixin, FileValueMixin ],

    props: {
      /* SSR does not know about File & FileList */
      value: isSSR === true
        ? {}
        : [ File, FileList, Array ],

      append: Boolean,
      useChips: Boolean,
      displayValue: [ String, Number ],

      tabindex: {
        type: [ String, Number ],
        default: 0
      },

      counterLabel: Function,

      inputClass: [ Array, String, Object ],
      inputStyle: [ Array, String, Object ]
    },

    data () {
      return {
        dnd: false
      }
    },

    computed: {
      innerValue () {
        return Object(this.value) === this.value
          ? ('length' in this.value ? Array.from(this.value) : [ this.value ])
          : []
      },

      selectedString () {
        return this.innerValue
          .map(file => file.name)
          .join(', ')
      },

      totalSize () {
        return humanStorageSize(
          this.innerValue.reduce((acc, file) => acc + file.size, 0)
        )
      },

      counterProps () {
        return {
          totalSize: this.totalSize,
          filesNumber: this.innerValue.length,
          maxFiles: this.maxFiles
        }
      },

      computedCounter () {
        if (this.counterLabel !== void 0) {
          return this.counterLabel(this.counterProps)
        }

        const max = this.maxFiles;
        return `${this.innerValue.length}${max !== void 0 ? ' / ' + max : ''} (${this.totalSize})`
      },

      inputAttrs () {
        return {
          tabindex: -1,
          type: 'file',
          title: '', // try to remove default tooltip,
          accept: this.accept,
          capture: this.capture,
          name: this.nameProp,
          ...this.qAttrs,
          id: this.targetUid,
          disabled: this.editable !== true
        }
      },

      isAppending () {
        return this.multiple === true && this.append === true
      },

      fieldClass () {
        return 'q-file q-field--auto-height' + (this.dnd === true ? ' q-file--dnd' : '')
      }
    },

    methods: {
      removeAtIndex (index) {
        const files = this.innerValue.slice();
        files.splice(index, 1);
        this.__emitValue(files);
      },

      removeFile (file) {
        const index = this.innerValue.findIndex(file);
        if (index > -1) {
          this.removeAtIndex(index);
        }
      },

      __emitValue (files) {
        this.$emit('input', this.multiple === true ? files : files[0]);
      },

      __onKeydown (e) {
        // prevent form submit if ENTER is pressed
        e.keyCode === 13 && prevent(e);
      },

      __onKeyup (e) {
        // only on ENTER and SPACE to match native input field
        if (e.keyCode === 13 || e.keyCode === 32) {
          this.pickFiles(e);
        }
      },

      __getFileInput () {
        return this.$refs.input
      },

      __addFiles (e, fileList) {
        const files = this.__processFiles(e, fileList, this.innerValue, this.isAppending);
        const fileInput = this.__getFileInput();

        if (fileInput !== void 0) {
          fileInput.value = '';
        }

        // if nothing to do...
        if (files === void 0) { return }

        // protect against input @change being called in a loop
        // like it happens on Safari, so don't emit same thing:
        if (
          this.multiple === true
            ? this.value && files.every(f => this.innerValue.includes(f))
            : this.value === files[ 0 ]
        ) {
          return
        }

        this.__emitValue(
          this.isAppending === true
            ? this.innerValue.concat(files)
            : files
        );
      },

      __getControl (h) {
        const data = {
          ref: 'target',
          staticClass: 'q-field__native row items-center cursor-pointer',
          attrs: {
            tabindex: this.tabindex
          }
        };

        if (this.editable === true) {
          data.on = cache(this, 'native', {
            dragover: this.__onDragOver,
            dragleave: this.__onDragLeave,
            keydown: this.__onKeydown,
            keyup: this.__onKeyup
          });
        }

        return h('div', data, [ this.__getInput(h) ].concat(this.__getSelection(h)))
      },

      __getControlChild (h) {
        return this.__getDnd(h, 'file')
      },

      __getFiller (h) {
        return [
          h('input', {
            class: [ this.inputClass, 'q-file__filler' ],
            style: this.inputStyle
          })
        ]
      },

      __getSelection (h) {
        if (this.$scopedSlots.file !== void 0) {
          return this.innerValue.length === 0
            ? this.__getFiller(h)
            : this.innerValue.map((file, index) => this.$scopedSlots.file({ index, file, ref: this }))
        }

        if (this.$scopedSlots.selected !== void 0) {
          return this.innerValue.length === 0
            ? this.__getFiller(h)
            : this.$scopedSlots.selected({ files: this.innerValue, ref: this })
        }

        if (this.useChips === true) {
          return this.innerValue.length === 0
            ? this.__getFiller(h)
            : this.innerValue.map((file, i) => h(QChip, {
              key: 'file-' + i,
              props: {
                removable: this.editable,
                dense: true,
                textColor: this.color,
                tabindex: this.tabindex
              },
              on: cache(this, 'rem#' + i, {
                remove: () => { this.removeAtIndex(i); }
              })
            }, [
              h('span', {
                staticClass: 'ellipsis',
                domProps: {
                  textContent: file.name
                }
              })
            ]))
        }

        const textContent = this.displayValue !== void 0
          ? this.displayValue
          : this.selectedString;

        return textContent.length > 0
          ? [
            h('div', {
              style: this.inputStyle,
              class: this.inputClass,
              domProps: { textContent }
            })
          ]
          : this.__getFiller(h)
      },

      __getInput (h) {
        const data = {
          ref: 'input',
          staticClass: 'q-field__input fit absolute-full cursor-pointer',
          attrs: this.inputAttrs,
          domProps: this.formDomProps,
          on: cache(this, 'input', {
            change: this.__addFiles
          })
        };

        if (this.multiple === true) {
          data.attrs.multiple = true;
        }

        return h('input', data)
      }
    },

    created () {
      // necessary for QField's clearable
      // and FileValueMixin
      this.type = 'file';
    }
  });

  var QFooter = Vue.extend({
    name: 'QFooter',

    mixins: [ ListenersMixin ],

    inject: {
      layout: {
        default () {
          console.error('QFooter needs to be child of QLayout');
        }
      }
    },

    props: {
      value: {
        type: Boolean,
        default: true
      },
      reveal: Boolean,
      bordered: Boolean,
      elevated: Boolean,

      heightHint: {
        type: [String, Number],
        default: 50
      }
    },

    data () {
      return {
        size: parseInt(this.heightHint, 10),
        revealed: true,
        windowHeight: onSSR || this.layout.container ? 0 : window.innerHeight
      }
    },

    watch: {
      value (val) {
        this.__update('space', val);
        this.__updateLocal('revealed', true);
        this.layout.__animate();
      },

      offset (val) {
        this.__update('offset', val);
      },

      reveal (val) {
        val === false && this.__updateLocal('revealed', this.value);
      },

      revealed (val) {
        this.layout.__animate();
        this.$emit('reveal', val);
      },

      'layout.scroll' () {
        this.__updateRevealed();
      },

      'layout.height' () {
        this.__updateRevealed();
      },

      size () {
        this.__updateRevealed();
      },

      '$q.screen.height' (val) {
        this.layout.container !== true && this.__updateLocal('windowHeight', val);
      }
    },

    computed: {
      fixed () {
        return this.reveal === true ||
          this.layout.view.indexOf('F') > -1 ||
          (this.$q.platform.is.ios && this.layout.container === true)
      },

      containerHeight () {
        return this.layout.container === true
          ? this.layout.containerHeight
          : this.windowHeight
      },

      offset () {
        if (this.value !== true) {
          return 0
        }
        if (this.fixed === true) {
          return this.revealed === true ? this.size : 0
        }
        const offset = this.layout.scroll.position + this.containerHeight + this.size - this.layout.height;
        return offset > 0 ? offset : 0
      },

      hidden () {
        return this.value !== true || (this.fixed === true && this.revealed !== true)
      },

      revealOnFocus () {
        return this.value === true && this.hidden === true && this.reveal === true
      },

      classes () {
        return (this.fixed === true ? 'fixed' : 'absolute') + '-bottom' +
          (this.bordered === true ? ' q-footer--bordered' : '') +
          (this.hidden === true ? ' q-footer--hidden' : '') +
          (this.value !== true ? ' q-layout--prevent-focus' : '') +
          (this.value !== true && this.fixed !== true ? ' hidden' : '')
      },

      style () {
        const
          view = this.layout.rows.bottom,
          css = {};

        if (view[0] === 'l' && this.layout.left.space === true) {
          css[this.$q.lang.rtl === true ? 'right' : 'left'] = `${this.layout.left.size}px`;
        }
        if (view[2] === 'r' && this.layout.right.space === true) {
          css[this.$q.lang.rtl === true ? 'left' : 'right'] = `${this.layout.right.size}px`;
        }

        return css
      },

      onEvents () {
        return {
          ...this.qListeners,
          focusin: this.__onFocusin,
          input: stop
        }
      }
    },

    render (h) {
      const child = mergeSlot([
        h(QResizeObserver, {
          props: { debounce: 0 },
          on: cache(this, 'resize', { resize: this.__onResize })
        })
      ], this, 'default');

      this.elevated === true && child.push(
        h('div', {
          staticClass: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'
        })
      );

      return h('footer', {
        staticClass: 'q-footer q-layout__section--marginal',
        class: this.classes,
        style: this.style,
        on: this.onEvents
      }, child)
    },

    created () {
      this.layout.instances.footer = this;
      this.value === true && this.__update('size', this.size);
      this.__update('space', this.value);
      this.__update('offset', this.offset);
    },

    beforeDestroy () {
      if (this.layout.instances.footer === this) {
        this.layout.instances.footer = void 0;
        this.__update('size', 0);
        this.__update('offset', 0);
        this.__update('space', false);
      }
    },

    methods: {
      __onResize ({ height }) {
        this.__updateLocal('size', height);
        this.__update('size', height);
      },

      __update (prop, val) {
        if (this.layout.footer[prop] !== val) {
          this.layout.footer[prop] = val;
        }
      },

      __updateLocal (prop, val) {
        if (this[prop] !== val) {
          this[prop] = val;
        }
      },

      __updateRevealed () {
        if (this.reveal !== true) { return }

        const { direction, position, inflexionPosition } = this.layout.scroll;

        this.__updateLocal('revealed', (
          direction === 'up' ||
          position - inflexionPosition < 100 ||
          this.layout.height - this.containerHeight - position - this.size < 300
        ));
      },

      __onFocusin (evt) {
        if (this.revealOnFocus === true) {
          this.__updateLocal('revealed', true);
        }

        this.$emit('focusin', evt);
      }
    }
  });

  var QForm = Vue.extend({
    name: 'QForm',

    mixins: [ ListenersMixin ],

    props: {
      autofocus: Boolean,
      noErrorFocus: Boolean,
      noResetFocus: Boolean,
      greedy: Boolean
    },

    computed: {
      onEvents () {
        return {
          ...this.qListeners,
          submit: this.submit,
          reset: this.reset
        }
      }
    },

    mounted () {
      this.validateIndex = 0;
      this.autofocus === true && this.focus();
    },

    activated () {
      if (this.shouldActivate !== true) { return }
      this.autofocus === true && this.focus();
    },

    deactivated () {
      this.shouldActivate = true;
    },

    methods: {
      validate (shouldFocus) {
        const promises = [];
        const focus = typeof shouldFocus === 'boolean'
          ? shouldFocus
          : this.noErrorFocus !== true;

        const index = ++this.validateIndex;

        const components = this.getValidationComponents().filter(c => c.disable !== true);

        const emit = (res, ref) => {
          this.$emit('validation-' + (res === true ? 'success' : 'error'), ref);
        };

        for (let i = 0; i < components.length; i++) {
          const comp = components[i];
          const valid = comp.validate();

          if (typeof valid.then === 'function') {
            promises.push(
              valid.then(
                valid => ({ valid, comp }),
                err => ({ valid: false, comp, err })
              )
            );
          }
          else if (valid !== true) {
            if (this.greedy === false) {
              emit(false, comp);

              if (focus === true && typeof comp.focus === 'function') {
                comp.focus();
              }

              return Promise.resolve(false)
            }

            promises.push({ valid: false, comp });
          }
        }

        if (promises.length === 0) {
          emit(true);
          return Promise.resolve(true)
        }

        return Promise.all(promises).then(
          res => {
            const errors = res.filter(r => r.valid !== true);

            if (errors.length === 0) {
              index === this.validateIndex && emit(true);
              return true
            }

            const { valid, comp, err } = errors[0];

            if (index === this.validateIndex) {
              err !== void 0 && console.error(err);

              emit(false, comp);

              if (
                focus === true &&
                valid !== true &&
                typeof comp.focus === 'function'
              ) {
                comp.focus();
              }
            }

            return false
          }
        )
      },

      resetValidation () {
        this.validateIndex++;

        this.getValidationComponents().forEach(comp => {
          typeof comp.resetValidation === 'function' && comp.resetValidation();
        });
      },

      submit (evt) {
        evt !== void 0 && stopAndPrevent(evt);

        const index = this.validateIndex + 1;

        this.validate().then(val => {
          // if not outdated && validation succeeded
          if (index === this.validateIndex && val === true) {
            if (this.qListeners.submit !== void 0) {
              this.$emit('submit', evt);
            }
            else if (evt !== void 0 && evt.target !== void 0 && typeof evt.target.submit === 'function') {
              evt.target.submit();
            }
          }
        });
      },

      reset (evt) {
        evt !== void 0 && stopAndPrevent(evt);

        this.$emit('reset');

        this.$nextTick(() => { // allow userland to reset values before
          this.resetValidation();
          if (this.autofocus === true && this.noResetFocus !== true) {
            this.focus();
          }
        });
      },

      focus () {
        addFocusFn(() => {
          if (!this.$el) { return }

          const target = this.$el.querySelector('[autofocus], [data-autofocus]') ||
            Array.prototype.find.call(this.$el.querySelectorAll('[tabindex]'), el => el.tabIndex > -1);

          target !== null && target !== void 0 && target.focus({ preventScroll: true });
        });
      },

      getValidationComponents () {
        return Array.prototype.map.call(
          this.$el.getElementsByClassName('q-validation-component'),
          field => field.__vue__
        ).filter(c => c !== void 0 && typeof c.validate === 'function')
      }
    },

    render (h) {
      return h('form', {
        staticClass: 'q-form',
        on: this.onEvents
      }, slot(this, 'default'))
    }
  });

  var QHeader = Vue.extend({
    name: 'QHeader',

    mixins: [ ListenersMixin ],

    inject: {
      layout: {
        default () {
          console.error('QHeader needs to be child of QLayout');
        }
      }
    },

    props: {
      value: {
        type: Boolean,
        default: true
      },
      reveal: Boolean,
      revealOffset: {
        type: Number,
        default: 250
      },
      bordered: Boolean,
      elevated: Boolean,

      heightHint: {
        type: [String, Number],
        default: 50
      }
    },

    data () {
      return {
        size: parseInt(this.heightHint, 10),
        revealed: true
      }
    },

    watch: {
      value (val) {
        this.__update('space', val);
        this.__updateLocal('revealed', true);
        this.layout.__animate();
      },

      offset (val) {
        this.__update('offset', val);
      },

      reveal (val) {
        val === false && this.__updateLocal('revealed', this.value);
      },

      revealed (val) {
        this.layout.__animate();
        this.$emit('reveal', val);
      },

      'layout.scroll' (scroll) {
        this.reveal === true && this.__updateLocal('revealed',
          scroll.direction === 'up' ||
          scroll.position <= this.revealOffset ||
          scroll.position - scroll.inflexionPosition < 100
        );
      }
    },

    computed: {
      fixed () {
        return this.reveal === true ||
          this.layout.view.indexOf('H') > -1 ||
          (this.$q.platform.is.ios && this.layout.container === true)
      },

      offset () {
        if (this.value !== true) {
          return 0
        }
        if (this.fixed === true) {
          return this.revealed === true ? this.size : 0
        }
        const offset = this.size - this.layout.scroll.position;
        return offset > 0 ? offset : 0
      },

      hidden () {
        return this.value !== true || (this.fixed === true && this.revealed !== true)
      },

      revealOnFocus () {
        return this.value === true && this.hidden === true && this.reveal === true
      },

      classes () {
        return (this.fixed === true ? 'fixed' : 'absolute') + '-top' +
          (this.bordered === true ? ' q-header--bordered' : '') +
          (this.hidden === true ? ' q-header--hidden' : '') +
          (this.value !== true ? ' q-layout--prevent-focus' : '')
      },

      style () {
        const
          view = this.layout.rows.top,
          css = {};

        if (view[0] === 'l' && this.layout.left.space === true) {
          css[this.$q.lang.rtl === true ? 'right' : 'left'] = `${this.layout.left.size}px`;
        }
        if (view[2] === 'r' && this.layout.right.space === true) {
          css[this.$q.lang.rtl === true ? 'left' : 'right'] = `${this.layout.right.size}px`;
        }

        return css
      },

      onEvents () {
        return {
          ...this.qListeners,
          focusin: this.__onFocusin,
          input: stop
        }
      }
    },

    render (h) {
      const child = uniqueSlot(this, 'default', []);

      this.elevated === true && child.push(
        h('div', {
          staticClass: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'
        })
      );

      child.push(
        h(QResizeObserver, {
          props: { debounce: 0 },
          on: cache(this, 'resize', { resize: this.__onResize })
        })
      );

      return h('header', {
        staticClass: 'q-header q-layout__section--marginal',
        class: this.classes,
        style: this.style,
        on: this.onEvents
      }, child)
    },

    created () {
      this.layout.instances.header = this;
      this.value === true && this.__update('size', this.size);
      this.__update('space', this.value);
      this.__update('offset', this.offset);
    },

    beforeDestroy () {
      if (this.layout.instances.header === this) {
        this.layout.instances.header = void 0;
        this.__update('size', 0);
        this.__update('offset', 0);
        this.__update('space', false);
      }
    },

    methods: {
      __onResize ({ height }) {
        this.__updateLocal('size', height);
        this.__update('size', height);
      },

      __update (prop, val) {
        if (this.layout.header[prop] !== val) {
          this.layout.header[prop] = val;
        }
      },

      __updateLocal (prop, val) {
        if (this[prop] !== val) {
          this[prop] = val;
        }
      },

      __onFocusin (evt) {
        if (this.revealOnFocus === true) {
          this.__updateLocal('revealed', true);
        }

        this.$emit('focusin', evt);
      }
    }
  });

  var RatioMixin = {
    props: {
      ratio: [ String, Number ]
    },

    computed: {
      ratioStyle () {
        const ratio = this.ratio || this.naturalRatio;

        if (ratio !== void 0) {
          return { paddingBottom: `${100 / ratio}%` }
        }
      }
    }
  };

  var QImg = Vue.extend({
    name: 'QImg',

    mixins: [ ListenersMixin, RatioMixin ],

    props: {
      src: String,
      srcset: String,
      sizes: String,
      alt: String,
      width: String,
      height: String,

      placeholderSrc: String,

      basic: Boolean,
      contain: Boolean,
      position: {
        type: String,
        default: '50% 50%'
      },

      transition: {
        type: String,
        default: 'fade'
      },

      imgClass: [ Array, String, Object ],
      imgStyle: Object,

      nativeContextMenu: Boolean,

      noDefaultSpinner: Boolean,
      spinnerColor: String,
      spinnerSize: String
    },

    data () {
      return {
        currentSrc: '',
        image: null,
        isLoading: !!this.src,
        hasError: false,
        naturalRatio: void 0
      }
    },

    watch: {
      src () {
        this.__load();
      },

      srcset (val) {
        this.__updateWatcher(val);
      }
    },

    computed: {
      url () {
        return this.currentSrc || this.placeholderSrc || void 0
      },

      attrs () {
        const att = { role: 'img' };
        if (this.alt !== void 0) {
          att['aria-label'] = this.alt;
        }
        return att
      },

      imgContainerStyle () {
        return Object.assign(
          {
            backgroundSize: this.contain === true ? 'contain' : 'cover',
            backgroundPosition: this.position
          },
          this.imgStyle,
          { backgroundImage: `url("${this.url}")` })
      },

      style () {
        return {
          width: this.width,
          height: this.height
        }
      },

      classes () {
        return 'q-img overflow-hidden' +
          (this.nativeContextMenu === true ? ' q-img--menu' : '')
      }
    },

    methods: {
      __onLoad (img) {
        this.isLoading = false;
        this.hasError = false;
        this.__computeRatio(img);
        this.__updateSrc();
        this.__updateWatcher(this.srcset);
        this.$emit('load', this.currentSrc);
      },

      __onError (err) {
        clearTimeout(this.ratioTimer);
        this.isLoading = false;
        this.hasError = true;
        this.currentSrc = '';
        this.$emit('error', err);
      },

      __updateSrc () {
        if (this.image !== void 0 && this.isLoading === false) {
          const src = this.image.currentSrc || this.image.src;
          if (this.currentSrc !== src) {
            this.currentSrc = src;
          }
        }
      },

      __updateWatcher (srcset) {
        if (srcset) {
          if (this.unwatch === void 0) {
            this.unwatch = this.$watch('$q.screen.width', this.__updateSrc);
          }
        }
        else if (this.unwatch !== void 0) {
          this.unwatch();
          this.unwatch = void 0;
        }
      },

      __load () {
        clearTimeout(this.ratioTimer);
        this.hasError = false;

        if (!this.src) {
          this.isLoading = false;
          this.image = void 0;
          this.currentSrc = '';
          return
        }

        this.isLoading = true;

        const img = new Image();
        this.image = img;

        img.onerror = err => {
          // if we are still rendering same image
          if (this.image === img && this.destroyed !== true) {
            this.__onError(err);
          }
        };

        img.onload = () => {
          if (this.destroyed === true) {
            return
          }

          // if we are still rendering same image
          if (this.image === img) {
            if (img.decode !== void 0) {
              img
                .decode()
                .catch(err => {
                  if (this.image === img && this.destroyed !== true) {
                    this.__onError(err);
                  }
                })
                .then(() => {
                  if (this.image === img && this.destroyed !== true) {
                    this.__onLoad(img);
                  }
                });
            }
            else {
              this.__onLoad(img);
            }
          }
        };

        img.src = this.src;

        if (this.srcset) {
          img.srcset = this.srcset;
        }

        if (this.sizes !== void 0) {
          img.sizes = this.sizes;
        }
        else {
          Object.assign(img, {
            height: this.height,
            width: this.width
          });
        }
      },

      __computeRatio (img) {
        const { naturalHeight, naturalWidth } = img;

        if (naturalHeight || naturalWidth) {
          this.naturalRatio = naturalHeight === 0
            ? 1
            : naturalWidth / naturalHeight;
        }
        else {
          this.ratioTimer = setTimeout(() => {
            if (this.image === img && this.destroyed !== true) {
              this.__computeRatio(img);
            }
          }, 100);
        }
      },

      __getImage (h) {
        const nativeImg = this.nativeContextMenu === true
          ? [
            h('img', {
              staticClass: 'absolute-full fit',
              attrs: { src: this.url, 'aria-hidden': 'true' }
            })
          ]
          : void 0;

        const content = this.url !== void 0
          ? h('div', {
            key: this.url,
            staticClass: 'q-img__image absolute-full',
            class: this.imgClass,
            style: this.imgContainerStyle
          }, nativeImg)
          : null;

        return this.basic === true
          ? content
          : h('transition', {
            props: { name: 'q-transition--' + this.transition }
          }, [ content ])
      },

      __getContent (h) {
        const slotVm = slot(this, this.hasError === true ? 'error' : 'default');

        if (this.basic === true) {
          return h('div', {
            key: 'content',
            staticClass: 'q-img__content absolute-full'
          }, slotVm)
        }

        const content = this.isLoading === true
          ? h('div', {
            key: 'placeholder',
            staticClass: 'q-img__loading absolute-full flex flex-center'
          }, this.$scopedSlots.loading !== void 0
            ? this.$scopedSlots.loading()
            : (
              this.noDefaultSpinner === false
                ? [
                  h(QSpinner, {
                    props: {
                      color: this.spinnerColor,
                      size: this.spinnerSize
                    }
                  })
                ]
                : void 0
            )
          )
          : h('div', {
            key: 'content',
            staticClass: 'q-img__content absolute-full'
          }, slotVm);

        return h('transition', {
          props: { name: 'q-transition--fade' }
        }, [ content ])
      }
    },

    render (h) {
      return h('div', {
        class: this.classes,
        style: this.style,
        attrs: this.attrs,
        on: { ...this.qListeners }
      }, [
        h('div', { style: this.ratioStyle }),
        this.__getImage(h),
        this.__getContent(h)
      ])
    },

    beforeMount () {
      if (this.placeholderSrc !== void 0 && this.ratio === void 0) {
        const img = new Image();
        img.src = this.placeholderSrc;
        this.__computeRatio(img);
      }
      this.isLoading === true && this.__load();
    },

    beforeDestroy () {
      this.destroyed = true;
      clearTimeout(this.ratioTimer);
      this.unwatch !== void 0 && this.unwatch();
    }
  });

  const { passive: passive$1 } = listenOpts;

  var QInfiniteScroll = Vue.extend({
    name: 'QInfiniteScroll',

    mixins: [ ListenersMixin ],

    props: {
      offset: {
        type: Number,
        default: 500
      },

      debounce: {
        type: [ String, Number ],
        default: 100
      },

      scrollTarget: {
        default: void 0
      },

      initialIndex: Number,

      disable: Boolean,
      reverse: Boolean
    },

    data () {
      return {
        index: this.initialIndex || 0,
        isFetching: false,
        isWorking: true
      }
    },

    watch: {
      disable (val) {
        if (val === true) { this.stop(); }
        else { this.resume(); }
      },

      reverse () {
        if (this.isFetching === false && this.isWorking === true) {
          this.immediatePoll();
        }
      },

      scrollTarget () {
        this.updateScrollTarget();
      },

      debounce (val) {
        this.__setDebounce(val);
      }
    },

    methods: {
      poll () {
        if (this.disable === true || this.isFetching === true || this.isWorking === false) {
          return
        }

        const
          scrollHeight = getScrollHeight(this.__scrollTarget),
          scrollPosition = getScrollPosition(this.__scrollTarget),
          containerHeight = height(this.__scrollTarget);

        if (this.reverse === false) {
          if (Math.round(scrollPosition + containerHeight + this.offset) >= Math.round(scrollHeight)) {
            this.trigger();
          }
        }
        else if (Math.round(scrollPosition) < this.offset) {
          this.trigger();
        }
      },

      trigger () {
        if (this.disable === true || this.isFetching === true || this.isWorking === false) {
          return
        }

        this.index++;
        this.isFetching = true;

        const heightBefore = getScrollHeight(this.__scrollTarget);

        this.$emit('load', this.index, stop => {
          if (this.isWorking === true) {
            this.isFetching = false;
            this.$nextTick(() => {
              if (this.reverse === true) {
                const
                  heightAfter = getScrollHeight(this.__scrollTarget),
                  scrollPosition = getScrollPosition(this.__scrollTarget),
                  heightDifference = heightAfter - heightBefore;

                setScrollPosition(this.__scrollTarget, scrollPosition + heightDifference);
              }

              if (stop === true) {
                this.stop();
              }
              else {
                this.$el.closest('body') && this.poll();
              }
            });
          }
        });
      },

      reset () {
        this.index = 0;
      },

      resume () {
        if (this.isWorking === false) {
          this.isWorking = true;
          this.__scrollTarget.addEventListener('scroll', this.poll, passive$1);
        }
        this.immediatePoll();
      },

      stop () {
        if (this.isWorking === true) {
          this.isWorking = false;
          this.isFetching = false;
          this.__scrollTarget.removeEventListener('scroll', this.poll, passive$1);
          typeof this.poll.cancel === 'function' && this.poll.cancel();
        }
      },

      updateScrollTarget () {
        if (this.__scrollTarget && this.isWorking === true) {
          this.__scrollTarget.removeEventListener('scroll', this.poll, passive$1);
        }

        this.__scrollTarget = getScrollTarget(this.$el, this.scrollTarget);

        if (this.isWorking === true) {
          this.__scrollTarget.addEventListener('scroll', this.poll, passive$1);

          if (this.reverse === true) {
            const
              scrollHeight = getScrollHeight(this.__scrollTarget),
              containerHeight = height(this.__scrollTarget);

            setScrollPosition(this.__scrollTarget, scrollHeight - containerHeight);
          }

          this.immediatePoll();
        }
      },

      setIndex (index) {
        this.index = index;
      },

      __setDebounce (val) {
        val = parseInt(val, 10);

        const oldPoll = this.poll;

        this.poll = val <= 0
          ? this.immediatePoll
          : debounce(this.immediatePoll, isNaN(val) === true ? 100 : val);

        if (this.__scrollTarget && this.isWorking === true) {
          if (oldPoll !== void 0) {
            this.__scrollTarget.removeEventListener('scroll', oldPoll, passive$1);
          }

          this.__scrollTarget.addEventListener('scroll', this.poll, passive$1);
        }
      }
    },

    mounted () {
      this.immediatePoll = this.poll;
      this.__setDebounce(this.debounce);

      this.updateScrollTarget();
    },

    activated () {
      if (this.__scrollPosition !== void 0 && this.__scrollTarget) {
        setScrollPosition(this.__scrollTarget, this.__scrollPosition);
      }
    },

    deactivated () {
      this.__scrollPosition = this.__scrollTarget
        ? getScrollPosition(this.__scrollTarget)
        : void 0;
    },

    beforeDestroy () {
      this.stop();
    },

    render (h) {
      const child = uniqueSlot(this, 'default', []);

      if (this.disable !== true && this.isWorking === true) {
        child[this.reverse === false ? 'push' : 'unshift'](
          h('div', {
            staticClass: 'q-infinite-scroll__loading',
            class: this.isFetching === true ? '' : 'invisible'
          }, slot(this, 'loading'))
        );
      }

      return h('div', {
        staticClass: 'q-infinite-scroll',
        on: { ...this.qListeners }
      }, child)
    }
  });

  var QInnerLoading = Vue.extend({
    name: 'QInnerLoading',

    mixins: [ ListenersMixin, DarkMixin, TransitionMixin ],

    props: {
      showing: Boolean,
      color: String,

      size: {
        type: [String, Number],
        default: 42
      },

      label: String,
      labelClass: String,
      labelStyle: [ String, Array, Object ]
    },

    computed: {
      classes () {
        return 'q-inner-loading absolute-full column flex-center' +
          (this.isDark === true ? ' q-inner-loading--dark' : '')
      },

      labelClasses () {
        return 'q-inner-loading__label' +
          (this.labelClass !== void 0 ? ` ${this.labelClass}` : '')
      }
    },

    methods: {
      __getInner (h) {
        const child = [
          h(QSpinner, {
            props: {
              size: this.size,
              color: this.color
            }
          })
        ];

        if (this.label !== void 0) {
          child.push(
            h('div', {
              class: this.labelClasses,
              style: this.labelStyle
            }, [ this.label ])
          );
        }

        return child
      },

      __getContent (h) {
        return this.showing === true
          ? [
            h('div',
              {
                staticClass: this.classes,
                on: { ...this.qListeners }
              },
              this.$scopedSlots.default !== void 0
                ? this.$scopedSlots.default()
                : this.__getInner(h)
            )
          ]
          : void 0
      }
    },

    render (h) {
      return h('transition', {
        props: {
          name: this.transition,
          appear: true
        }
      }, this.__getContent(h))
    }
  });

  // leave NAMED_MASKS at top of file (code referenced from docs)
  const NAMED_MASKS = {
    date: '####/##/##',
    datetime: '####/##/## ##:##',
    time: '##:##',
    fulltime: '##:##:##',
    phone: '(###) ### - ####',
    card: '#### #### #### ####'
  };

  const TOKENS = {
    '#': { pattern: '[\\d]', negate: '[^\\d]' },

    S: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]' },
    N: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]' },

    A: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]', transform: v => v.toLocaleUpperCase() },
    a: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]', transform: v => v.toLocaleLowerCase() },

    X: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]', transform: v => v.toLocaleUpperCase() },
    x: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]', transform: v => v.toLocaleLowerCase() }
  };

  const KEYS = Object.keys(TOKENS);
  KEYS.forEach(key => {
    TOKENS[key].regex = new RegExp(TOKENS[key].pattern);
  });

  const
    tokenRegexMask = new RegExp('\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([' + KEYS.join('') + '])|(.)', 'g'),
    escRegex = /[.*+?^${}()|[\]\\]/g;

  const MARKER = String.fromCharCode(1);

  var MaskMixin = {
    props: {
      mask: String,
      reverseFillMask: Boolean,
      fillMask: [Boolean, String],
      unmaskedValue: Boolean
    },

    watch: {
      type () {
        this.__updateMaskInternals();
      },

      autogrow () {
        this.__updateMaskInternals();
      },

      mask (v) {
        if (v !== void 0) {
          this.__updateMaskValue(this.innerValue, true);
        }
        else {
          const val = this.__unmask(this.innerValue);
          this.__updateMaskInternals();
          this.value !== val && this.$emit('input', val);
        }
      },

      fillMask () {
        this.hasMask === true && this.__updateMaskValue(this.innerValue, true);
      },

      reverseFillMask () {
        this.hasMask === true && this.__updateMaskValue(this.innerValue, true);
      },

      unmaskedValue () {
        this.hasMask === true && this.__updateMaskValue(this.innerValue);
      }
    },

    methods: {
      __getInitialMaskedValue () {
        this.__updateMaskInternals();

        if (this.hasMask === true) {
          const masked = this.__mask(this.__unmask(this.value));

          return this.fillMask !== false
            ? this.__fillWithMask(masked)
            : masked
        }

        return this.value
      },

      __getPaddedMaskMarked (size) {
        if (size < this.maskMarked.length) {
          return this.maskMarked.slice(-size)
        }

        let
          maskMarked = this.maskMarked,
          pad = '';
        const
          padPos = maskMarked.indexOf(MARKER);

        if (padPos > -1) {
          for (let i = size - maskMarked.length; i > 0; i--) {
            pad += MARKER;
          }

          maskMarked = maskMarked.slice(0, padPos) + pad + maskMarked.slice(padPos);
        }

        return maskMarked
      },

      __updateMaskInternals () {
        this.hasMask = this.mask !== void 0 &&
          this.mask.length > 0 &&
          (this.autogrow === true || ['textarea', 'text', 'search', 'url', 'tel', 'password'].includes(this.type));

        if (this.hasMask === false) {
          this.computedUnmask = void 0;
          this.maskMarked = '';
          this.maskReplaced = '';
          return
        }

        const
          computedMask = NAMED_MASKS[this.mask] === void 0
            ? this.mask
            : NAMED_MASKS[this.mask],
          fillChar = typeof this.fillMask === 'string' && this.fillMask.length > 0
            ? this.fillMask.slice(0, 1)
            : '_',
          fillCharEscaped = fillChar.replace(escRegex, '\\$&'),
          unmask = [],
          extract = [],
          mask = [];

        let
          firstMatch = this.reverseFillMask === true,
          unmaskChar = '',
          negateChar = '';

        computedMask.replace(tokenRegexMask, (_, char1, esc, token, char2) => {
          if (token !== void 0) {
            const c = TOKENS[token];
            mask.push(c);
            negateChar = c.negate;
            if (firstMatch === true) {
              extract.push('(?:' + negateChar + '+)?(' + c.pattern + '+)?(?:' + negateChar + '+)?(' + c.pattern + '+)?');
              firstMatch = false;
            }
            extract.push('(?:' + negateChar + '+)?(' + c.pattern + ')?');
          }
          else if (esc !== void 0) {
            unmaskChar = '\\' + (esc === '\\' ? '' : esc);
            mask.push(esc);
            unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');
          }
          else {
            const c = char1 !== void 0 ? char1 : char2;
            unmaskChar = c === '\\' ? '\\\\\\\\' : c.replace(escRegex, '\\\\$&');
            mask.push(c);
            unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');
          }
        });

        const
          unmaskMatcher = new RegExp(
            '^' +
            unmask.join('') +
            '(' + (unmaskChar === '' ? '.' : '[^' + unmaskChar + ']') + '+)?' +
            '$'
          ),
          extractLast = extract.length - 1,
          extractMatcher = extract.map((re, index) => {
            if (index === 0 && this.reverseFillMask === true) {
              return new RegExp('^' + fillCharEscaped + '*' + re)
            }
            else if (index === extractLast) {
              return new RegExp(
                '^' + re +
                '(' + (negateChar === '' ? '.' : negateChar) + '+)?' +
                (this.reverseFillMask === true ? '$' : fillCharEscaped + '*')
              )
            }

            return new RegExp('^' + re)
          });

        this.computedMask = mask;
        this.computedUnmask = val => {
          const unmaskMatch = unmaskMatcher.exec(val);
          if (unmaskMatch !== null) {
            val = unmaskMatch.slice(1).join('');
          }

          const
            extractMatch = [],
            extractMatcherLength = extractMatcher.length;

          for (let i = 0, str = val; i < extractMatcherLength; i++) {
            const m = extractMatcher[i].exec(str);

            if (m === null) {
              break
            }

            str = str.slice(m.shift().length);
            extractMatch.push(...m);
          }
          if (extractMatch.length > 0) {
            return extractMatch.join('')
          }

          return val
        };
        this.maskMarked = mask.map(v => typeof v === 'string' ? v : MARKER).join('');
        this.maskReplaced = this.maskMarked.split(MARKER).join(fillChar);
      },

      __updateMaskValue (rawVal, updateMaskInternals, inputType) {
        const
          inp = this.$refs.input,
          end = inp.selectionEnd,
          endReverse = inp.value.length - end,
          unmasked = this.__unmask(rawVal);

        // Update here so unmask uses the original fillChar
        updateMaskInternals === true && this.__updateMaskInternals();

        const
          preMasked = this.__mask(unmasked),
          masked = this.fillMask !== false
            ? this.__fillWithMask(preMasked)
            : preMasked,
          changed = this.innerValue !== masked;

        // We want to avoid "flickering" so we set value immediately
        inp.value !== masked && (inp.value = masked);

        changed === true && (this.innerValue = masked);

        document.activeElement === inp && this.$nextTick(() => {
          if (masked === this.maskReplaced) {
            const cursor = this.reverseFillMask === true ? this.maskReplaced.length : 0;
            inp.setSelectionRange(cursor, cursor, 'forward');

            return
          }

          if (inputType === 'insertFromPaste' && this.reverseFillMask !== true) {
            const cursor = end - 1;
            this.__moveCursorRight(inp, cursor, cursor);

            return
          }

          if (['deleteContentBackward', 'deleteContentForward'].indexOf(inputType) > -1) {
            const cursor = this.reverseFillMask === true
              ? (
                end === 0
                  ? (masked.length > preMasked.length ? 1 : 0)
                  : Math.max(0, masked.length - (masked === this.maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1
              )
              : end;
            inp.setSelectionRange(cursor, cursor, 'forward');

            return
          }

          if (this.reverseFillMask === true) {
            if (changed === true) {
              const cursor = Math.max(0, masked.length - (masked === this.maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));

              if (cursor === 1 && end === 1) {
                inp.setSelectionRange(cursor, cursor, 'forward');
              }
              else {
                this.__moveCursorRightReverse(inp, cursor, cursor);
              }
            }
            else {
              const cursor = masked.length - endReverse;
              inp.setSelectionRange(cursor, cursor, 'backward');
            }
          }
          else {
            if (changed === true) {
              const cursor = Math.max(0, this.maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);
              this.__moveCursorRight(inp, cursor, cursor);
            }
            else {
              const cursor = end - 1;
              this.__moveCursorRight(inp, cursor, cursor);
            }
          }
        });

        const val = this.unmaskedValue === true
          ? this.__unmask(masked)
          : masked;

        String(this.value) !== val && this.__emitValue(val, true);
      },

      __moveCursorForPaste (inp, start, end) {
        const preMasked = this.__mask(this.__unmask(inp.value));

        start = Math.max(0, this.maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));

        inp.setSelectionRange(start, end, 'forward');
      },

      __moveCursorLeft (inp, start, end, selection) {
        const noMarkBefore = this.maskMarked.slice(start - 1).indexOf(MARKER) === -1;
        let i = Math.max(0, start - 1);

        for (; i >= 0; i--) {
          if (this.maskMarked[i] === MARKER) {
            start = i;
            noMarkBefore === true && start++;
            break
          }
        }

        if (
          i < 0 &&
          this.maskMarked[start] !== void 0 &&
          this.maskMarked[start] !== MARKER
        ) {
          return this.__moveCursorRight(inp, 0, 0)
        }

        start >= 0 && inp.setSelectionRange(
          start,
          selection === true ? end : start, 'backward'
        );
      },

      __moveCursorRight (inp, start, end, selection) {
        const limit = inp.value.length;
        let i = Math.min(limit, end + 1);

        for (; i <= limit; i++) {
          if (this.maskMarked[i] === MARKER) {
            end = i;
            break
          }
          else if (this.maskMarked[i - 1] === MARKER) {
            end = i;
          }
        }

        if (
          i > limit &&
          this.maskMarked[end - 1] !== void 0 &&
          this.maskMarked[end - 1] !== MARKER
        ) {
          return this.__moveCursorLeft(inp, limit, limit)
        }

        inp.setSelectionRange(selection ? start : end, end, 'forward');
      },

      __moveCursorLeftReverse (inp, start, end, selection) {
        const
          maskMarked = this.__getPaddedMaskMarked(inp.value.length);
        let i = Math.max(0, start - 1);

        for (; i >= 0; i--) {
          if (maskMarked[i - 1] === MARKER) {
            start = i;
            break
          }
          else if (maskMarked[i] === MARKER) {
            start = i;
            if (i === 0) {
              break
            }
          }
        }

        if (
          i < 0 &&
          maskMarked[start] !== void 0 &&
          maskMarked[start] !== MARKER
        ) {
          return this.__moveCursorRightReverse(inp, 0, 0)
        }

        start >= 0 && inp.setSelectionRange(
          start,
          selection === true ? end : start, 'backward'
        );
      },

      __moveCursorRightReverse (inp, start, end, selection) {
        const
          limit = inp.value.length,
          maskMarked = this.__getPaddedMaskMarked(limit),
          noMarkBefore = maskMarked.slice(0, end + 1).indexOf(MARKER) === -1;
        let i = Math.min(limit, end + 1);

        for (; i <= limit; i++) {
          if (maskMarked[i - 1] === MARKER) {
            end = i;
            end > 0 && noMarkBefore === true && end--;
            break
          }
        }

        if (
          i > limit &&
          maskMarked[end - 1] !== void 0 &&
          maskMarked[end - 1] !== MARKER
        ) {
          return this.__moveCursorLeftReverse(inp, limit, limit)
        }

        inp.setSelectionRange(selection === true ? start : end, end, 'forward');
      },

      __onMaskedKeydown (e) {
        if (shouldIgnoreKey(e) === true) {
          return
        }

        const
          inp = this.$refs.input,
          start = inp.selectionStart,
          end = inp.selectionEnd;

        if (e.keyCode === 37 || e.keyCode === 39) { // Left / Right
          const fn = this['__moveCursor' + (e.keyCode === 39 ? 'Right' : 'Left') + (this.reverseFillMask === true ? 'Reverse' : '')];

          e.preventDefault();
          fn(inp, start, end, e.shiftKey);
        }
        else if (
          e.keyCode === 8 && // Backspace
          this.reverseFillMask !== true &&
          start === end
        ) {
          this.__moveCursorLeft(inp, start, end, true);
        }
        else if (
          e.keyCode === 46 && // Delete
          this.reverseFillMask === true &&
          start === end
        ) {
          this.__moveCursorRightReverse(inp, start, end, true);
        }

        this.$emit('keydown', e);
      },

      __mask (val) {
        if (val === void 0 || val === null || val === '') { return '' }

        if (this.reverseFillMask === true) {
          return this.__maskReverse(val)
        }

        const mask = this.computedMask;

        let valIndex = 0, output = '';

        for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {
          const
            valChar = val[valIndex],
            maskDef = mask[maskIndex];

          if (typeof maskDef === 'string') {
            output += maskDef;
            valChar === maskDef && valIndex++;
          }
          else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
            output += maskDef.transform !== void 0
              ? maskDef.transform(valChar)
              : valChar;
            valIndex++;
          }
          else {
            return output
          }
        }

        return output
      },

      __maskReverse (val) {
        const
          mask = this.computedMask,
          firstTokenIndex = this.maskMarked.indexOf(MARKER);

        let valIndex = val.length - 1, output = '';

        for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {
          const maskDef = mask[maskIndex];

          let valChar = val[valIndex];

          if (typeof maskDef === 'string') {
            output = maskDef + output;
            valChar === maskDef && valIndex--;
          }
          else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
            do {
              output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;
              valIndex--;
              valChar = val[valIndex];
            // eslint-disable-next-line no-unmodified-loop-condition
            } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar))
          }
          else {
            return output
          }
        }

        return output
      },

      __unmask (val) {
        return typeof val !== 'string' || this.computedUnmask === void 0
          ? (typeof val === 'number' ? this.computedUnmask('' + val) : val)
          : this.computedUnmask(val)
      },

      __fillWithMask (val) {
        if (this.maskReplaced.length - val.length <= 0) {
          return val
        }

        return this.reverseFillMask === true && val.length > 0
          ? this.maskReplaced.slice(0, -val.length) + val
          : val + this.maskReplaced.slice(val.length)
      }
    }
  };

  const isJapanese = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/;
  const isChinese = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u;
  const isKorean = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/;
  const isPlainText = /[a-z0-9_ -]$/i;

  var CompositionMixin = {
    methods: {
      __onComposition (e) {
        if (e.type === 'compositionend' || e.type === 'change') {
          if (e.target.qComposing !== true) { return }
          e.target.qComposing = false;
          this.__onInput(e);
        }
        else if (
          e.type === 'compositionupdate' &&
          e.target.qComposing !== true &&
          typeof e.data === 'string'
        ) {
          const isComposing = client.is.firefox === true
            ? isPlainText.test(e.data) === false
            : isJapanese.test(e.data) === true || isChinese.test(e.data) === true || isKorean.test(e.data) === true;

          if (isComposing === true) {
            e.target.qComposing = true;
          }
        }
      }
    }
  };

  var QInput = Vue.extend({
    name: 'QInput',

    mixins: [
      QField,
      MaskMixin,
      CompositionMixin,
      FormFieldMixin,
      FileValueMixin,
      ListenersMixin
    ],

    props: {
      value: { required: false },

      shadowText: String,

      type: {
        type: String,
        default: 'text'
      },

      debounce: [String, Number],

      autogrow: Boolean, // makes a textarea

      inputClass: [Array, String, Object],
      inputStyle: [Array, String, Object]
    },

    watch: {
      value (v) {
        if (this.hasMask === true) {
          if (this.stopValueWatcher === true) {
            this.stopValueWatcher = false;

            if (String(v) === this.emitCachedValue) {
              return
            }
          }

          this.__updateMaskValue(v);
        }
        else if (this.innerValue !== v) {
          this.innerValue = v;

          if (
            this.type === 'number' &&
            this.hasOwnProperty('tempValue') === true
          ) {
            if (this.typedNumber === true) {
              this.typedNumber = false;
            }
            else {
              delete this.tempValue;
            }
          }
        }

        // textarea only
        this.autogrow === true && this.$nextTick(this.__adjustHeight);
      },

      // some browsers lose the native input value
      // so we need to reattach it dynamically
      // (like type="password" <-> type="text"; see #12078)
      type () {
        if (this.$refs.input) {
          this.$refs.input.value = this.value;
        }
      },

      autogrow (autogrow) {
        // textarea only
        if (autogrow === true) {
          this.$nextTick(this.__adjustHeight);
        }
        // if it has a number of rows set respect it
        else if (this.qAttrs.rows > 0 && this.$refs.input !== void 0) {
          const inp = this.$refs.input;
          inp.style.height = 'auto';
        }
      },

      dense () {
        this.autogrow === true && this.$nextTick(this.__adjustHeight);
      }
    },

    data () {
      return { innerValue: this.__getInitialMaskedValue() }
    },

    computed: {
      isTextarea () {
        return this.type === 'textarea' || this.autogrow === true
      },

      isTypeText () {
        return this.isTextarea === true || ['text', 'search', 'url', 'tel', 'password'].includes(this.type)
      },

      fieldClass () {
        return `q-${this.isTextarea === true ? 'textarea' : 'input'}` +
          (this.autogrow === true ? ' q-textarea--autogrow' : '')
      },

      hasShadow () {
        return this.type !== 'file' &&
          typeof this.shadowText === 'string' &&
          this.shadowText.length > 0
      },

      onEvents () {
        const on = {
          ...this.qListeners,
          input: this.__onInput,
          paste: this.__onPaste,
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          change: this.__onChange,
          blur: this.__onFinishEditing,
          focus: stop
        };

        on.compositionstart = on.compositionupdate = on.compositionend = this.__onComposition;

        if (this.hasMask === true) {
          on.keydown = this.__onMaskedKeydown;
        }

        if (this.autogrow === true) {
          on.animationend = this.__adjustHeight;
        }

        return on
      },

      inputAttrs () {
        const attrs = {
          tabindex: 0,
          'data-autofocus': this.autofocus || void 0,
          rows: this.type === 'textarea' ? 6 : void 0,
          'aria-label': this.label,
          name: this.nameProp,
          ...this.qAttrs,
          id: this.targetUid,
          type: this.type,
          maxlength: this.maxlength,
          disabled: this.disable === true,
          readonly: this.readonly === true
        };

        if (this.autogrow === true) {
          attrs.rows = 1;
        }

        return attrs
      }
    },

    methods: {
      focus () {
        addFocusFn(() => {
          const el = document.activeElement;
          if (
            this.$refs.input !== void 0 &&
            this.$refs.input !== el &&
            // IE can have null document.activeElement
            (el === null || el.id !== this.targetUid)
          ) {
            this.$refs.input.focus({ preventScroll: true });
          }
        });
      },

      select () {
        this.$refs.input !== void 0 && this.$refs.input.select();
      },

      getNativeElement () {
        return this.$refs.input
      },

      __onPaste (e) {
        if (this.hasMask === true && this.reverseFillMask !== true) {
          const inp = e.target;
          this.__moveCursorForPaste(inp, inp.selectionStart, inp.selectionEnd);
        }

        this.$emit('paste', e);
      },

      __onInput (e) {
        if (!e || !e.target || e.target.qComposing === true) {
          return
        }

        if (this.type === 'file') {
          this.$emit('input', e.target.files);
          return
        }

        const val = e.target.value;

        if (this.hasMask === true) {
          this.__updateMaskValue(val, false, e.inputType);
        }
        else {
          this.__emitValue(val);

          if (this.isTypeText === true && e.target === document.activeElement) {
            const { selectionStart, selectionEnd } = e.target;

            if (selectionStart !== void 0 && selectionEnd !== void 0) {
              this.$nextTick(() => {
                if (e.target === document.activeElement && val.indexOf(e.target.value) === 0) {
                  e.target.setSelectionRange(selectionStart, selectionEnd);
                }
              });
            }
          }
        }

        // we need to trigger it immediately too,
        // to avoid "flickering"
        this.autogrow === true && this.__adjustHeight();
      },

      __emitValue (val, stopWatcher) {
        this.emitValueFn = () => {
          if (
            this.type !== 'number' &&
            this.hasOwnProperty('tempValue') === true
          ) {
            delete this.tempValue;
          }

          if (this.value !== val && this.emitCachedValue !== val) {
            this.emitCachedValue = val;

            stopWatcher === true && (this.stopValueWatcher = true);
            this.$emit('input', val);

            this.$nextTick(() => {
              this.emitCachedValue === val && (this.emitCachedValue = NaN);
            });
          }

          this.emitValueFn = void 0;
        };

        if (this.type === 'number') {
          this.typedNumber = true;
          this.tempValue = val;
        }

        if (this.debounce !== void 0) {
          clearTimeout(this.emitTimer);
          this.tempValue = val;
          this.emitTimer = setTimeout(this.emitValueFn, this.debounce);
        }
        else {
          this.emitValueFn();
        }
      },

      // textarea only
      __adjustHeight () {
        const inp = this.$refs.input;
        if (inp !== void 0) {
          const parentStyle = inp.parentNode.style;
          const { overflow } = inp.style;

          // reset height of textarea to a small size to detect the real height
          // but keep the total control size the same
          parentStyle.marginBottom = (inp.scrollHeight - 1) + 'px';
          inp.style.height = '1px';
          inp.style.overflow = 'hidden';

          inp.style.height = inp.scrollHeight + 'px';
          inp.style.overflow = overflow;
          parentStyle.marginBottom = '';
        }
      },

      __onChange (e) {
        this.__onComposition(e);

        clearTimeout(this.emitTimer);
        this.emitValueFn !== void 0 && this.emitValueFn();

        this.$emit('change', e);
      },

      __onFinishEditing (e) {
        e !== void 0 && stop(e);

        clearTimeout(this.emitTimer);
        this.emitValueFn !== void 0 && this.emitValueFn();

        this.typedNumber = false;
        this.stopValueWatcher = false;
        delete this.tempValue;

        // we need to use setTimeout instead of this.$nextTick
        // to avoid a bug where focusout is not emitted for type date/time/week/...
        this.type !== 'file' && setTimeout(() => {
          if (this.$refs.input !== void 0) {
            this.$refs.input.value = this.innerValue !== void 0 ? this.innerValue : '';
          }
        });
      },

      __getCurValue () {
        return this.hasOwnProperty('tempValue') === true
          ? this.tempValue
          : (this.innerValue !== void 0 ? this.innerValue : '')
      },

      __getShadowControl (h) {
        return h('div', {
          staticClass: 'q-field__native q-field__shadow absolute-bottom no-pointer-events' +
            (this.isTextarea === true ? '' : ' text-no-wrap')
        }, [
          h('span', { staticClass: 'invisible' }, this.__getCurValue()),
          h('span', this.shadowText)
        ])
      },

      __getControl (h) {
        return h(this.isTextarea === true ? 'textarea' : 'input', {
          ref: 'input',
          staticClass: 'q-field__native q-placeholder',
          style: this.inputStyle,
          class: this.inputClass,
          attrs: this.inputAttrs,
          on: this.onEvents,
          domProps: this.type !== 'file'
            ? { value: this.__getCurValue() }
            : this.formDomProps
        })
      }
    },

    created () {
      this.emitCachedValue = NaN;
    },

    mounted () {
      // textarea only
      this.autogrow === true && this.__adjustHeight();
    },

    beforeDestroy () {
      this.__onFinishEditing();
    }
  });

  const defaultCfg = {
    threshold: 0,
    root: null,
    rootMargin: '0px'
  };

  function update (el, ctx, value) {
    let handler, cfg, changed;

    if (typeof value === 'function') {
      handler = value;
      cfg = defaultCfg;
      changed = ctx.cfg === void 0;
    }
    else {
      handler = value.handler;
      cfg = Object.assign({}, defaultCfg, value.cfg);
      changed = ctx.cfg === void 0 || isDeepEqual(ctx.cfg, cfg) === false;
    }

    if (ctx.handler !== handler) {
      ctx.handler = handler;
    }

    if (changed === true) {
      ctx.cfg = cfg;
      ctx.observer !== void 0 && ctx.observer.unobserve(el);

      ctx.observer = new IntersectionObserver(([ entry ]) => {
        if (typeof ctx.handler === 'function') {
          // if observed element is part of a vue transition
          // then we need to be careful...
          if (
            entry.rootBounds === null &&
            (el.__vue__ !== void 0 ? el.__vue__._inactive !== true : document.body.contains(el) === true)
          ) {
            ctx.observer.unobserve(el);
            ctx.observer.observe(el);
            return
          }

          const res = ctx.handler(entry, ctx.observer);

          if (
            res === false ||
            (ctx.once === true && entry.isIntersecting === true)
          ) {
            destroy$3(el);
          }
        }
      }, cfg);

      ctx.observer.observe(el);
    }
  }

  function destroy$3 (el) {
    const ctx = el.__qvisible;

    if (ctx !== void 0) {
      ctx.observer !== void 0 && ctx.observer.unobserve(el);
      delete el.__qvisible;
    }
  }

  var Intersection = {
    name: 'intersection',

    inserted (el, { modifiers, value }) {
      if (el.__qvisible !== void 0) {
        destroy$3(el);
        el.__qvisible_destroyed = true;
      }

      const ctx = {
        once: modifiers.once === true
      };

      update(el, ctx, value);

      el.__qvisible = ctx;
    },

    update (el, binding) {
      const ctx = el.__qvisible;
      ctx !== void 0 && update(el, ctx, binding.value);
    },

    unbind (el) {
      if (el.__qvisible_destroyed === void 0) {
        destroy$3(el);
      }
      else {
        delete el.__qvisible_destroyed;
      }
    }
  };

  var QIntersection = Vue.extend({
    name: 'QIntersection',

    mixins: [ TagMixin, ListenersMixin ],

    directives: {
      Intersection
    },

    props: {
      once: Boolean,
      transition: String,

      ssrPrerender: Boolean,

      margin: String,
      threshold: [ Number, Array ],
      root: {
        default: null
      },

      disable: Boolean
    },

    data () {
      return {
        showing: onSSR === true ? this.ssrPrerender : false
      }
    },

    computed: {
      value () {
        return this.root !== void 0 || this.margin !== void 0 || this.threshold !== void 0
          ? {
            handler: this.__trigger,
            cfg: {
              root: this.root,
              rootMargin: this.margin,
              threshold: this.threshold
            }
          }
          : this.__trigger
      },

      directives () {
        if (this.disable !== true && (onSSR !== true || this.once !== true || this.ssrPrerender !== true)) {
          return [{
            name: 'intersection',
            value: this.value,
            modifiers: {
              once: this.once
            }
          }]
        }
      }
    },

    methods: {
      __trigger (entry) {
        if (this.showing !== entry.isIntersecting) {
          this.showing = entry.isIntersecting;

          if (this.qListeners.visibility !== void 0) {
            this.$emit('visibility', this.showing);
          }
        }
      }
    },

    render (h) {
      const content = this.showing === true
        ? [ h('div', { key: 'content' }, slot(this, 'default')) ]
        : void 0;

      return h(this.tag, {
        staticClass: 'q-intersection',
        on: { ...this.qListeners },
        directives: this.directives
      }, this.transition
        ? [
          h('transition', {
            props: { name: 'q-transition--' + this.transition }
          }, content)
        ]
        : content
      )
    }
  });

  // PGDOWN, LEFT, DOWN, PGUP, RIGHT, UP
  const keyCodes$1 = [34, 37, 40, 33, 39, 38];

  var QKnob = Vue.extend({
    name: 'QKnob',

    mixins: [
      { props: QCircularProgress.options.props },
      FormMixin
    ],

    directives: {
      TouchPan
    },

    props: {
      innerMin: Number,
      innerMax: Number,

      step: {
        type: Number,
        default: 1,
        validator: v => v >= 0
      },

      tabindex: {
        type: [Number, String],
        default: 0
      },

      disable: Boolean,
      readonly: Boolean
    },

    data () {
      const innerMin = this.__getInnerMin(this.innerMin);
      const innerMax = this.__getInnerMax(this.innerMax);

      return {
        model: this.value === null ? innerMin : between(this.value, innerMin, innerMax),
        dragging: false
      }
    },

    watch: {
      modelUpdate () {
        this.model = this.value === null
          ? this.computedInnerMin
          : between(this.value, this.computedInnerMin, this.computedInnerMax);

        this.__updateValue(true);
      }
    },

    computed: {
      classes () {
        return 'q-knob non-selectable' + (
          this.editable === true
            ? ' q-knob--editable'
            : (this.disable === true ? ' disabled' : '')
        )
      },

      computedInnerMin () {
        return this.__getInnerMin(this.innerMin)
      },

      computedInnerMax () {
        return this.__getInnerMax(this.innerMax)
      },

      modelUpdate () {
        return `${this.value}|${this.computedInnerMin}|${this.computedInnerMax}`
      },

      editable () {
        return this.disable === false && this.readonly === false
      },

      decimals () {
        return (String(this.step).trim('0').split('.')[1] || '').length
      },

      computedStep () {
        return this.step === 0 ? 1 : this.step
      },

      computedInstantFeedback () {
        return this.instantFeedback === true ||
          this.dragging === true
      },

      onEvents () {
        return this.$q.platform.is.mobile === true
          ? { click: this.__click }
          : {
            mousedown: this.__activate,
            click: this.__click,
            keydown: this.__keydown,
            keyup: this.__keyup
          }
      },

      attrs () {
        const attrs = {
          role: 'slider',
          'aria-valuemin': this.computedInnerMin,
          'aria-valuemax': this.computedInnerMax,
          'aria-valuenow': this.value
        };

        if (this.editable === true) {
          attrs.tabindex = this.tabindex;
        }
        else {
          attrs[`aria-${this.disable === true ? 'disabled' : 'readonly'}`] = '';
        }

        return attrs
      }
    },

    methods: {
      __getInnerMin (val) {
        return isNaN(val) === true || this.innerMin < this.min
          ? this.min
          : this.innerMin
      },

      __getInnerMax (val) {
        return isNaN(val) === true || val > this.max
          ? this.max
          : this.innerMax
      },

      __updateCenterPosition () {
        const { top, left, width, height } = this.$el.getBoundingClientRect();
        this.centerPosition = {
          top: top + height / 2,
          left: left + width / 2
        };
      },

      __pan (event) {
        if (event.isFinal) {
          this.__updatePosition(event.evt, true);
          this.dragging = false;
        }
        else if (event.isFirst) {
          this.__updateCenterPosition();
          this.dragging = true;
          this.__updatePosition(event.evt);
        }
        else {
          this.__updatePosition(event.evt);
        }
      },

      __click (evt) {
        this.__updateCenterPosition();
        this.__updatePosition(evt, true);
      },

      __keydown (evt) {
        if (!keyCodes$1.includes(evt.keyCode)) {
          return
        }

        stopAndPrevent(evt);

        const
          step = ([34, 33].includes(evt.keyCode) ? 10 : 1) * this.computedStep,
          offset = [34, 37, 40].includes(evt.keyCode) ? -step : step;

        this.model = between(
          parseFloat((this.model + offset).toFixed(this.decimals)),
          this.computedInnerMin,
          this.computedInnerMax
        );

        this.__updateValue();
      },

      __keyup (evt) {
        if (keyCodes$1.includes(evt.keyCode)) {
          this.__updateValue(true);
        }
      },

      __activate (evt) {
        this.__updateCenterPosition();
        this.__updatePosition(evt);
      },

      __updatePosition (evt, change) {
        const
          center = this.centerPosition,
          pos = position(evt),
          height = Math.abs(pos.top - center.top),
          distance = Math.sqrt(
            height ** 2 +
            Math.abs(pos.left - center.left) ** 2
          );

        let angle = Math.asin(height / distance) * (180 / Math.PI);

        if (pos.top < center.top) {
          angle = center.left < pos.left ? 90 - angle : 270 + angle;
        }
        else {
          angle = center.left < pos.left ? angle + 90 : 270 - angle;
        }

        if (this.$q.lang.rtl === true) {
          angle = normalizeToInterval(-angle - this.angle, 0, 360);
        }
        else if (this.angle) {
          angle = normalizeToInterval(angle - this.angle, 0, 360);
        }

        if (this.reverse === true) {
          angle = 360 - angle;
        }

        let model = this.min + (angle / 360) * (this.max - this.min);

        if (this.step !== 0) {
          const
            step = this.computedStep,
            modulo = model % step;

          model = model - modulo +
            (Math.abs(modulo) >= step / 2 ? (modulo < 0 ? -1 : 1) * step : 0);

          model = parseFloat(model.toFixed(this.decimals));
        }

        model = between(model, this.computedInnerMin, this.computedInnerMax);

        this.$emit('drag-value', model);

        if (this.model !== model) {
          this.model = model;
        }

        this.__updateValue(change);
      },

      __updateValue (change) {
        this.value !== this.model && this.$emit('input', this.model);
        change === true && this.$emit('change', this.model);
      },

      __getNameInput () {
        return this.$createElement('input', { attrs: this.formAttrs })
      }
    },

    render (h) {
      const data = {
        class: this.classes,
        attrs: this.attrs,
        props: {
          ...this.$props,
          value: this.model,
          instantFeedback: this.computedInstantFeedback
        }
      };

      if (this.editable === true) {
        data.on = this.onEvents;
        data.directives = cache(this, 'dir', [{
          name: 'touch-pan',
          value: this.__pan,
          modifiers: {
            prevent: true,
            stop: true,
            mouse: true
          }
        }]);

        if (this.name !== void 0) {
          data.scopedSlots = {
            internal: this.__getNameInput
          };
        }
      }

      return h(QCircularProgress, data, slot(this, 'default'))
    }
  });

  const { passive: passive$2 } = listenOpts;

  var QScrollObserver = Vue.extend({
    name: 'QScrollObserver',

    props: {
      debounce: [ String, Number ],
      horizontal: Boolean,

      scrollTarget: {
        default: void 0
      }
    },

    render: noop, // eslint-disable-line

    data () {
      return {
        pos: 0,
        dir: this.horizontal === true ? 'right' : 'down',
        dirChanged: false,
        dirChangePos: 0
      }
    },

    watch: {
      scrollTarget () {
        this.__unconfigureScrollTarget();
        this.__configureScrollTarget();
      }
    },

    methods: {
      getPosition () {
        return {
          position: this.pos,
          direction: this.dir,
          directionChanged: this.dirChanged,
          inflexionPosition: this.dirChangePos
        }
      },

      trigger (immediately) {
        if (immediately === true || this.debounce === 0 || this.debounce === '0') {
          this.__emit();
        }
        else if (this.clearTimer === void 0) {
          const [ timer, fn ] = this.debounce
            ? [ setTimeout(this.__emit, this.debounce), clearTimeout ]
            : [ requestAnimationFrame(this.__emit), cancelAnimationFrame ];

          this.clearTimer = () => {
            fn(timer);
            this.clearTimer = void 0;
          };
        }
      },

      __emit () {
        this.clearTimer !== void 0 && this.clearTimer();

        const fn = this.horizontal === true
          ? getHorizontalScrollPosition
          : getScrollPosition;

        const
          pos = Math.max(0, fn(this.__scrollTarget)),
          delta = pos - this.pos,
          dir = this.horizontal === true
            ? delta < 0 ? 'left' : 'right'
            : delta < 0 ? 'up' : 'down';

        this.dirChanged = this.dir !== dir;

        if (this.dirChanged) {
          this.dir = dir;
          this.dirChangePos = this.pos;
        }

        this.pos = pos;
        this.$emit('scroll', this.getPosition());
      },

      __configureScrollTarget () {
        this.__scrollTarget = getScrollTarget(this.$el.parentNode, this.scrollTarget);
        this.__scrollTarget.addEventListener('scroll', this.trigger, passive$2);
        this.trigger(true);
      },

      __unconfigureScrollTarget () {
        if (this.__scrollTarget !== void 0) {
          this.__scrollTarget.removeEventListener('scroll', this.trigger, passive$2);
          this.__scrollTarget = void 0;
        }
      }
    },

    mounted () {
      this.__configureScrollTarget();
    },

    beforeDestroy () {
      this.clearTimer !== void 0 && this.clearTimer();
      this.__unconfigureScrollTarget();
    }
  });

  var QLayout = Vue.extend({
    name: 'QLayout',

    mixins: [ ListenersMixin ],

    provide () {
      return {
        layout: this
      }
    },

    props: {
      container: Boolean,
      view: {
        type: String,
        default: 'hhh lpr fff',
        validator: v => /^(h|l)h(h|r) lpr (f|l)f(f|r)$/.test(v.toLowerCase())
      }
    },

    data () {
      return {
        // page related
        height: this.$q.screen.height,
        width: this.container === true ? 0 : this.$q.screen.width,

        // container only prop
        containerHeight: 0,
        scrollbarWidth: onSSR === true ? 0 : getScrollbarWidth(),

        header: {
          size: 0,
          offset: 0,
          space: false
        },
        right: {
          size: 300,
          offset: 0,
          space: false
        },
        footer: {
          size: 0,
          offset: 0,
          space: false
        },
        left: {
          size: 300,
          offset: 0,
          space: false
        },

        scroll: {
          position: 0,
          direction: 'down'
        }
      }
    },

    computed: {
      rows () {
        const rows = this.view.toLowerCase().split(' ');
        return {
          top: rows[0].split(''),
          middle: rows[1].split(''),
          bottom: rows[2].split('')
        }
      },

      style () {
        return this.container === true
          ? null
          : { minHeight: this.$q.screen.height + 'px' }
      },

      // used by container only
      targetStyle () {
        if (this.scrollbarWidth !== 0) {
          return { [this.$q.lang.rtl === true ? 'left' : 'right']: `${this.scrollbarWidth}px` }
        }
      },

      targetChildStyle () {
        if (this.scrollbarWidth !== 0) {
          return {
            [this.$q.lang.rtl === true ? 'right' : 'left']: 0,
            [this.$q.lang.rtl === true ? 'left' : 'right']: `-${this.scrollbarWidth}px`,
            width: `calc(100% + ${this.scrollbarWidth}px)`
          }
        }
      },

      totalWidth () {
        return this.width + this.scrollbarWidth
      },

      classes () {
        return 'q-layout q-layout--' +
          (this.container === true ? 'containerized' : 'standard')
      },

      scrollbarEvtAction () {
        return this.container !== true && this.scrollbarWidth > 0
          ? 'add' : 'remove'
      }
    },

    watch: {
      scrollbarEvtAction: '__updateScrollEvent'
    },

    created () {
      this.instances = {};
    },

    mounted () {
      this.scrollbarEvtAction === 'add' && this.__updateScrollEvent('add');
    },

    beforeDestroy () {
      this.scrollbarEvtAction === 'add' && this.__updateScrollEvent('remove');
    },

    render (h) {
      const layout = h('div', {
        class: this.classes,
        style: this.style,
        attrs: { tabindex: -1 },
        on: { ...this.qListeners }
      }, mergeSlot([
        h(QScrollObserver, {
          on: cache(this, 'scroll', { scroll: this.__onPageScroll })
        }),

        h(QResizeObserver, {
          on: cache(this, 'resizeOut', { resize: this.__onPageResize })
        })
      ], this, 'default'));

      return this.container === true
        ? h('div', {
          staticClass: 'q-layout-container overflow-hidden'
        }, [
          h(QResizeObserver, {
            on: cache(this, 'resizeIn', { resize: this.__onContainerResize })
          }),
          h('div', {
            staticClass: 'absolute-full',
            style: this.targetStyle
          }, [
            h('div', {
              staticClass: 'scroll',
              style: this.targetChildStyle
            }, [ layout ])
          ])
        ])
        : layout
    },

    methods: {
      __animate () {
        if (this.timer !== void 0) {
          clearTimeout(this.timer);
        }
        else {
          document.body.classList.add('q-body--layout-animate');
        }
        this.timer = setTimeout(() => {
          document.body.classList.remove('q-body--layout-animate');
          this.timer = void 0;
        }, 150);
      },

      __onPageScroll (data) {
        if (this.container === true || document.qScrollPrevented !== true) {
          this.scroll = data;
        }
        this.qListeners.scroll !== void 0 && this.$emit('scroll', data);
      },

      __onPageResize ({ height, width }) {
        let resized = false;

        if (this.height !== height) {
          resized = true;
          this.height = height;
          if (this.qListeners['scroll-height'] !== void 0) {
            this.$emit('scroll-height', height);
          }
          this.__updateScrollbarWidth();
        }
        if (this.width !== width) {
          resized = true;
          this.width = width;
        }

        if (resized === true && this.qListeners.resize !== void 0) {
          this.$emit('resize', { height, width });
        }
      },

      __onContainerResize ({ height }) {
        if (this.containerHeight !== height) {
          this.containerHeight = height;
          this.__updateScrollbarWidth();
        }
      },

      __updateScrollbarWidth () {
        if (this.container === true) {
          const width = this.height > this.containerHeight
            ? getScrollbarWidth()
            : 0;

          if (this.scrollbarWidth !== width) {
            this.scrollbarWidth = width;
          }
        }
      },

      __updateScrollEvent (action) {
        if (this.timerScrollbar !== void 0 && action === 'remove') {
          clearTimeout(this.timerScrollbar);
          this.__restoreScrollbar();
        }

        window[`${action}EventListener`]('resize', this.__hideScrollbar);
      },

      __hideScrollbar () {
        if (this.timerScrollbar === void 0) {
          const el = document.body;

          // if it has no scrollbar then there's nothing to do
          if (el.scrollHeight > this.$q.screen.height) {
            return
          }

          el.classList.add('hide-scrollbar');
        }
        else {
          clearTimeout(this.timerScrollbar);
        }

        this.timerScrollbar = setTimeout(this.__restoreScrollbar, 200);
      },

      __restoreScrollbar () {
        this.timerScrollbar = void 0;
        document.body.classList.remove('hide-scrollbar');
      }
    }
  });

  var QMarkupTable = Vue.extend({
    name: 'QMarkupTable',

    mixins: [ DarkMixin, ListenersMixin ],

    props: {
      dense: Boolean,
      flat: Boolean,
      bordered: Boolean,
      square: Boolean,
      separator: {
        type: String,
        default: 'horizontal',
        validator: v => ['horizontal', 'vertical', 'cell', 'none'].includes(v)
      },
      wrapCells: Boolean
    },

    computed: {
      classes () {
        return `q-table--${this.separator}-separator` +
          (this.isDark === true ? ' q-table--dark q-table__card--dark q-dark' : '') +
          (this.dense === true ? ' q-table--dense' : '') +
          (this.flat === true ? ' q-table--flat' : '') +
          (this.bordered === true ? ' q-table--bordered' : '') +
          (this.square === true ? ' q-table--square' : '') +
          (this.wrapCells === false ? ' q-table--no-wrap' : '')
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-markup-table q-table__container q-table__card',
        class: this.classes,
        on: { ...this.qListeners }
      }, [
        h('table', { staticClass: 'q-table' }, slot(this, 'default'))
      ])
    }
  });

  var QNoSsr = Vue.extend({
    name: 'QNoSsr',

    mixins: [ CanRenderMixin, TagMixin, ListenersMixin ],

    props: {
      placeholder: String
    },

    render (h) {
      const data = {
        on: { ...this.qListeners }
      };

      if (this.canRender === true) {
        const node = slot(this, 'default');
        return node === void 0
          ? node
          : (node.length > 1 ? h(this.tag, data, node) : node[0])
      }

      data.staticClass = 'q-no-ssr-placeholder';

      const node = slot(this, 'placeholder');
      if (node !== void 0) {
        return node.length > 1
          ? h(this.tag, data, node)
          : node[0]
      }

      if (this.placeholder !== void 0) {
        return h(this.tag, data, [
          this.placeholder
        ])
      }
    }
  });

  var QRadio = Vue.extend({
    name: 'QRadio',

    mixins: [ DarkMixin, OptionSizeMixin, FormMixin, RefocusTargetMixin ],

    props: {
      value: {
        required: true
      },
      val: {
        required: true
      },

      label: String,
      leftLabel: Boolean,

      checkedIcon: String,
      uncheckedIcon: String,

      color: String,
      keepColor: Boolean,
      dense: Boolean,

      disable: Boolean,
      tabindex: [String, Number]
    },

    computed: {
      isTrue () {
        return this.value === this.val
      },

      classes () {
        return 'q-radio cursor-pointer no-outline row inline no-wrap items-center' +
          (this.disable === true ? ' disabled' : '') +
          (this.isDark === true ? ' q-radio--dark' : '') +
          (this.dense === true ? ' q-radio--dense' : '') +
          (this.leftLabel === true ? ' reverse' : '')
      },

      innerClass () {
        const color = this.color !== void 0 && (
          this.keepColor === true ||
          this.isTrue === true
        )
          ? ` text-${this.color}`
          : '';

        return `q-radio__inner--${this.isTrue === true ? 'truthy' : 'falsy'}${color}`
      },

      computedIcon () {
        return this.isTrue === true
          ? this.checkedIcon
          : this.uncheckedIcon
      },

      computedTabindex () {
        return this.disable === true ? -1 : this.tabindex || 0
      },

      formAttrs () {
        const prop = { type: 'radio' };

        this.name !== void 0 && Object.assign(prop, {
          name: this.name,
          value: this.val
        });

        return prop
      },

      formDomProps () {
        if (this.name !== void 0 && this.isTrue === true) {
          return { checked: true }
        }
      },

      attrs () {
        const attrs = {
          tabindex: this.computedTabindex,
          role: 'radio',
          'aria-label': this.label,
          'aria-checked': this.isTrue === true ? 'true' : 'false'
        };

        if (this.disable === true) {
          attrs['aria-disabled'] = 'true';
        }

        return attrs
      }
    },

    methods: {
      set (e) {
        if (e !== void 0) {
          stopAndPrevent(e);
          this.__refocusTarget(e);
        }

        if (this.disable !== true && this.isTrue !== true) {
          this.$emit('input', this.val, e);
        }
      }
    },

    render (h) {
      const content = this.computedIcon !== void 0
        ? [
          h('div', {
            key: 'icon',
            staticClass: 'q-radio__icon-container absolute-full flex flex-center no-wrap'
          }, [
            h(QIcon, {
              staticClass: 'q-radio__icon',
              props: { name: this.computedIcon }
            })
          ])
        ]
        : [
          h('svg', {
            key: 'svg',
            staticClass: 'q-radio__bg absolute non-selectable',
            attrs: { focusable: 'false' /* needed for IE11 */, viewBox: '0 0 24 24', 'aria-hidden': 'true' }
          }, [
            h('path', {
              attrs: {
                d: 'M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12'
              }
            }),

            h('path', {
              staticClass: 'q-radio__check',
              attrs: {
                d: 'M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6'
              }
            })
          ])
        ];

      this.disable !== true && this.__injectFormInput(
        content,
        'unshift',
        'q-radio__native q-ma-none q-pa-none'
      );

      const child = [
        h('div', {
          staticClass: 'q-radio__inner relative-position',
          class: this.innerClass,
          style: this.sizeStyle
        }, content)
      ];

      if (this.__refocusTargetEl !== void 0) {
        child.push(this.__refocusTargetEl);
      }

      const label = this.label !== void 0
        ? mergeSlot([ this.label ], this, 'default')
        : slot(this, 'default');

      label !== void 0 && child.push(
        h('div', {
          staticClass: 'q-radio__label q-anchor--skip'
        }, label)
      );

      return h('div', {
        class: this.classes,
        attrs: this.attrs,
        on: cache(this, 'inpExt', {
          click: this.set,
          keydown: e => {
            if (e.keyCode === 13 || e.keyCode === 32) {
              stopAndPrevent(e);
            }
          },
          keyup: e => {
            if (e.keyCode === 13 || e.keyCode === 32) {
              this.set(e);
            }
          }
        })
      }, child)
    }
  });

  var QToggle = Vue.extend({
    name: 'QToggle',

    mixins: [ CheckboxMixin ],

    props: {
      icon: String,

      iconColor: String
    },

    computed: {
      computedIcon () {
        return (
          this.isTrue === true
            ? this.checkedIcon
            : (this.isIndeterminate === true ? this.indeterminateIcon : this.uncheckedIcon)
        ) || this.icon
      },

      computedIconColor () {
        if (this.isTrue === true) {
          return this.iconColor
        }
      }
    },

    methods: {
      __getInner (h) {
        return [
          h('div', { staticClass: 'q-toggle__track' }),

          h('div', {
            staticClass: 'q-toggle__thumb absolute flex flex-center no-wrap'
          }, this.computedIcon !== void 0
            ? [
              h(QIcon, {
                props: {
                  name: this.computedIcon,
                  color: this.computedIconColor
                }
              })
            ]
            : void 0
          )
        ]
      }
    },

    created () {
      this.type = 'toggle';
    }
  });

  const components = {
    radio: QRadio,
    checkbox: QCheckbox,
    toggle: QToggle
  };

  const typeValues = Object.keys(components);

  var QOptionGroup = Vue.extend({
    name: 'QOptionGroup',

    mixins: [ DarkMixin, ListenersMixin ],

    props: {
      value: {
        required: true
      },
      options: {
        type: Array,
        validator (opts) {
          return opts.every(opt => 'value' in opt && 'label' in opt)
        }
      },

      name: String,

      type: {
        default: 'radio',
        validator: v => typeValues.includes(v)
      },

      color: String,
      keepColor: Boolean,
      dense: Boolean,

      size: String,

      leftLabel: Boolean,
      inline: Boolean,
      disable: Boolean
    },

    computed: {
      component () {
        return components[this.type]
      },

      model () {
        return Array.isArray(this.value)
          ? this.value.slice()
          : this.value
      },

      classes () {
        return 'q-option-group q-gutter-x-sm' +
          (this.inline === true ? ' q-option-group--inline' : '')
      },

      attrs () {
        if (this.type === 'radio') {
          const attrs = {
            role: 'radiogroup'
          };

          if (this.disable === true) {
            attrs['aria-disabled'] = 'true';
          }

          return attrs
        }
      }
    },

    methods: {
      __update (value) {
        this.$emit('input', value);
      }
    },

    created () {
      const isArray = Array.isArray(this.value);

      if (this.type === 'radio') {
        if (isArray) {
          console.error('q-option-group: model should not be array');
        }
      }
      else if (isArray === false) {
        console.error('q-option-group: model should be array in your case');
      }
    },

    render (h) {
      return h('div', {
        class: this.classes,
        attrs: this.attrs,
        on: { ...this.qListeners }
      }, this.options.map((opt, i) => {
        const child = this.$scopedSlots[ 'label-' + i ] !== void 0
          ? this.$scopedSlots[ 'label-' + i ](opt)
          : (
            this.$scopedSlots.label !== void 0
              ? this.$scopedSlots.label(opt)
              : void 0
          );

        return h('div', [
          h(this.component, {
            props: {
              value: this.value,
              val: opt.value,
              name: opt.name === void 0 ? this.name : opt.name,
              disable: this.disable || opt.disable,
              label: child === void 0 ? opt.label : void 0,
              leftLabel: opt.leftLabel === void 0 ? this.leftLabel : opt.leftLabel,
              color: opt.color === void 0 ? this.color : opt.color,
              checkedIcon: opt.checkedIcon,
              uncheckedIcon: opt.uncheckedIcon,
              dark: opt.dark || this.isDark,
              size: opt.size === void 0 ? this.size : opt.size,
              dense: this.dense,
              keepColor: opt.keepColor === void 0 ? this.keepColor : opt.keepColor
            },
            on: cache(this, 'inp', {
              input: this.__update
            })
          }, child)
        ])
      }))
    }
  });

  var QPage = Vue.extend({
    name: 'QPage',

    mixins: [ ListenersMixin ],

    inject: {
      pageContainer: {
        default () {
          console.error('QPage needs to be child of QPageContainer');
        }
      },
      layout: {}
    },

    props: {
      padding: Boolean,
      styleFn: Function
    },

    computed: {
      style () {
        const offset =
          (this.layout.header.space === true ? this.layout.header.size : 0) +
          (this.layout.footer.space === true ? this.layout.footer.size : 0);

        if (typeof this.styleFn === 'function') {
          const height = this.layout.container === true
            ? this.layout.containerHeight
            : this.$q.screen.height;

          return this.styleFn(offset, height)
        }

        return {
          minHeight: this.layout.container === true
            ? (this.layout.containerHeight - offset) + 'px'
            : (
              this.$q.screen.height === 0
                ? `calc(100vh - ${offset}px)`
                : (this.$q.screen.height - offset) + 'px'
            )
        }
      },

      classes () {
        if (this.padding === true) {
          return 'q-layout-padding'
        }
      }
    },

    render (h) {
      return h('main', {
        staticClass: 'q-page',
        style: this.style,
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var QPageContainer = Vue.extend({
    name: 'QPageContainer',

    mixins: [ ListenersMixin ],

    inject: {
      layout: {
        default () {
          console.error('QPageContainer needs to be child of QLayout');
        }
      }
    },

    provide: {
      pageContainer: true
    },

    computed: {
      style () {
        const css = {};

        if (this.layout.header.space === true) {
          css.paddingTop = `${this.layout.header.size}px`;
        }
        if (this.layout.right.space === true) {
          css[`padding${this.$q.lang.rtl === true ? 'Left' : 'Right'}`] = `${this.layout.right.size}px`;
        }
        if (this.layout.footer.space === true) {
          css.paddingBottom = `${this.layout.footer.size}px`;
        }
        if (this.layout.left.space === true) {
          css[`padding${this.$q.lang.rtl === true ? 'Right' : 'Left'}`] = `${this.layout.left.size}px`;
        }

        return css
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-page-container',
        style: this.style,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var QPageSticky = Vue.extend({
    name: 'QPageSticky',

    mixins: [ ListenersMixin ],

    inject: {
      layout: {
        default () {
          console.error('QPageSticky needs to be child of QLayout');
        }
      }
    },

    props: {
      position: {
        type: String,
        default: 'bottom-right',
        validator: v => [
          'top-right', 'top-left',
          'bottom-right', 'bottom-left',
          'top', 'right', 'bottom', 'left'
        ].includes(v)
      },
      offset: {
        type: Array,
        validator: v => v.length === 2
      },
      expand: Boolean
    },

    computed: {
      attach () {
        const pos = this.position;

        return {
          top: pos.indexOf('top') > -1,
          right: pos.indexOf('right') > -1,
          bottom: pos.indexOf('bottom') > -1,
          left: pos.indexOf('left') > -1,
          vertical: pos === 'top' || pos === 'bottom',
          horizontal: pos === 'left' || pos === 'right'
        }
      },

      top () {
        return this.layout.header.offset
      },

      right () {
        return this.layout.right.offset
      },

      bottom () {
        return this.layout.footer.offset
      },

      left () {
        return this.layout.left.offset
      },

      style () {
        let
          posX = 0,
          posY = 0;

        const
          attach = this.attach,
          dir = this.$q.lang.rtl === true ? -1 : 1;

        if (attach.top === true && this.top !== 0) {
          posY = `${this.top}px`;
        }
        else if (attach.bottom === true && this.bottom !== 0) {
          posY = `${-this.bottom}px`;
        }

        if (attach.left === true && this.left !== 0) {
          posX = `${dir * this.left}px`;
        }
        else if (attach.right === true && this.right !== 0) {
          posX = `${-dir * this.right}px`;
        }

        const css = { transform: `translate(${posX}, ${posY})` };

        if (this.offset) {
          css.margin = `${this.offset[1]}px ${this.offset[0]}px`;
        }

        if (attach.vertical === true) {
          if (this.left !== 0) {
            css[this.$q.lang.rtl === true ? 'right' : 'left'] = `${this.left}px`;
          }
          if (this.right !== 0) {
            css[this.$q.lang.rtl === true ? 'left' : 'right'] = `${this.right}px`;
          }
        }
        else if (attach.horizontal === true) {
          if (this.top !== 0) {
            css.top = `${this.top}px`;
          }
          if (this.bottom !== 0) {
            css.bottom = `${this.bottom}px`;
          }
        }

        return css
      },

      classes () {
        return `fixed-${this.position} q-page-sticky--${this.expand === true ? 'expand' : 'shrink'}`
      }
    },

    render (h) {
      const content = slot(this, 'default');

      return h('div', {
        staticClass: 'q-page-sticky row flex-center',
        class: this.classes,
        style: this.style,
        on: { ...this.qListeners }
      },
      this.expand === true
        ? content
        : [ h('div', content) ]
      )
    }
  });

  var QPageScroller = Vue.extend({
    name: 'QPageScroller',

    mixins: [ QPageSticky ],

    props: {
      scrollOffset: {
        type: Number,
        default: 1000
      },

      reverse: Boolean,

      duration: {
        type: Number,
        default: 300
      },

      offset: {
        default: () => [18, 18]
      }
    },

    inject: {
      layout: {
        default () {
          console.error('QPageScroller needs to be used within a QLayout');
        }
      }
    },

    data () {
      return {
        showing: this.__isVisible()
      }
    },

    computed: {
      scrollHeight () {
        return this.layout.height - (
          this.layout.container === true
            ? this.layout.containerHeight
            : this.$q.screen.height
        )
      },

      onEvents () {
        return {
          ...this.qListeners,
          click: this.__onClick
        }
      }
    },

    watch: {
      'layout.scroll.position' () {
        this.__updateVisibility();
      },

      reverse: {
        handler (val) {
          if (val === true) {
            if (this.heightWatcher === void 0) {
              this.heightWatcher = this.$watch('scrollHeight', this.__updateVisibility);
            }
          }
          else if (this.heightWatcher !== void 0) {
            this.__cleanup();
          }
        },
        immediate: true
      }
    },

    methods: {
      __isVisible () {
        return this.reverse === true
          ? this.scrollHeight - this.layout.scroll.position > this.scrollOffset
          : this.layout.scroll.position > this.scrollOffset
      },

      __onClick (e) {
        const target = getScrollTarget(this.layout.container === true ? this.$el : this.layout.$el);
        setScrollPosition(target, this.reverse === true ? this.layout.height : 0, this.duration);
        this.$emit('click', e);
      },

      __updateVisibility () {
        const newVal = this.__isVisible();
        if (this.showing !== newVal) {
          this.showing = newVal;
        }
      },

      __cleanup () {
        this.heightWatcher();
        this.heightWatcher = void 0;
      }
    },

    render (h) {
      return h('transition', {
        props: { name: 'q-transition--fade' }
      },
      this.showing === true
        ? [
          h('div', {
            staticClass: 'q-page-scroller',
            on: this.onEvents
          }, [
            QPageSticky.options.render.call(this, h)
          ])
        ]
        : null
      )
    },

    beforeDestroy () {
      this.heightWatcher !== void 0 && this.__cleanup();
    }
  });

  var QPagination = Vue.extend({
    name: 'QPagination',

    mixins: [ DarkMixin, ListenersMixin ],

    props: {
      value: {
        type: Number,
        required: true
      },
      min: {
        type: Number,
        default: 1
      },
      max: {
        type: Number,
        required: true
      },

      color: {
        type: String,
        default: 'primary'
      },
      textColor: String,

      activeColor: String,
      activeTextColor: String,

      inputStyle: [Array, String, Object],
      inputClass: [Array, String, Object],

      size: String,

      disable: Boolean,

      input: Boolean,

      iconPrev: String,
      iconNext: String,
      iconFirst: String,
      iconLast: String,

      toFn: Function,

      boundaryLinks: {
        type: Boolean,
        default: null
      },
      boundaryNumbers: {
        type: Boolean,
        default: null
      },
      directionLinks: {
        type: Boolean,
        default: null
      },
      ellipses: {
        type: Boolean,
        default: null
      },
      maxPages: {
        type: Number,
        default: 0,
        validator: v => v >= 0
      },

      ripple: {
        type: [Boolean, Object],
        default: null
      },

      round: Boolean,
      rounded: Boolean,

      flat: Boolean,
      outline: Boolean,
      unelevated: Boolean,
      push: Boolean,
      glossy: Boolean,

      dense: Boolean,
      padding: {
        type: String,
        default: '3px 2px'
      }
    },

    data () {
      return {
        newPage: null
      }
    },

    watch: {
      min () {
        this.model = this.value;
      },

      max () {
        this.model = this.value;
      }
    },

    computed: {
      model: {
        get () {
          return this.value
        },
        set (val) {
          val = parseInt(val, 10);
          if (this.disable || isNaN(val)) {
            return
          }
          const value = between(val, this.min, this.max);
          this.$emit('input', value);
        }
      },

      inputPlaceholder () {
        return this.model + ' / ' + this.max
      },

      __boundaryLinks () {
        return this.__getBool(this.boundaryLinks, this.input)
      },

      __boundaryNumbers () {
        return this.__getBool(this.boundaryNumbers, !this.input)
      },

      __directionLinks () {
        return this.__getBool(this.directionLinks, this.input)
      },

      __ellipses () {
        return this.__getBool(this.ellipses, !this.input)
      },

      icons () {
        const ico = [
          this.iconFirst || this.$q.iconSet.pagination.first,
          this.iconPrev || this.$q.iconSet.pagination.prev,
          this.iconNext || this.$q.iconSet.pagination.next,
          this.iconLast || this.$q.iconSet.pagination.last
        ];
        return this.$q.lang.rtl === true ? ico.reverse() : ico
      },

      attrs () {
        if (this.disable === true) {
          return {
            'aria-disabled': 'true'
          }
        }
      },

      btnProps () {
        return {
          round: this.round,
          rounded: this.rounded,

          outline: this.outline,
          unelevated: this.unelevated,
          push: this.push,
          glossy: this.glossy,

          dense: this.dense,
          padding: this.padding,

          color: this.color,
          flat: true,
          size: this.size,
          ripple: this.ripple !== null
            ? this.ripple
            : true
        }
      },

      activeBtnProps () {
        return {
          flat: this.flat,
          color: this.activeColor || this.color,
          textColor: this.activeTextColor || this.textColor
        }
      }
    },

    methods: {
      set (value) {
        this.model = value;
      },

      setByOffset (offset) {
        this.model = this.model + offset;
      },

      __update () {
        this.model = this.newPage;
        this.newPage = null;
      },

      __getBool (val, otherwise) {
        return [true, false].includes(val)
          ? val
          : otherwise
      },

      __getBtn (h, data, props, page) {
        data.props = {
          ...this.btnProps,
          ...props
        };

        if (page !== void 0) {
          if (this.toFn !== void 0) {
            data.props.to = this.toFn(page);
          }
          else {
            data.on = { click: () => this.set(page) };
          }
        }

        return h(QBtn, data)
      }
    },

    render (h) {
      const
        contentStart = [],
        contentEnd = [],
        contentMiddle = [];

      if (this.__boundaryLinks) {
        contentStart.push(this.__getBtn(h, {
          key: 'bls'
        }, {
          disable: this.disable || this.value <= this.min,
          icon: this.icons[0]
        }, this.min));
        contentEnd.unshift(this.__getBtn(h, {
          key: 'ble'
        }, {
          disable: this.disable || this.value >= this.max,
          icon: this.icons[3]
        }, this.max));
      }

      if (this.__directionLinks) {
        contentStart.push(this.__getBtn(h, {
          key: 'bdp'
        }, {
          disable: this.disable || this.value <= this.min,
          icon: this.icons[1]
        }, this.value - 1));
        contentEnd.unshift(this.__getBtn(h, {
          key: 'bdn'
        }, {
          disable: this.disable || this.value >= this.max,
          icon: this.icons[2]
        }, this.value + 1));
      }

      if (this.input === true) {
        contentMiddle.push(h(QInput, {
          staticClass: 'inline',
          style: {
            width: `${this.inputPlaceholder.length / 1.5}em`
          },
          props: {
            type: 'number',
            dense: true,
            value: this.newPage,
            disable: this.disable,
            dark: this.isDark,
            borderless: true,
            inputClass: this.inputClass,
            inputStyle: this.inputStyle
          },
          attrs: {
            placeholder: this.inputPlaceholder,
            min: this.min,
            max: this.max
          },
          on: cache(this, 'inp', {
            input: value => { this.newPage = value; },
            keyup: e => { isKeyCode(e, 13) === true && this.__update(); },
            blur: this.__update
          })
        }));
      }
      else { // is type select
        let
          maxPages = Math.max(
            this.maxPages,
            1 + (this.__ellipses ? 2 : 0) + (this.__boundaryNumbers ? 2 : 0)
          ),
          pgFrom = this.min,
          pgTo = this.max,
          ellipsesStart = false,
          ellipsesEnd = false,
          boundaryStart = false,
          boundaryEnd = false;

        if (this.maxPages && maxPages < (this.max - this.min + 1)) {
          maxPages = 1 + Math.floor(maxPages / 2) * 2;
          pgFrom = Math.max(this.min, Math.min(this.max - maxPages + 1, this.value - Math.floor(maxPages / 2)));
          pgTo = Math.min(this.max, pgFrom + maxPages - 1);
          if (this.__boundaryNumbers) {
            boundaryStart = true;
            pgFrom += 1;
          }
          if (this.__ellipses && pgFrom > (this.min + (this.__boundaryNumbers ? 1 : 0))) {
            ellipsesStart = true;
            pgFrom += 1;
          }
          if (this.__boundaryNumbers) {
            boundaryEnd = true;
            pgTo -= 1;
          }
          if (this.__ellipses && pgTo < (this.max - (this.__boundaryNumbers ? 1 : 0))) {
            ellipsesEnd = true;
            pgTo -= 1;
          }
        }
        const style = {
          minWidth: `${Math.max(2, String(this.max).length)}em`
        };
        if (boundaryStart) {
          const active = this.min === this.value;
          const btn = {
            disable: this.disable,
            flat: !active,
            label: this.min
          };

          if (active) {
            btn.color = this.activeColor || this.color;
            btn.textColor = this.activeTextColor || this.textColor;
          }

          contentStart.push(this.__getBtn(h, {
            key: 'bns',
            style
          }, btn, this.min));
        }
        if (boundaryEnd) {
          const active = this.max === this.value;
          const btn = {
            disable: this.disable,
            flat: !active,
            label: this.max
          };

          if (active) {
            btn.color = this.activeColor || this.color;
            btn.textColor = this.activeTextColor || this.textColor;
          }

          contentEnd.unshift(this.__getBtn(h, {
            key: 'bne',
            style
          }, btn, this.max));
        }
        if (ellipsesStart) {
          contentStart.push(this.__getBtn(h, {
            key: 'bes',
            style
          }, {
            disable: this.disable,
            label: '',
            ripple: false
          }, pgFrom - 1));
        }
        if (ellipsesEnd) {
          contentEnd.unshift(this.__getBtn(h, {
            key: 'bee',
            style
          }, {
            disable: this.disable,
            label: '',
            ripple: false
          }, pgTo + 1));
        }
        for (let i = pgFrom; i <= pgTo; i++) {
          const btn = {
            disable: this.disable,
            flat: true,
            label: i
          };

          if (i === this.value) {
            Object.assign(btn, this.activeBtnProps);
          }

          contentMiddle.push(this.__getBtn(h, {
            key: `bpg${i}`,
            style
          }, btn, i));
        }
      }

      return h('div', {
        staticClass: 'q-pagination row no-wrap items-center',
        class: { disabled: this.disable },
        attrs: this.attrs,
        on: { ...this.qListeners }
      }, [
        contentStart,

        h('div', {
          staticClass: 'row justify-center',
          on: this.input === true
            ? cache(this, 'stop', { input: stop })
            : null
        }, [
          contentMiddle
        ]),

        contentEnd
      ])
    }
  });

  function frameDebounce (fn) {
    let wait = false, frame, callArgs;

    function debounced (/* ...args */) {
      callArgs = arguments;
      if (wait === true) { return }

      wait = true;
      frame = requestAnimationFrame(() => {
        fn.apply(this, callArgs);
        callArgs = void 0;
        wait = false;
      });
    }

    debounced.cancel = () => {
      window.cancelAnimationFrame(frame);
      wait = false;
    };

    return debounced
  }

  const { passive: passive$3 } = listenOpts;

  var QParallax = Vue.extend({
    name: 'QParallax',

    mixins: [ ListenersMixin ],

    props: {
      src: String,
      height: {
        type: Number,
        default: 500
      },
      speed: {
        type: Number,
        default: 1,
        validator: v => v >= 0 && v <= 1
      },

      scrollTarget: {
        default: void 0
      }
    },

    data () {
      return {
        scrolling: false,
        percentScrolled: 0
      }
    },

    watch: {
      height () {
        this.working === true && this.__updatePos();
      },

      scrollTarget () {
        if (this.working === true) {
          this.__stop();
          this.__start();
        }
      }
    },

    methods: {
      __update (percentage) {
        this.percentScrolled = percentage;
        this.qListeners.scroll !== void 0 && this.$emit('scroll', percentage);
      },

      __updatePos () {
        let containerTop, containerHeight, containerBottom;

        if (this.__scrollTarget === window) {
          containerTop = 0;
          containerHeight = window.innerHeight;
          containerBottom = containerHeight;
        }
        else {
          containerTop = offset(this.__scrollTarget).top;
          containerHeight = height(this.__scrollTarget);
          containerBottom = containerTop + containerHeight;
        }

        const top = offset(this.$el).top;
        const bottom = top + this.height;

        if (this.observer !== void 0 || (bottom > containerTop && top < containerBottom)) {
          const percent = (containerBottom - top) / (this.height + containerHeight);
          this.__setPos((this.mediaHeight - this.height) * percent * this.speed);
          this.__update(percent);
        }
      },

      __setPos (offset) {
        // apply it immediately without any delay
        this.media.style.transform = `translate3d(-50%,${Math.round(offset)}px,0)`;
      },

      __onResize () {
        this.mediaHeight = this.media.naturalHeight || this.media.videoHeight || height(this.media);
        this.working === true && this.__updatePos();
      },

      __start () {
        this.working = true;
        this.__scrollTarget = getScrollTarget(this.$el, this.scrollTarget);
        this.__scrollTarget.addEventListener('scroll', this.__updatePos, passive$3);
        window.addEventListener('resize', this.__resizeHandler, passive$3);
        this.__updatePos();
      },

      __stop () {
        if (this.working === true) {
          this.working = false;
          this.__setPos.cancel();
          this.__update.cancel();
          this.__resizeHandler.cancel();
          this.__scrollTarget.removeEventListener('scroll', this.__updatePos, passive$3);
          window.removeEventListener('resize', this.__resizeHandler, passive$3);
          this.__scrollTarget = void 0;
        }
      }
    },

    render (h) {
      return h('div', {
        staticClass: 'q-parallax',
        style: { height: `${this.height}px` },
        on: { ...this.qListeners }
      }, [
        h('div', {
          ref: 'mediaParent',
          staticClass: 'q-parallax__media absolute-full'
        }, this.$scopedSlots.media !== void 0 ? this.$scopedSlots.media() : [
          h('img', {
            ref: 'media',
            attrs: {
              src: this.src
            }
          })
        ]),

        h(
          'div',
          { staticClass: 'q-parallax__content absolute-full column flex-center' },
          this.$scopedSlots.content !== void 0
            ? this.$scopedSlots.content({ percentScrolled: this.percentScrolled })
            : slot(this, 'default')
        )
      ])
    },

    mounted () {
      this.__setPos = frameDebounce(this.__setPos);
      this.__update = frameDebounce(this.__update);
      this.__resizeHandler = frameDebounce(this.__onResize);

      this.media = this.$scopedSlots.media !== void 0
        ? this.$refs.mediaParent.children[0]
        : this.$refs.media;

      this.media.onload = this.media.onloadstart = this.media.loadedmetadata = this.__onResize;
      this.__onResize();
      this.media.style.display = 'initial';

      if (window.IntersectionObserver !== void 0) {
        this.observer = new IntersectionObserver(entries => {
          this[entries[0].isIntersecting === true ? '__start' : '__stop']();
        });

        this.observer.observe(this.$el);
      }
      else {
        this.__start();
      }
    },

    beforeDestroy () {
      this.__stop();
      this.observer !== void 0 && this.observer.disconnect();
      this.media.onload = this.media.onloadstart = this.media.loadedmetadata = null;
    }
  });

  // adapted from https://stackoverflow.com/a/40294058

  function cloneDeep (data, hash = new WeakMap()) {
    if (Object(data) !== data) return data
    if (hash.has(data)) return hash.get(data)

    const result = data instanceof Date
      ? new Date(data)
      : (data instanceof RegExp
        ? new RegExp(data.source, data.flags)
        : (data instanceof Set
          ? new Set()
          : (data instanceof Map
            ? new Map()
            : (typeof data.constructor !== 'function'
              ? Object.create(null)
              : (data.prototype !== void 0 && typeof data.prototype.constructor === 'function'
                ? data
                : new data.constructor()
              )
            )
          )
        )
      );

    if (typeof data.constructor === 'function' && typeof data.valueOf === 'function') {
      const val = data.valueOf();

      if (Object(val) !== val) {
        const result = new data.constructor(val);

        hash.set(data, result);

        return result
      }
    }

    hash.set(data, result);

    if (data instanceof Set) {
      data.forEach(val => {
        result.add(cloneDeep(val, hash));
      });
    }
    else if (data instanceof Map) {
      data.forEach((val, key) => {
        result.set(key, cloneDeep(val, hash));
      });
    }

    return Object.assign(
      result,
      ...Object.keys(data).map(key => ({ [key]: cloneDeep(data[key], hash) }))
    )
  }

  var QPopupEdit = Vue.extend({
    name: 'QPopupEdit',

    mixins: [ AttrsMixin ],

    props: {
      value: {
        required: true
      },
      title: String,
      buttons: Boolean,
      labelSet: String,
      labelCancel: String,

      color: {
        type: String,
        default: 'primary'
      },
      validate: {
        type: Function,
        default: () => true
      },

      autoSave: Boolean,

      /* menu props overrides */
      cover: {
        type: Boolean,
        default: true
      },
      contentClass: String,
      /* end of menu props */

      disable: Boolean
    },

    data () {
      return {
        modelChanged: false,
        model: null
      }
    },

    computed: {
      classes () {
        return 'q-popup-edit' +
          (this.contentClass !== void 0 ? ` ${this.contentClass}` : '')
      },

      modelValue () {
        return this.modelChanged === true ? this.model : this.value
      },

      initialValue () {
        return this.modelChanged !== true ? this.model : this.value
      },

      defaultSlotScope () {
        const acc = {
          initialValue: this.initialValue,
          updatePosition: this.__reposition,
          emitValue: this.__changeModel,
          validate: this.validate,
          set: this.set,
          cancel: this.cancel
        };

        Object.defineProperty(acc, 'value', {
          get: () => this.modelValue,
          set: this.__changeModel
        });

        return acc
      },

      menuProps () {
        return {
          ...this.qAttrs,
          cover: this.cover,
          contentClass: this.classes
        }
      }
    },

    methods: {
      set () {
        if (this.validate(this.modelValue) !== true) {
          return
        }
        if (this.__hasChanged() === true) {
          this.$emit('save', this.modelValue, this.initialValue);
          this.modelChanged === true && this.$emit('input', this.modelValue);
        }
        this.__close();
      },

      cancel () {
        if (this.__hasChanged() === true) {
          this.$emit('cancel', this.modelValue, this.initialValue);
          this.modelChanged !== true && this.$emit('input', this.initialValue);
        }
        this.__close();
      },

      show (e) {
        this.$refs.menu !== void 0 && this.$refs.menu.show(e);
      },

      hide (e) {
        this.$refs.menu !== void 0 && this.$refs.menu.hide(e);
      },

      __hasChanged () {
        return isDeepEqual(this.modelValue, this.initialValue) === false
      },

      __changeModel (val) {
        if (this.disable !== true) {
          this.model = val;
          this.modelChanged = true;
        }
      },

      __close () {
        this.validated = true;
        this.$refs.menu.showing === true && this.$refs.menu.hide();
      },

      __reposition () {
        this.$nextTick(() => {
          this.$refs.menu.updatePosition();
        });
      },

      __getContent (h) {
        const
          title = slot(this, 'title', this.title),
          child = this.$scopedSlots.default === void 0
            ? []
            : [].concat(this.$scopedSlots.default(this.defaultSlotScope));

        title && child.unshift(
          h('div', { staticClass: 'q-dialog__title q-mt-sm q-mb-sm' }, [ title ])
        );

        this.buttons === true && child.push(
          h('div', { staticClass: 'q-popup-edit__buttons row justify-center no-wrap' }, [
            h(QBtn, {
              props: {
                flat: true,
                color: this.color,
                label: this.labelCancel || this.$q.lang.label.cancel
              },
              on: cache(this, 'cancel', { click: this.cancel })
            }),
            h(QBtn, {
              props: {
                flat: true,
                color: this.color,
                label: this.labelSet || this.$q.lang.label.set
              },
              on: cache(this, 'ok', { click: this.set })
            })
          ])
        );

        return child
      }
    },

    render (h) {
      if (this.disable === true) { return }

      return h(QMenu, {
        ref: 'menu',
        props: this.menuProps,
        on: cache(this, 'menu', {
          'before-show': () => {
            this.validated = false;
            this.modelChanged = false;
            this.model = cloneDeep(this.value);
            this.watcher = this.$watch('value', this.__reposition);
            this.$emit('before-show');
          },

          show: () => {
            this.$emit('show');
          },

          'escape-key': this.cancel,

          'before-hide': () => {
            this.watcher();

            if (this.validated === false && this.__hasChanged() === true) {
              if (this.autoSave === true && this.validate(this.model) === true) {
                this.$emit('save', this.modelValue, this.initialValue);
                this.modelChanged === true && this.$emit('input', this.modelValue);
              }
              else {
                this.$emit('cancel', this.modelValue, this.initialValue);
                this.modelChanged !== true && this.$emit('input', this.initialValue);
              }
            }

            this.$emit('before-hide');
          },

          hide: () => {
            this.$emit('hide');
          },

          keyup: e => {
            isKeyCode(e, 13) === true && this.set();
          }
        })
      }, this.__getContent(h))
    }
  });

  var QPopupProxy = Vue.extend({
    name: 'QPopupProxy',

    mixins: [ AttrsMixin, ListenersMixin, AnchorMixin ],

    props: {
      breakpoint: {
        type: [String, Number],
        default: 450
      }
    },

    data () {
      const breakpoint = parseInt(this.breakpoint, 10);
      return {
        type: this.$q.screen.width < breakpoint || this.$q.screen.height < breakpoint
          ? 'dialog'
          : 'menu'
      }
    },

    computed: {
      parsedBreakpoint () {
        return parseInt(this.breakpoint, 10)
      },

      onEvents () {
        return {
          ...this.qListeners,
          hide: this.__onHide
        }
      }
    },

    watch: {
      '$q.screen.width' (width) {
        if (this.$refs.popup.showing !== true) {
          this.__updateType(width, this.$q.screen.height, this.parsedBreakpoint);
        }
      },

      '$q.screen.height' (height) {
        if (this.$refs.popup.showing !== true) {
          this.__updateType(this.$q.screen.width, height, this.parsedBreakpoint);
        }
      },

      breakpoint (breakpoint) {
        if (this.$refs.popup.showing !== true) {
          this.__updateType(this.$q.screen.width, this.$q.screen.height, parseInt(breakpoint, 10));
        }
      }
    },

    methods: {
      toggle (evt) {
        this.$refs.popup.toggle(evt);
      },

      show (evt) {
        this.$refs.popup.show(evt);
      },

      hide (evt) {
        this.$refs.popup.hide(evt);
      },

      __onHide (evt) {
        this.__updateType(this.$q.screen.width, this.$q.screen.height, this.parsedBreakpoint);
        this.$emit('hide', evt);
      },

      __updateType (width, height, breakpoint) {
        const type = width < breakpoint || height < breakpoint
          ? 'dialog'
          : 'menu';

        if (this.type !== type) {
          this.type = type;
        }
      }
    },

    render (h) {
      const def = slot(this, 'default');

      const props = (
        this.type === 'menu' &&
        def !== void 0 &&
        def[0] !== void 0 &&
        def[0].componentOptions !== void 0 &&
        def[0].componentOptions.Ctor !== void 0 &&
        def[0].componentOptions.Ctor.sealedOptions !== void 0 &&
        ['QDate', 'QTime', 'QCarousel', 'QColor'].includes(
          def[0].componentOptions.Ctor.sealedOptions.name
        )
      ) ? { cover: true, maxHeight: '99vh' } : {};

      const data = {
        ref: 'popup',
        props: { ...props, ...this.qAttrs },
        on: this.onEvents
      };

      let component;

      if (this.type === 'dialog') {
        component = QDialog;
      }
      else {
        component = QMenu;
        data.props.target = this.target;
        data.props.contextMenu = this.contextMenu;
        data.props.noParentEvent = true;
        data.props.separateClosePopup = true;
      }

      return h(component, data, def)
    }
  });

  function width$1 (val, reverse, $q) {
    return {
      transform: reverse === true
        ? `translateX(${$q.lang.rtl === true ? '-' : ''}100%) scale3d(${-val},1,1)`
        : `scale3d(${val},1,1)`
    }
  }

  var QLinearProgress = Vue.extend({
    name: 'QLinearProgress',

    mixins: [
      ListenersMixin,
      DarkMixin,
      getSizeMixin({
        xs: 2,
        sm: 4,
        md: 6,
        lg: 10,
        xl: 14
      })
    ],

    props: {
      value: {
        type: Number,
        default: 0
      },
      buffer: Number,

      color: String,
      trackColor: String,

      reverse: Boolean,
      stripe: Boolean,
      indeterminate: Boolean,
      query: Boolean,
      rounded: Boolean,

      instantFeedback: Boolean
    },

    computed: {
      motion () {
        return this.indeterminate === true || this.query === true
      },

      widthReverse () {
        return this.reverse !== this.query
      },

      classes () {
        return 'q-linear-progress' +
          (this.color !== void 0 ? ` text-${this.color}` : '') +
          (this.reverse === true || this.query === true ? ' q-linear-progress--reverse' : '') +
          (this.rounded === true ? ' rounded-borders' : '')
      },

      trackStyle () {
        return width$1(this.buffer !== void 0 ? this.buffer : 1, this.widthReverse, this.$q)
      },

      trackClass () {
        return `q-linear-progress__track--with${this.instantFeedback === true ? 'out' : ''}-transition` +
          ` q-linear-progress__track--${this.isDark === true ? 'dark' : 'light'}` +
          (this.trackColor !== void 0 ? ` bg-${this.trackColor}` : '')
      },

      modelStyle () {
        return width$1(this.motion === true ? 1 : this.value, this.widthReverse, this.$q)
      },

      modelClasses () {
        return `q-linear-progress__model--with${this.instantFeedback === true ? 'out' : ''}-transition` +
          ` q-linear-progress__model--${this.motion === true ? 'in' : ''}determinate`
      },

      stripeStyle () {
        return { width: (this.value * 100) + '%' }
      },

      stripeClass () {
        return this.reverse === true ? 'absolute-right' : 'absolute-left'
      },

      attrs () {
        return {
          role: 'progressbar',
          'aria-valuemin': 0,
          'aria-valuemax': 1,
          'aria-valuenow': this.indeterminate === true ? void 0 : this.value
        }
      }
    },

    render (h) {
      const child = [
        h('div', {
          staticClass: 'q-linear-progress__track absolute-full',
          style: this.trackStyle,
          class: this.trackClass
        }),

        h('div', {
          staticClass: 'q-linear-progress__model absolute-full',
          style: this.modelStyle,
          class: this.modelClasses
        })
      ];

      this.stripe === true && this.motion === false && child.push(
        h('div', {
          staticClass: 'q-linear-progress__stripe',
          style: this.stripeStyle,
          class: this.stripeClass
        })
      );

      return h('div', {
        style: this.sizeStyle,
        class: this.classes,
        attrs: this.attrs,
        on: { ...this.qListeners }
      }, mergeSlot(child, this, 'default'))
    }
  });

  const
    PULLER_HEIGHT = 40,
    OFFSET_TOP = 20;

  var QPullToRefresh = Vue.extend({
    name: 'QPullToRefresh',

    mixins: [ ListenersMixin ],

    directives: {
      TouchPan
    },

    props: {
      color: String,
      bgColor: String,
      icon: String,
      noMouse: Boolean,
      disable: Boolean,

      scrollTarget: {
        default: void 0
      }
    },

    data () {
      return {
        state: 'pull',
        pullRatio: 0,
        pulling: false,
        pullPosition: -PULLER_HEIGHT,
        animating: false,
        positionCSS: {}
      }
    },

    computed: {
      style () {
        return {
          opacity: this.pullRatio,
          transform: `translateY(${this.pullPosition}px) rotate(${this.pullRatio * 360}deg)`
        }
      },

      classes () {
        return 'q-pull-to-refresh__puller row flex-center' +
          (this.animating === true ? ' q-pull-to-refresh__puller--animating' : '') +
          (this.bgColor !== void 0 ? ` bg-${this.bgColor}` : '')
      },

      directives () {
        if (this.disable !== true) {
          const modifiers = {
            down: true,
            mightPrevent: true
          };

          if (this.noMouse !== true) {
            modifiers.mouse = true;
          }

          return [{
            name: 'touch-pan',
            modifiers,
            value: this.__pull
          }]
        }
      },

      contentClass () {
        return `q-pull-to-refresh__content${this.pulling === true ? ' no-pointer-events' : ''}`
      }
    },

    watch: {
      scrollTarget () {
        this.updateScrollTarget();
      }
    },

    methods: {
      trigger () {
        this.$emit('refresh', () => {
          this.__animateTo({ pos: -PULLER_HEIGHT, ratio: 0 }, () => {
            this.state = 'pull';
          });
        });
      },

      updateScrollTarget () {
        this.__scrollTarget = getScrollTarget(this.$el, this.scrollTarget);
      },

      __pull (event) {
        if (event.isFinal === true) {
          if (this.pulling === true) {
            this.pulling = false;

            if (this.state === 'pulled') {
              this.state = 'refreshing';
              this.__animateTo({ pos: OFFSET_TOP });
              this.trigger();
            }
            else if (this.state === 'pull') {
              this.__animateTo({ pos: -PULLER_HEIGHT, ratio: 0 });
            }
          }

          return
        }

        if (this.animating === true || this.state === 'refreshing') {
          return false
        }

        if (event.isFirst === true) {
          if (getScrollPosition(this.__scrollTarget) !== 0 || event.direction !== 'down') {
            if (this.pulling === true) {
              this.pulling = false;
              this.state = 'pull';
              this.__animateTo({ pos: -PULLER_HEIGHT, ratio: 0 });
            }

            return false
          }

          this.pulling = true;

          const { top, left } = this.$el.getBoundingClientRect();
          this.positionCSS = {
            top: top + 'px',
            left: left + 'px',
            width: window.getComputedStyle(this.$el).getPropertyValue('width')
          };
        }

        prevent(event.evt);

        const distance = Math.min(140, Math.max(0, event.distance.y));
        this.pullPosition = distance - PULLER_HEIGHT;
        this.pullRatio = between(distance / (OFFSET_TOP + PULLER_HEIGHT), 0, 1);

        const state = this.pullPosition > OFFSET_TOP ? 'pulled' : 'pull';

        if (this.state !== state) {
          this.state = state;
        }
      },

      __animateTo ({ pos, ratio }, done) {
        this.animating = true;
        this.pullPosition = pos;

        if (ratio !== void 0) {
          this.pullRatio = ratio;
        }

        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          this.animating = false;
          done && done();
        }, 300);
      }
    },

    mounted () {
      this.updateScrollTarget();
    },

    beforeDestroy () {
      clearTimeout(this.timer);
    },

    render (h) {
      return h('div', {
        staticClass: 'q-pull-to-refresh',
        on: { ...this.qListeners },
        directives: this.directives
      }, [
        h('div', {
          class: this.contentClass
        }, slot(this, 'default')),

        h('div', {
          staticClass: 'q-pull-to-refresh__puller-container fixed row flex-center no-pointer-events z-top',
          style: this.positionCSS
        }, [
          h('div', {
            style: this.style,
            class: this.classes
          }, [
            this.state !== 'refreshing'
              ? h(QIcon, {
                props: {
                  name: this.icon || this.$q.iconSet.pullToRefresh.icon,
                  color: this.color,
                  size: '32px'
                }
              })
              : h(QSpinner, {
                props: {
                  size: '24px',
                  color: this.color
                }
              })
          ])
        ])
      ])
    }
  });

  const dragType = {
    MIN: 0,
    RANGE: 1,
    MAX: 2
  };

  var QRange = Vue.extend({
    name: 'QRange',

    mixins: [ SliderMixin ],

    props: {
      value: {
        type: Object,
        default: () => ({ min: null, max: null }),
        validator: v => 'min' in v && 'max' in v
      },

      dragRange: Boolean,
      dragOnlyRange: Boolean,

      leftLabelColor: String,
      leftLabelTextColor: String,
      rightLabelColor: String,
      rightLabelTextColor: String,

      leftLabelValue: [ String, Number ],
      rightLabelValue: [ String, Number ],

      leftThumbColor: String,
      rightThumbColor: String
    },

    data () {
      const innerMin = this.__getInnerMin(this.innerMin);
      const innerMax = this.__getInnerMax(this.innerMax);
      return {
        model: {
          min: this.value.min === null ? innerMin : between(this.value.min, innerMin, innerMax),
          max: this.value.max === null ? innerMax : between(this.value.max, innerMin, innerMax)
        },
        curMinRatio: 0,
        curMaxRatio: 0
      }
    },

    computed: {
      modelMinRatio () {
        return this.__convertModelToRatio(this.model.min)
      },
      modelMaxRatio () {
        return this.__convertModelToRatio(this.model.max)
      },

      ratioMin () {
        return this.active === true ? this.curMinRatio : this.modelMinRatio
      },
      ratioMax () {
        return this.active === true ? this.curMaxRatio : this.modelMaxRatio
      },

      selectionBarStyle () {
        const acc = {
          [ this.positionProp ]: `${100 * this.ratioMin}%`,
          [ this.sizeProp ]: `${100 * (this.ratioMax - this.ratioMin)}%`
        };
        if (this.selectionImg !== void 0) {
          acc.backgroundImage = `url(${this.selectionImg}) !important`;
        }
        return acc
      },

      trackContainerEvents () {
        if (this.editable !== true) {
          return {}
        }

        if (this.$q.platform.is.mobile === true) {
          return { click: this.__onMobileClick }
        }

        const evt = { mousedown: this.__onActivate };

        if (this.dragRange === true || this.dragOnlyRange === true) {
          Object.assign(evt, {
            focus: () => { this.focus = 'both'; },
            blur: this.__onBlur,
            keydown: this.__onKeydown,
            keyup: this.__onKeyup
          });
        }

        return evt
      },

      trackContainerAttrs () {
        return {
          tabindex: this.$q.platform.is.mobile !== true && (this.dragRange || this.dragOnlyRange === true)
            ? this.computedTabindex
            : null
        }
      },

      thumbAttrs () {
        return {
          tabindex: this.dragOnlyRange !== true ? this.computedTabindex : null
        }
      },

      thumbMinEvents () {
        return this.__getEvents('min')
      },
      thumbMaxEvents () {
        return this.__getEvents('max')
      },

      thumbMinLabel () {
        return this.leftLabelValue !== void 0
          ? this.leftLabelValue
          : this.model.min
      },
      thumbMaxLabel () {
        return this.rightLabelValue !== void 0
          ? this.rightLabelValue
          : this.model.max
      },

      thumbMinClasses () {
        const color = this.leftThumbColor || this.thumbColor || this.color;
        return `q-slider__thumb q-slider__thumb${this.axis} q-slider__thumb${this.axis}-${this.isReversed === true ? 'rtl' : 'ltr'} absolute non-selectable` +
          (
            this.preventFocus === false && (this.focus === 'min' || this.focus === 'both')
              ? ' q-slider--focus'
              : ''
          ) +
          (color !== void 0 ? ` text-${color}` : '')
      },
      thumbMaxClasses () {
        const color = this.rightThumbColor || this.thumbColor || this.color;
        return `q-slider__thumb q-slider__thumb${this.axis} q-slider__thumb${this.axis}-${this.isReversed === true ? 'rtl' : 'ltr'} absolute non-selectable` +
          (
            this.preventFocus === false && (this.focus === 'max' || this.focus === 'both')
              ? ' q-slider--focus'
              : ''
          ) +
          (color !== void 0 ? ` text-${color}` : '')
      },

      thumbMinStyle () {
        return {
          width: this.thumbSize,
          height: this.thumbSize,
          [ this.positionProp ]: `${100 * this.ratioMin}%`,
          zIndex: this.focus === 'min' ? 2 : void 0
        }
      },
      thumbMaxStyle () {
        return {
          width: this.thumbSize,
          height: this.thumbSize,
          [ this.positionProp ]: `${100 * this.ratioMax}%`,
          zIndex: this.focus === 'max' ? 2 : void 0
        }
      },

      thumbMinPinColor () {
        const color = this.leftLabelColor || this.labelColor;
        return color !== void 0
          ? ` text-${color}`
          : ''
      },
      thumbMaxPinColor () {
        const color = this.rightLabelColor || this.labelColor;
        return color !== void 0
          ? ` text-${color}`
          : ''
      },

      thumbMinTextContainerStyle () {
        return this.__getTextContainerStyle(this.ratioMin)
      },
      thumbMaxTextContainerStyle () {
        return this.__getTextContainerStyle(this.ratioMax)
      },

      thumbMinTextClass () {
        const color = this.leftLabelTextColor || this.labelTextColor;
        return 'q-slider__text' +
          (color !== void 0 ? ` text-${color}` : '')
      },
      thumbMaxTextClass () {
        const color = this.rightLabelTextColor || this.labelTextColor;
        return 'q-slider__text' +
          (color !== void 0 ? ` text-${color}` : '')
      },

      formAttrs () {
        return {
          type: 'hidden',
          name: this.name,
          value: `${this.value.min}|${this.value.max}`
        }
      },

      modelUpdate () {
        return `${this.value.min}|${this.value.max}|${this.computedInnerMin}|${this.computedInnerMax}`
      }
    },

    watch: {
      modelUpdate () {
        this.model.min = this.value.min === null
          ? this.computedInnerMin
          : between(this.value.min, this.computedInnerMin, this.computedInnerMax);

        this.model.max = this.value.max === null
          ? this.computedInnerMax
          : between(this.value.max, this.computedInnerMin, this.computedInnerMax);
      }
    },

    methods: {
      __updateValue (change) {
        if (this.model.min !== this.value.min || this.model.max !== this.value.max) {
          this.$emit('input', { ...this.model });
        }
        change === true && this.$emit('change', { ...this.model });
      },

      __getDragging (event) {
        const
          { left, top, width, height } = this.$el.getBoundingClientRect(),
          sensitivity = this.dragOnlyRange === true
            ? 0
            : (
              this.vertical === true
                ? this.$refs.minThumb.offsetHeight / (2 * height)
                : this.$refs.minThumb.offsetWidth / (2 * width)
            );

        const dragging = {
          left,
          top,
          width,
          height,
          valueMin: this.model.min,
          valueMax: this.model.max,
          ratioMin: this.modelMinRatio,
          ratioMax: this.modelMaxRatio
        };

        const ratio = this.__getDraggingRatio(event, dragging);

        if (this.dragOnlyRange !== true && ratio < dragging.ratioMin + sensitivity) {
          dragging.type = dragType.MIN;
        }
        else if (this.dragOnlyRange === true || ratio < dragging.ratioMax - sensitivity) {
          if (this.dragRange === true || this.dragOnlyRange === true) {
            dragging.type = dragType.RANGE;
            Object.assign(dragging, {
              offsetRatio: ratio,
              offsetModel: this.__convertRatioToModel(ratio),
              rangeValue: dragging.valueMax - dragging.valueMin,
              rangeRatio: dragging.ratioMax - dragging.ratioMin
            });
          }
          else {
            dragging.type = dragging.ratioMax - ratio < ratio - dragging.ratioMin
              ? dragType.MAX
              : dragType.MIN;
          }
        }
        else {
          dragging.type = dragType.MAX;
        }

        return dragging
      },

      __updatePosition (event, dragging = this.dragging) {
        let pos;
        const ratio = this.__getDraggingRatio(event, dragging);
        const localModel = this.__convertRatioToModel(ratio);

        switch (dragging.type) {
          case dragType.MIN:
            if (ratio <= dragging.ratioMax) {
              pos = {
                minR: ratio,
                maxR: dragging.ratioMax,
                min: localModel,
                max: dragging.valueMax
              };
              this.focus = 'min';
            }
            else {
              pos = {
                minR: dragging.ratioMax,
                maxR: ratio,
                min: dragging.valueMax,
                max: localModel
              };
              this.focus = 'max';
            }
            break

          case dragType.MAX:
            if (ratio >= dragging.ratioMin) {
              pos = {
                minR: dragging.ratioMin,
                maxR: ratio,
                min: dragging.valueMin,
                max: localModel
              };
              this.focus = 'max';
            }
            else {
              pos = {
                minR: ratio,
                maxR: dragging.ratioMin,
                min: localModel,
                max: dragging.valueMin
              };
              this.focus = 'min';
            }
            break

          case dragType.RANGE:
            const
              ratioDelta = ratio - dragging.offsetRatio,
              minR = between(dragging.ratioMin + ratioDelta, 0, 1 - dragging.rangeRatio),
              modelDelta = localModel - dragging.offsetModel,
              min = between(dragging.valueMin + modelDelta, this.min, this.max - dragging.rangeValue);

            pos = {
              minR,
              maxR: minR + dragging.rangeRatio,
              min: parseFloat(min.toFixed(this.computedDecimals)),
              max: parseFloat((min + dragging.rangeValue).toFixed(this.computedDecimals))
            };

            this.focus = 'both';
            break
        }

        // If either of the values to be emitted are null, set them to the defaults the user has entered.
        this.model = this.model.min === null || this.model.max === null
          ? { min: pos.min || this.min, max: pos.max || this.max }
          : { min: pos.min, max: pos.max };

        if (this.snap !== true || this.step === 0) {
          this.curMinRatio = pos.minR;
          this.curMaxRatio = pos.maxR;
        }
        else {
          this.curMinRatio = this.__convertModelToRatio(this.model.min);
          this.curMaxRatio = this.__convertModelToRatio(this.model.max);
        }
      },

      __getEvents (side) {
        return this.$q.platform.is.mobile !== true && this.editable === true && this.dragOnlyRange !== true
          ? {
            focus: () => { this.focus = side; },
            blur: this.__onBlur,
            keydown: this.__onKeydown,
            keyup: this.__onKeyup
          }
          : {}
      },

      __onKeydown (evt) {
        if (!keyCodes.includes(evt.keyCode)) {
          return
        }

        stopAndPrevent(evt);

        const
          stepVal = ([ 34, 33 ].includes(evt.keyCode) ? 10 : 1) * this.computedStep,
          offset = ([ 34, 37, 40 ].includes(evt.keyCode) ? -1 : 1) * (this.isReversed === true ? -1 : 1) * stepVal;

        if (this.focus === 'both') {
          const interval = this.model.max - this.model.min;
          const min = between(
            parseFloat((this.model.min + offset).toFixed(this.computedDecimals)),
            this.computedInnerMin,
            this.computedInnerMax - interval
          );

          this.model = {
            min,
            max: parseFloat((min + interval).toFixed(this.computedDecimals))
          };
        }
        else if (this.focus === false) {
          return
        }
        else {
          const which = this.focus;

          this.model = {
            ...this.model,
            [ which ]: between(
              parseFloat((this.model[ which ] + offset).toFixed(this.computedDecimals)),
              which === 'min' ? this.computedInnerMin : this.model.min,
              which === 'max' ? this.computedInnerMax : this.model.max
            )
          };
        }

        this.__updateValue();
      }
    },

    render (h) {
      const content = this.__getContent(h, node => {
        node.push(
          this.__getThumb(h, {
            pinColor: this.thumbMinPinColor,
            textContainerStyle: this.thumbMinTextContainerStyle,
            textClass: this.thumbMinTextClass,
            label: this.thumbMinLabel,
            classes: this.thumbMinClasses,
            style: this.thumbMinStyle,
            nodeData: {
              ref: 'minThumb',
              key: 'tmin',
              on: this.thumbMinEvents,
              attrs: this.thumbAttrs
            }
          }),

          this.__getThumb(h, {
            pinColor: this.thumbMaxPinColor,
            textContainerStyle: this.thumbMaxTextContainerStyle,
            textClass: this.thumbMaxTextClass,
            label: this.thumbMaxLabel,
            classes: this.thumbMaxClasses,
            style: this.thumbMaxStyle,
            nodeData: {
              key: 'tmax',
              on: this.thumbMaxEvents,
              attrs: this.thumbAttrs
            }
          })
        );
      });

      return h('div', {
        class: 'q-range ' + this.classes + (
          this.value.min === null || this.value.max === null
            ? ' q-slider--no-value'
            : ''
        ),
        attrs: {
          ...this.attributes,
          'aria-valuenow': this.value.min + '|' + this.value.max
        }
      }, content)
    }
  });

  var QRating = Vue.extend({
    name: 'QRating',

    mixins: [ SizeMixin, FormMixin, ListenersMixin ],

    props: {
      value: {
        type: Number,
        required: true
      },

      max: {
        type: [String, Number],
        default: 5
      },

      icon: [String, Array],
      iconHalf: [String, Array],
      iconSelected: [String, Array],

      color: [String, Array],
      colorHalf: [String, Array],
      colorSelected: [String, Array],

      noReset: Boolean,
      noDimming: Boolean,

      readonly: Boolean,
      disable: Boolean
    },

    data () {
      return {
        mouseModel: 0
      }
    },

    computed: {
      editable () {
        return this.readonly !== true && this.disable !== true
      },

      classes () {
        return `q-rating--${this.editable === true ? '' : 'non-'}editable` +
          (this.noDimming === true ? ' q-rating--no-dimming' : '') +
          (this.disable === true ? ' disabled' : '') +
          (this.color !== void 0 && Array.isArray(this.color) === false ? ` text-${this.color}` : '')
      },

      iconData () {
        const
          iconLen = Array.isArray(this.icon) === true ? this.icon.length : 0,
          selIconLen = Array.isArray(this.iconSelected) === true ? this.iconSelected.length : 0,
          halfIconLen = Array.isArray(this.iconHalf) === true ? this.iconHalf.length : 0,
          colorLen = Array.isArray(this.color) === true ? this.color.length : 0,
          selColorLen = Array.isArray(this.colorSelected) === true ? this.colorSelected.length : 0,
          halfColorLen = Array.isArray(this.colorHalf) === true ? this.colorHalf.length : 0;

        return {
          iconLen,
          icon: iconLen > 0 ? this.icon[iconLen - 1] : this.icon,
          selIconLen,
          selIcon: selIconLen > 0 ? this.iconSelected[selIconLen - 1] : this.iconSelected,
          halfIconLen,
          halfIcon: halfIconLen > 0 ? this.iconHalf[selIconLen - 1] : this.iconHalf,
          colorLen,
          color: colorLen > 0 ? this.color[colorLen - 1] : this.color,
          selColorLen,
          selColor: selColorLen > 0 ? this.colorSelected[selColorLen - 1] : this.colorSelected,
          halfColorLen,
          halfColor: halfColorLen > 0 ? this.colorHalf[halfColorLen - 1] : this.colorHalf
        }
      },

      stars () {
        const
          acc = [],
          icons = this.iconData,
          ceil = Math.ceil(this.value);

        const halfIndex = this.iconHalf === void 0 || ceil === this.value
          ? -1
          : ceil;

        for (let i = 1; i <= this.max; i++) {
          const
            active = (this.mouseModel === 0 && this.value >= i) || (this.mouseModel > 0 && this.mouseModel >= i),
            half = halfIndex === i && this.mouseModel < i,
            exSelected = this.mouseModel > 0 && (half === true ? ceil : this.value) >= i && this.mouseModel < i,
            color = half === true
              ? (i <= icons.halfColorLen ? this.colorHalf[i - 1] : icons.halfColor)
              : (
                icons.selColor !== void 0 && active === true
                  ? (i <= icons.selColorLen ? this.colorSelected[i - 1] : icons.selColor)
                  : (i <= icons.colorLen ? this.color[i - 1] : icons.color)
              );

          acc.push({
            name: (
              half === true
                ? (i <= icons.halfIconLen ? this.iconHalf[i - 1] : icons.halfIcon)
                : (
                  icons.selIcon !== void 0 && (active === true || exSelected === true)
                    ? (i <= icons.selIconLen ? this.iconSelected[i - 1] : icons.selIcon)
                    : (i <= icons.iconLen ? this.icon[i - 1] : icons.icon)
                )
            ) || this.$q.iconSet.rating.icon,

            classes: 'q-rating__icon' +
              (active === true || half === true ? ' q-rating__icon--active' : '') +
              (exSelected === true ? ' q-rating__icon--exselected' : '') +
              (this.mouseModel === i ? ' q-rating__icon--hovered' : '') +
              (color !== void 0 ? ` text-${color}` : '')
          });
        }

        return acc
      },

      attrs () {
        if (this.disable === true) {
          return { 'aria-disabled': 'true' }
        }
        if (this.readonly === true) {
          return { 'aria-readonly': 'true' }
        }
      }
    },

    methods: {
      __set (value) {
        if (this.editable === true) {
          const
            model = between(parseInt(value, 10), 1, parseInt(this.max, 10)),
            newVal = this.noReset !== true && this.value === model ? 0 : model;

          newVal !== this.value && this.$emit('input', newVal);
          this.mouseModel = 0;
        }
      },

      __setHoverValue (value) {
        if (this.editable === true) {
          this.mouseModel = value;
        }
      },

      __keyup (e, i) {
        switch (e.keyCode) {
          case 13:
          case 32:
            this.__set(i);
            return stopAndPrevent(e)
          case 37: // LEFT ARROW
          case 40: // DOWN ARROW
            if (this.$refs[`rt${i - 1}`]) {
              this.$refs[`rt${i - 1}`].focus();
            }
            return stopAndPrevent(e)
          case 39: // RIGHT ARROW
          case 38: // UP ARROW
            if (this.$refs[`rt${i + 1}`]) {
              this.$refs[`rt${i + 1}`].focus();
            }
            return stopAndPrevent(e)
        }
      }
    },

    render (h) {
      const
        child = [],
        tabindex = this.editable === true ? 0 : null;

      this.stars.forEach(({ classes, name }, index) => {
        const i = index + 1;

        child.push(
          h('div', {
            key: i,
            ref: `rt${i}`,
            class: 'q-rating__icon-container flex flex-center',
            attrs: { tabindex },
            on: cache(this, 'i#' + i, {
              click: () => { this.__set(i); },
              mouseover: () => { this.__setHoverValue(i); },
              mouseout: () => { this.mouseModel = 0; },
              focus: () => { this.__setHoverValue(i); },
              blur: () => { this.mouseModel = 0; },
              keyup: e => { this.__keyup(e, i); }
            })
          }, mergeSlot(
            [h(QIcon, { class: classes, props: { name } })],
            this, `tip-${i}`
          ))
        );
      });

      if (this.name !== void 0 && this.disable !== true) {
        this.__injectFormInput(child, 'push');
      }

      return h('div', {
        staticClass: 'q-rating row inline items-center',
        class: this.classes,
        style: this.sizeStyle,
        attrs: this.attrs,
        on: { ...this.qListeners }
      }, child)
    }
  });

  var QResponsive = Vue.extend({
    name: 'QResponsive',

    mixins: [ RatioMixin, ListenersMixin ],

    render (h) {
      return h('div', {
        staticClass: 'q-responsive',
        on: { ...this.qListeners }
      }, [
        h('div', {
          staticClass: 'q-responsive__filler overflow-hidden'
        }, [
          h('div', { style: this.ratioStyle })
        ]),

        h('div', {
          staticClass: 'q-responsive__content absolute-full fit'
        }, slot(this, 'default'))
      ])
    }
  });

  const getMinThumbSize = size => (size >= 250 ? 50 : Math.ceil(size / 5));

  const axisList = [ 'vertical', 'horizontal' ];
  const dirProps = {
    vertical: { offset: 'offsetY', scroll: 'scrollTop', dir: 'down', dist: 'y' },
    horizontal: { offset: 'offsetX', scroll: 'scrollLeft', dir: 'right', dist: 'x' }
  };

  var QScrollArea = Vue.extend({
    name: 'QScrollArea',

    mixins: [ DarkMixin ],

    directives: {
      TouchPan
    },

    props: {
      thumbStyle: Object,
      verticalThumbStyle: Object,
      horizontalThumbStyle: Object,

      barStyle: [ Array, String, Object ],
      verticalBarStyle: [ Array, String, Object ],
      horizontalBarStyle: [ Array, String, Object ],

      contentStyle: [ Array, String, Object ],
      contentActiveStyle: [ Array, String, Object ],

      delay: {
        type: [ String, Number ],
        default: 1000
      },

      visible: {
        type: Boolean,
        default: null
      },

      horizontal: Boolean,

      tabindex: [ String, Number ]
    },

    data () {
      return {
        // state management
        tempShowing: false,
        panning: false,
        hover: false,

        // other...
        container: {
          vertical: 0,
          horizontal: 0
        },

        scroll: {
          vertical: {
            position: 0,
            size: 0
          },

          horizontal: {
            position: 0,
            size: 0
          }
        }
      }
    },

    computed: {
      classes () {
        return 'q-scrollarea' +
          (this.isDark === true ? ' q-scrollarea--dark' : '')
      },

      verticalScrollPercentage () {
        const diff = this.scroll.vertical.size - this.container.vertical;
        if (diff <= 0) { return 0 }
        const p = between(this.scroll.vertical.position / diff, 0, 1);
        return Math.round(p * 10000) / 10000
      },

      horizontalScrollPercentage () {
        const diff = this.scroll.horizontal.size - this.container.horizontal;
        if (diff <= 0) { return 0 }
        const p = between(this.scroll.horizontal.position / diff, 0, 1);
        return Math.round(p * 10000) / 10000
      },

      verticalThumbHidden () {
        return (
          (this.visible === null ? this.hover : this.visible) !== true &&
          this.tempShowing === false &&
          this.panning === false
        ) || this.scroll.vertical.size <= this.container.vertical + 1
      },

      horizontalThumbHidden () {
        return (
          (this.visible === null ? this.hover : this.visible) !== true &&
          this.tempShowing === false &&
          this.panning === false
        ) || this.scroll.horizontal.size <= this.container.horizontal + 1
      },

      verticalThumbStart () {
        return this.verticalScrollPercentage * (this.container.vertical - this.verticalThumbSize)
      },

      horizontalThumbStart () {
        return this.horizontalScrollPercentage * (this.container.horizontal - this.horizontalThumbSize)
      },

      verticalThumbSize () {
        return Math.round(
          between(
            this.container.vertical * this.container.vertical / this.scroll.vertical.size,
            getMinThumbSize(this.container.vertical),
            this.container.vertical
          )
        )
      },

      horizontalThumbSize () {
        return Math.round(
          between(
            this.container.horizontal * this.container.horizontal / this.scroll.horizontal.size,
            getMinThumbSize(this.container.horizontal),
            this.container.horizontal
          )
        )
      },

      verticalStyle () {
        return {
          ...this.thumbStyle,
          ...this.verticalThumbStyle,
          top: `${this.verticalThumbStart}px`,
          height: `${this.verticalThumbSize}px`
        }
      },

      horizontalStyle () {
        return {
          ...this.thumbStyle,
          ...this.horizontalThumbStyle,
          left: `${this.horizontalThumbStart}px`,
          width: `${this.horizontalThumbSize}px`
        }
      },

      verticalThumbClass () {
        return 'q-scrollarea__thumb q-scrollarea__thumb--v absolute-right' +
          (this.verticalThumbHidden === true ? ' q-scrollarea__thumb--invisible' : '')
      },

      horizontalThumbClass () {
        return 'q-scrollarea__thumb q-scrollarea__thumb--h absolute-bottom' +
          (this.horizontalThumbHidden === true ? ' q-scrollarea__thumb--invisible' : '')
      },

      verticalBarClass () {
        return 'q-scrollarea__bar q-scrollarea__bar--v absolute-right' +
          (this.verticalThumbHidden === true ? ' q-scrollarea__bar--invisible' : '')
      },

      horizontalBarClass () {
        return 'q-scrollarea__bar q-scrollarea__bar--h absolute-bottom' +
          (this.horizontalThumbHidden === true ? ' q-scrollarea__bar--invisible' : '')
      },

      scrollComputed () {
        return {
          vertical: {
            ...this.scroll.vertical,
            percentage: this.verticalScrollPercentage,
            thumbHidden: this.verticalThumbHidden,
            thumbStart: this.verticalThumbStart,
            thumbSize: this.verticalThumbSize,
            style: this.verticalStyle,
            thumbClass: this.verticalThumbClass,
            barClass: this.verticalBarClass
          },
          horizontal: {
            ...this.scroll.horizontal,
            percentage: this.horizontalScrollPercentage,
            thumbHidden: this.horizontalThumbHidden,
            thumbStart: this.horizontalThumbStart,
            thumbSize: this.horizontalThumbSize,
            style: this.horizontalStyle,
            thumbClass: this.horizontalThumbClass,
            barClass: this.horizontalBarClass
          }
        }
      },

      mainStyle () {
        return this.verticalThumbHidden === true && this.horizontalThumbHidden === true
          ? this.contentStyle
          : this.contentActiveStyle
      },

      verticalThumbDirectives () {
        return [{
          name: 'touch-pan',
          modifiers: {
            vertical: true,
            prevent: true,
            mouse: true,
            mouseAllDir: true
          },
          value: e => { this.__panThumb(e, 'vertical'); }
        }]
      },

      horizontalThumbDirectives () {
        return [{
          name: 'touch-pan',
          modifiers: {
            horizontal: true,
            prevent: true,
            mouse: true,
            mouseAllDir: true
          },
          value: e => { this.__panThumb(e, 'horizontal'); }
        }]
      },

      scrollAttrs () {
        if (this.tabindex !== void 0) {
          return { tabindex: this.tabindex }
        }
      }
    },

    methods: {
      getScrollTarget () {
        return this.$refs.target
      },

      getScroll () {
        const info = {};

        axisList.forEach(axis => {
          const data = this.scrollComputed[ axis ];

          info[ axis + 'Position' ] = data.position;
          info[ axis + 'Percentage' ] = data.percentage;
          info[ axis + 'Size' ] = data.size;
          info[ axis + 'ContainerSize' ] = this.container[ axis ];
        });

        return info
      },

      getScrollPosition (axis) {
        if (axis === 'both') {
          return {
            top: this.scroll.vertical.position,
            left: this.scroll.horizontal.position
          }
        }

        if (axisList.includes(axis) !== true) {
          axis = this.horizontal === true ? 'horizontal' : 'vertical';
        }

        return this.scroll[axis].position
      },

      getScrollPercentage (axis) {
        if (axis === 'both') {
          return {
            top: this.verticalScrollPercentage,
            left: this.horizontalScrollPercentage
          }
        }

        if (axisList.includes(axis) !== true) {
          axis = this.horizontal === true ? 'horizontal' : 'vertical';
        }

        return this[`${axis}ScrollPercentage`]
      },

      setScrollPosition (axis, offset, duration) {
        if (axisList.includes(axis) === false) {
          if (isNaN(axis) === true) {
            console.error('[QScrollArea]: wrong first param of setScrollPosition (vertical/horizontal)');
            return
          }

          [axis, offset, duration] = [this.horizontal === true ? 'horizontal' : 'vertical', axis, offset];
        }

        const fn = axis === 'vertical'
          ? setVerticalScrollPosition
          : setHorizontalScrollPosition;

        fn(this.$refs.target, offset, duration);
      },

      setScrollPercentage (axis, percentage, duration) {
        if (axisList.includes(axis) === false) {
          if (isNaN(axis) === true) {
            console.error('[QScrollArea]: wrong first param of setScrollPercentage (vertical/horizontal)');
            return
          }

          [axis, percentage, duration] = [this.horizontal === true ? 'horizontal' : 'vertical', axis, percentage];
        }

        this.setScrollPosition(
          axis,
          percentage * (this.scroll[axis].size - this.container[axis]),
          duration
        );
      },

      __updateContainer ({ height, width }) {
        let change = false;

        if (this.container.vertical !== height) {
          this.container.vertical = height;
          change = true;
        }

        if (this.container.horizontal !== width) {
          this.container.horizontal = width;
          change = true;
        }

        change === true && this.__startTimer();
      },

      __updateVerticalScroll ({ position }) {
        if (this.scroll.vertical.position !== position) {
          this.scroll.vertical.position = position;
          this.__startTimer();
        }
      },

      __updateHorizontalScroll ({ position }) {
        if (this.scroll.horizontal.position !== position) {
          this.scroll.horizontal.position = position;
          this.__startTimer();
        }
      },

      __updateScrollSize ({ height, width }) {
        let change = false;

        if (this.scroll.horizontal.size !== width) {
          this.scroll.horizontal.size = width;
          change = true;
        }

        if (this.scroll.vertical.size !== height) {
          this.scroll.vertical.size = height;
          change = true;
        }

        change === true && this.__startTimer();
      },

      __panThumb (e, axis) {
        const data = this.scrollComputed[ axis ];

        if (e.isFinal === true) {
          if (this.panning !== true) {
            return
          }

          this.panning = false;
        }
        else if (e.isFirst === true) {
          if (data.thumbHidden === true) {
            return
          }

          this.refPos = data.position;
          this.panning = true;
        }
        else if (this.panning !== true) {
          return
        }

        const dProp = dirProps[ axis ];
        const containerSize = this.container[axis];

        const multiplier = (data.size - containerSize) / (containerSize - data.thumbSize);
        const distance = e.distance[dProp.dist];
        const pos = this.refPos + (e.direction === dProp.dir ? 1 : -1) * distance * multiplier;

        this.__setScroll(pos, axis);
      },

      __mouseDown (evt, axis) {
        const data = this.scrollComputed[ axis ];

        if (data.thumbHidden !== true) {
          const offset = evt[ dirProps[ axis ].offset ];
          if (offset < data.thumbStart || offset > data.thumbStart + data.thumbSize) {
            const pos = offset - data.thumbSize / 2;
            this.__setScroll(pos / this.container[ axis ] * data.size, axis);
          }

          const ref = axis === 'vertical' ? this.$refs.verticalThumb : this.$refs.horizontalThumb;
          // activate thumb pan
          if (ref !== void 0) {
            ref.dispatchEvent(new MouseEvent(evt.type, evt));
          }
        }
      },

      __verticalMouseDown (evt) {
        this.__mouseDown(evt, 'vertical');
      },

      __horizontalMouseDown (evt) {
        this.__mouseDown(evt, 'horizontal');
      },

      __startTimer () {
        if (this.tempShowing === true) {
          clearTimeout(this.timer);
        }
        else {
          this.tempShowing = true;
        }

        this.timer = setTimeout(() => { this.tempShowing = false; }, this.delay);
        this.$listeners.scroll !== void 0 && this.__emitScroll();
      },

      __setScroll (offset, axis) {
        this.$refs.target[ dirProps[ axis ].scroll ] = offset;
      },

      __mouseEnter () {
        this.hover = true;
      },

      __mouseLeave () {
        this.hover = false;
      }
    },

    render (h) {
      return h('div', {
        class: this.classes,
        on: cache(this, 'desk', {
          mouseenter: this.__mouseEnter,
          mouseleave: this.__mouseLeave
        })
      }, [
        h('div', {
          ref: 'target',
          staticClass: 'q-scrollarea__container scroll relative-position fit hide-scrollbar',
          attrs: this.scrollAttrs
        }, [
          h('div', {
            staticClass: 'q-scrollarea__content absolute',
            style: this.mainStyle
          }, mergeSlot([
            h(QResizeObserver, {
              props: { debounce: 0 },
              on: cache(this, 'resizeIn', { resize: this.__updateScrollSize })
            })
          ], this, 'default')),

          h(QScrollObserver, {
            on: cache(this, 'scrollV', { scroll: this.__updateVerticalScroll })
          }),

          h(QScrollObserver, {
            props: { horizontal: true },
            on: cache(this, 'scrollH', { scroll: this.__updateHorizontalScroll })
          })
        ]),

        h(QResizeObserver, {
          props: { debounce: 0 },
          on: cache(this, 'resizeOut', { resize: this.__updateContainer })
        }),

        h('div', {
          class: this.verticalBarClass,
          style: [ this.barStyle, this.verticalBarStyle ],
          attrs: ariaHidden,
          on: cache(this, 'barV', {
            mousedown: this.__verticalMouseDown
          })
        }),

        h('div', {
          class: this.horizontalBarClass,
          style: [ this.barStyle, this.horizontalBarStyle ],
          attrs: ariaHidden,
          on: cache(this, 'barH', {
            mousedown: this.__horizontalMouseDown
          })
        }),

        h('div', {
          ref: 'verticalThumb',
          class: this.verticalThumbClass,
          style: this.verticalStyle,
          attrs: ariaHidden,
          directives: this.verticalThumbDirectives
        }),

        h('div', {
          ref: 'horizontalThumb',
          class: this.horizontalThumbClass,
          style: this.horizontalStyle,
          attrs: ariaHidden,
          directives: this.horizontalThumbDirectives
        })
      ])
    },

    created () {
      // we have lots of listeners, so
      // ensure we're not emitting same info
      // multiple times
      this.__emitScroll = debounce(() => {
        const info = this.getScroll();
        info.ref = this;
        this.$emit('scroll', info);
      }, 0);
    },

    activated () {
      if (this.__scrollPosition === void 0) { return }

      const scrollTarget = this.getScrollTarget();

      if (scrollTarget !== void 0) {
        setHorizontalScrollPosition(scrollTarget, this.__scrollPosition.left);
        setVerticalScrollPosition(scrollTarget, this.__scrollPosition.top);
      }
    },

    deactivated () {
      this.__scrollPosition = this.getScrollPosition('both');
    },

    beforeDestroy () {
      this.__emitScroll.cancel();
      clearTimeout(this.timer);
    }
  });

  const aggBucketSize = 1000;

  const scrollToEdges = [
    'start',
    'center',
    'end',
    'start-force',
    'center-force',
    'end-force'
  ];

  const filterProto = Array.prototype.filter;

  function sumFn (acc, h) {
    return acc + h
  }

  function getScrollDetails (
    parent,
    child,
    beforeRef,
    afterRef,
    horizontal,
    rtl,
    stickyStart,
    stickyEnd
  ) {
    const
      parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent,
      propElSize = horizontal === true ? 'offsetWidth' : 'offsetHeight',
      details = {
        scrollStart: 0,
        scrollViewSize: -stickyStart - stickyEnd,
        scrollMaxSize: 0,
        offsetStart: -stickyStart,
        offsetEnd: -stickyEnd
      };

    if (horizontal === true) {
      if (parent === window) {
        details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0;
        details.scrollViewSize += document.documentElement.clientWidth;
      }
      else {
        details.scrollStart = parentCalc.scrollLeft;
        details.scrollViewSize += parentCalc.clientWidth;
      }
      details.scrollMaxSize = parentCalc.scrollWidth;

      if (rtl === true) {
        details.scrollStart = (rtlHasScrollBug() === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart;
      }
    }
    else {
      if (parent === window) {
        details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0;
        details.scrollViewSize += document.documentElement.clientHeight;
      }
      else {
        details.scrollStart = parentCalc.scrollTop;
        details.scrollViewSize += parentCalc.clientHeight;
      }
      details.scrollMaxSize = parentCalc.scrollHeight;
    }

    if (beforeRef !== void 0) {
      for (let el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {
        if (el.classList.contains('q-virtual-scroll--skip') === false) {
          details.offsetStart += el[propElSize];
        }
      }
    }
    if (afterRef !== void 0) {
      for (let el = afterRef.nextElementSibling; el !== null; el = el.nextElementSibling) {
        if (el.classList.contains('q-virtual-scroll--skip') === false) {
          details.offsetEnd += el[propElSize];
        }
      }
    }

    if (child !== parent) {
      const
        parentRect = parentCalc.getBoundingClientRect(),
        childRect = child.getBoundingClientRect();

      if (horizontal === true) {
        details.offsetStart += childRect.left - parentRect.left;
        details.offsetEnd -= childRect.width;
      }
      else {
        details.offsetStart += childRect.top - parentRect.top;
        details.offsetEnd -= childRect.height;
      }

      if (parent !== window) {
        details.offsetStart += details.scrollStart;
      }
      details.offsetEnd += details.scrollMaxSize - details.offsetStart;
    }

    return details
  }

  function setScroll$1 (parent, scroll, horizontal, rtl) {
    if (scroll === 'end') {
      scroll = (parent === window ? document.body : parent)[horizontal === true ? 'scrollWidth' : 'scrollHeight'];
    }

    if (parent === window) {
      if (horizontal === true) {
        if (rtl === true) {
          scroll = (rtlHasScrollBug() === true ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - scroll;
        }
        window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
      }
      else {
        window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll);
      }
    }
    else if (horizontal === true) {
      if (rtl === true) {
        scroll = (rtlHasScrollBug() === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll;
      }
      parent.scrollLeft = scroll;
    }
    else {
      parent.scrollTop = scroll;
    }
  }

  function sumSize (sizeAgg, size, from, to) {
    if (from >= to) { return 0 }

    const
      lastTo = size.length,
      fromAgg = Math.floor(from / aggBucketSize),
      toAgg = Math.floor((to - 1) / aggBucketSize) + 1;

    let total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0);

    if (from % aggBucketSize !== 0) {
      total -= size.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0);
    }
    if (to % aggBucketSize !== 0 && to !== lastTo) {
      total -= size.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0);
    }

    return total
  }

  const commonVirtScrollProps = {
    virtualScrollSliceSize: {
      type: [ Number, String ],
      default: null
    },

    virtualScrollSliceRatioBefore: {
      type: [ Number, String ],
      default: 1
    },

    virtualScrollSliceRatioAfter: {
      type: [ Number, String ],
      default: 1
    },

    virtualScrollItemSize: {
      type: [ Number, String ],
      default: 24
    },

    virtualScrollStickySizeStart: {
      type: [ Number, String ],
      default: 0
    },

    virtualScrollStickySizeEnd: {
      type: [ Number, String ],
      default: 0
    },

    tableColspan: [ Number, String ]
  };

  function setOverflowAnchor (contentEl, index) {
    if (setOverflowAnchor.isSupported === void 0) {
      setOverflowAnchor.isSupported = window.getComputedStyle(document.body).overflowAnchor !== void 0;
    }

    if (setOverflowAnchor.isSupported === false || contentEl === void 0) {
      return
    }

    cancelAnimationFrame(contentEl._qOverflowAnimationFrame);
    contentEl._qOverflowAnimationFrame = requestAnimationFrame(() => {
      if (contentEl === void 0) {
        return
      }

      const children = contentEl.children || [];

      filterProto
        .call(children, el => el.dataset && el.dataset.qVsAnchor !== void 0)
        .forEach(el => {
          delete el.dataset.qVsAnchor;
        });

      const el = children[index];

      if (el && el.dataset) {
        el.dataset.qVsAnchor = '';
      }
    });
  }

  const commonVirtPropsList = Object.keys(commonVirtScrollProps);

  var VirtualScroll = {
    props: {
      virtualScrollHorizontal: Boolean,
      ...commonVirtScrollProps
    },

    data () {
      return {
        virtualScrollSliceRange: { from: 0, to: 0 }
      }
    },

    watch: {
      needsSliceRecalc () {
        this.__setVirtualScrollSize();
      },

      needsReset () {
        this.reset();
      }
    },

    computed: {
      needsReset () {
        return ['virtualScrollItemSizeComputed', 'virtualScrollHorizontal']
          .map(p => this[p]).join(';')
      },

      needsSliceRecalc () {
        return this.needsReset + ';' + ['virtualScrollSliceRatioBefore', 'virtualScrollSliceRatioAfter']
          .map(p => this[p]).join(';')
      },

      colspanAttr () {
        return this.tableColspan !== void 0
          ? { colspan: this.tableColspan }
          : { colspan: 100 }
      },

      virtualScrollItemSizeComputed () {
        return this.virtualScrollItemSize
      }
    },

    methods: {
      reset () {
        this.__resetVirtualScroll(this.prevToIndex, true);
      },

      refresh (toIndex) {
        this.__resetVirtualScroll(toIndex === void 0 ? this.prevToIndex : toIndex);
      },

      scrollTo (toIndex, edge) {
        const scrollEl = this.__getVirtualScrollTarget();

        if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
          return
        }

        const scrollDetails = getScrollDetails(
          scrollEl,
          this.__getVirtualScrollEl(),
          this.$refs.before,
          this.$refs.after,
          this.virtualScrollHorizontal,
          this.$q.lang.rtl,
          this.virtualScrollStickySizeStart,
          this.virtualScrollStickySizeEnd
        );

        this.__scrollViewSize !== scrollDetails.scrollViewSize && this.__setVirtualScrollSize(scrollDetails.scrollViewSize);

        this.__setVirtualScrollSliceRange(
          scrollEl,
          scrollDetails,
          Math.min(this.virtualScrollLength - 1, Math.max(0, parseInt(toIndex, 10) || 0)),
          0,
          scrollToEdges.indexOf(edge) > -1 ? edge : (this.prevToIndex > -1 && toIndex > this.prevToIndex ? 'end' : 'start')
        );
      },

      __onVirtualScrollEvt () {
        const scrollEl = this.__getVirtualScrollTarget();

        if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
          return
        }

        const
          scrollDetails = getScrollDetails(
            scrollEl,
            this.__getVirtualScrollEl(),
            this.$refs.before,
            this.$refs.after,
            this.virtualScrollHorizontal,
            this.$q.lang.rtl,
            this.virtualScrollStickySizeStart,
            this.virtualScrollStickySizeEnd
          ),
          listLastIndex = this.virtualScrollLength - 1,
          listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - this.virtualScrollPaddingAfter;

        if (this.prevScrollStart === scrollDetails.scrollStart) {
          return
        }

        if (scrollDetails.scrollMaxSize <= 0) {
          this.__setVirtualScrollSliceRange(scrollEl, scrollDetails, 0, 0);

          return
        }

        this.__scrollViewSize !== scrollDetails.scrollViewSize && this.__setVirtualScrollSize(scrollDetails.scrollViewSize);

        this.__updateVirtualScrollSizes(this.virtualScrollSliceRange.from);

        const scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize -
          Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd) -
          Math.min(this.virtualScrollSizes[listLastIndex], scrollDetails.scrollViewSize / 2));

        if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {
          this.__setVirtualScrollSliceRange(
            scrollEl,
            scrollDetails,
            listLastIndex,
            scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - this.virtualScrollSizesAgg.reduce(sumFn, 0)
          );

          return
        }

        let
          toIndex = 0,
          listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart,
          offset = listOffset;

        if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= this.virtualScrollPaddingBefore) {
          listOffset -= this.virtualScrollPaddingBefore;
          toIndex = this.virtualScrollSliceRange.from;
          offset = listOffset;
        }
        else {
          for (let j = 0; listOffset >= this.virtualScrollSizesAgg[j] && toIndex < listLastIndex; j++) {
            listOffset -= this.virtualScrollSizesAgg[j];
            toIndex += aggBucketSize;
          }
        }

        while (listOffset > 0 && toIndex < listLastIndex) {
          listOffset -= this.virtualScrollSizes[toIndex];
          if (listOffset > -scrollDetails.scrollViewSize) {
            toIndex++;
            offset = listOffset;
          }
          else {
            offset = this.virtualScrollSizes[toIndex] + listOffset;
          }
        }

        this.__setVirtualScrollSliceRange(
          scrollEl,
          scrollDetails,
          toIndex,
          offset
        );
      },

      __setVirtualScrollSliceRange (scrollEl, scrollDetails, toIndex, offset, align) {
        const alignForce = typeof align === 'string' && align.indexOf('-force') > -1;
        const alignEnd = alignForce === true ? align.replace('-force', '') : align;
        const alignRange = alignEnd !== void 0 ? alignEnd : 'start';

        let
          from = Math.max(0, toIndex - this.virtualScrollSliceSizeComputed[alignRange]),
          to = from + this.virtualScrollSliceSizeComputed.total;

        if (to > this.virtualScrollLength) {
          to = this.virtualScrollLength;
          from = Math.max(0, to - this.virtualScrollSliceSizeComputed.total);
        }

        this.prevScrollStart = scrollDetails.scrollStart;

        const rangeChanged = from !== this.virtualScrollSliceRange.from || to !== this.virtualScrollSliceRange.to;

        if (rangeChanged === false && alignEnd === void 0) {
          this.__emitScroll(toIndex);

          return
        }

        const { activeElement } = document;
        const contentEl = this.$refs.content;
        if (
          rangeChanged === true &&
          contentEl !== void 0 &&
          contentEl !== activeElement &&
          contentEl.contains(activeElement) === true
        ) {
          contentEl.addEventListener('focusout', this.__onBlurRefocusFn);

          setTimeout(() => {
            contentEl !== void 0 && contentEl.removeEventListener('focusout', this.__onBlurRefocusFn);
          });
        }

        setOverflowAnchor(contentEl, toIndex - from);

        const sizeBefore = alignEnd !== void 0 ? this.virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0;

        if (rangeChanged === true) {
          // vue key matching algorithm works only if
          // the array of VNodes changes on only one of the ends
          // so we first change one end and then the other

          const tempTo = to >= this.virtualScrollSliceRange.from && from <= this.virtualScrollSliceRange.to
            ? this.virtualScrollSliceRange.to
            : to;
          this.virtualScrollSliceRange = { from, to: tempTo };
          this.virtualScrollPaddingBefore = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, 0, from);
          this.virtualScrollPaddingAfter = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, this.virtualScrollSliceRange.to, this.virtualScrollLength);

          requestAnimationFrame(() => {
            if (this.virtualScrollSliceRange.to !== to && this.prevScrollStart === scrollDetails.scrollStart) {
              this.virtualScrollSliceRange = { from: this.virtualScrollSliceRange.from, to };
              this.virtualScrollPaddingAfter = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, to, this.virtualScrollLength);
            }
          });
        }

        requestAnimationFrame(() => {
          // if the scroll was changed give up
          // (another call to __setVirtualScrollSliceRange before animation frame)
          if (this.prevScrollStart !== scrollDetails.scrollStart) {
            return
          }

          if (rangeChanged === true) {
            this.__updateVirtualScrollSizes(from);
          }

          const
            sizeAfter = this.virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0),
            posStart = sizeAfter + scrollDetails.offsetStart + this.virtualScrollPaddingBefore,
            posEnd = posStart + this.virtualScrollSizes[toIndex];

          let scrollPosition = posStart + offset;

          if (alignEnd !== void 0) {
            const sizeDiff = sizeAfter - sizeBefore;
            const scrollStart = scrollDetails.scrollStart + sizeDiff;

            scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize
              ? scrollStart
              : (
                alignEnd === 'end'
                  ? posEnd - scrollDetails.scrollViewSize
                  : posStart - (alignEnd === 'start' ? 0 : Math.round((scrollDetails.scrollViewSize - this.virtualScrollSizes[toIndex]) / 2))
              );
          }

          this.prevScrollStart = scrollPosition;

          setScroll$1(
            scrollEl,
            scrollPosition,
            this.virtualScrollHorizontal,
            this.$q.lang.rtl
          );

          this.__emitScroll(toIndex);
        });
      },

      __updateVirtualScrollSizes (from) {
        const contentEl = this.$refs.content;

        if (contentEl !== void 0) {
          const
            children = filterProto.call(contentEl.children || [], el => el.classList && el.classList.contains('q-virtual-scroll--skip') === false), // fallback [] for IE
            childrenLength = children.length,
            sizeFn = this.virtualScrollHorizontal === true
              ? el => el.getBoundingClientRect().width
              : el => el.offsetHeight;

          let
            index = from,
            size, diff;

          for (let i = 0; i < childrenLength;) {
            size = sizeFn(children[i]);
            i++;

            while (i < childrenLength && children[i].classList.contains('q-virtual-scroll--with-prev') === true) {
              size += sizeFn(children[i]);
              i++;
            }

            diff = size - this.virtualScrollSizes[index];

            if (diff !== 0) {
              this.virtualScrollSizes[index] += diff;
              this.virtualScrollSizesAgg[Math.floor(index / aggBucketSize)] += diff;
            }

            index++;
          }
        }
      },

      __resetVirtualScroll (toIndex, fullReset) {
        const defaultSize = 1 * this.virtualScrollItemSizeComputed;

        if (fullReset === true || Array.isArray(this.virtualScrollSizes) === false) {
          this.virtualScrollSizes = [];
        }

        const oldVirtualScrollSizesLength = this.virtualScrollSizes.length;

        this.virtualScrollSizes.length = this.virtualScrollLength;

        for (let i = this.virtualScrollLength - 1; i >= oldVirtualScrollSizesLength; i--) {
          this.virtualScrollSizes[i] = defaultSize;
        }

        const jMax = Math.floor((this.virtualScrollLength - 1) / aggBucketSize);
        this.virtualScrollSizesAgg = [];
        for (let j = 0; j <= jMax; j++) {
          let size = 0;
          const iMax = Math.min((j + 1) * aggBucketSize, this.virtualScrollLength);
          for (let i = j * aggBucketSize; i < iMax; i++) {
            size += this.virtualScrollSizes[i];
          }
          this.virtualScrollSizesAgg.push(size);
        }

        this.prevToIndex = -1;
        this.prevScrollStart = void 0;

        this.virtualScrollPaddingBefore = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, 0, this.virtualScrollSliceRange.from);
        this.virtualScrollPaddingAfter = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, this.virtualScrollSliceRange.to, this.virtualScrollLength);

        if (toIndex >= 0) {
          this.__updateVirtualScrollSizes(this.virtualScrollSliceRange.from);

          this.$nextTick(() => {
            this.scrollTo(toIndex);
          });
        }
        else {
          this.__onVirtualScrollEvt();
        }
      },

      __setVirtualScrollSize (scrollViewSize) {
        if (scrollViewSize === void 0 && typeof window !== 'undefined') {
          const scrollEl = this.__getVirtualScrollTarget();

          if (scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {
            scrollViewSize = getScrollDetails(
              scrollEl,
              this.__getVirtualScrollEl(),
              this.$refs.before,
              this.$refs.after,
              this.virtualScrollHorizontal,
              this.$q.lang.rtl,
              this.virtualScrollStickySizeStart,
              this.virtualScrollStickySizeEnd
            ).scrollViewSize;
          }
        }

        this.__scrollViewSize = scrollViewSize;

        const virtualScrollSliceRatioBefore = parseFloat(this.virtualScrollSliceRatioBefore) || 0;
        const virtualScrollSliceRatioAfter = parseFloat(this.virtualScrollSliceRatioAfter) || 0;
        const multiplier = 1 + virtualScrollSliceRatioBefore + virtualScrollSliceRatioAfter;
        const view = scrollViewSize === void 0 || scrollViewSize <= 0
          ? 1
          : Math.ceil(scrollViewSize / this.virtualScrollItemSizeComputed);
        const baseSize = Math.max(
          1,
          view,
          Math.ceil((this.virtualScrollSliceSize > 0 ? this.virtualScrollSliceSize : 10) / multiplier)
        );

        this.virtualScrollSliceSizeComputed = {
          total: Math.ceil(baseSize * multiplier),
          start: Math.ceil(baseSize * virtualScrollSliceRatioBefore),
          center: Math.ceil(baseSize * (0.5 + virtualScrollSliceRatioBefore)),
          end: Math.ceil(baseSize * (1 + virtualScrollSliceRatioBefore)),
          view
        };
      },

      __padVirtualScroll (h, tag, content) {
        const paddingSize = this.virtualScrollHorizontal === true ? 'width' : 'height';
        const style = {
          ['--q-virtual-scroll-item-' + paddingSize]: this.virtualScrollItemSizeComputed + 'px'
        };

        return [
          tag === 'tbody'
            ? h(tag, {
              staticClass: 'q-virtual-scroll__padding',
              key: 'before',
              ref: 'before'
            }, [
              h('tr', [
                h('td', {
                  style: { [paddingSize]: `${this.virtualScrollPaddingBefore}px`, ...style },
                  attrs: this.colspanAttr
                })
              ])
            ])
            : h(tag, {
              staticClass: 'q-virtual-scroll__padding',
              key: 'before',
              ref: 'before',
              style: { [paddingSize]: `${this.virtualScrollPaddingBefore}px`, ...style }
            }),

          h(tag, {
            staticClass: 'q-virtual-scroll__content',
            key: 'content',
            ref: 'content',
            attrs: { tabindex: -1 }
          }, content),

          tag === 'tbody'
            ? h(tag, {
              staticClass: 'q-virtual-scroll__padding',
              key: 'after',
              ref: 'after'
            }, [
              h('tr', [
                h('td', {
                  style: { [paddingSize]: `${this.virtualScrollPaddingAfter}px`, ...style },
                  attrs: this.colspanAttr
                })
              ])
            ])
            : h(tag, {
              staticClass: 'q-virtual-scroll__padding',
              key: 'after',
              ref: 'after',
              style: { [paddingSize]: `${this.virtualScrollPaddingAfter}px`, ...style }
            })
        ]
      },

      __emitScroll (index) {
        if (this.prevToIndex !== index) {
          this.qListeners['virtual-scroll'] !== void 0 && this.$emit('virtual-scroll', {
            index,
            from: this.virtualScrollSliceRange.from,
            to: this.virtualScrollSliceRange.to - 1,
            direction: index < this.prevToIndex ? 'decrease' : 'increase',
            ref: this
          });

          this.prevToIndex = index;
        }
      },

      __onBlurRefocusFn () {
        this.$refs.content !== void 0 && this.$refs.content.focus();
      }
    },

    created () {
      this.__setVirtualScrollSize();
    },

    activated () {
      if (this.shouldActivate !== true) { return }

      const scrollEl = this.__getVirtualScrollTarget();

      if (this.prevScrollStart !== void 0 && scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {
        setScroll$1(
          scrollEl,
          this.prevScrollStart,
          this.virtualScrollHorizontal,
          this.$q.lang.rtl
        );
      }
      else {
        this.scrollTo(this.prevToIndex);
      }
    },

    deactivated () {
      this.shouldActivate = true;
    },

    beforeMount () {
      this.__onVirtualScrollEvt = debounce(this.__onVirtualScrollEvt, this.$q.platform.is.ios === true ? 120 : 35);
      this.__setVirtualScrollSize();
    },

    beforeDestroy () {
      this.__onVirtualScrollEvt.cancel();
    }
  };

  const validateNewValueMode = v => ['add', 'add-unique', 'toggle'].includes(v);
  const reEscapeList = '.*+?^${}()|[]\\';

  var QSelect = Vue.extend({
    name: 'QSelect',

    mixins: [
      QField,
      VirtualScroll,
      CompositionMixin,
      FormFieldMixin,
      ListenersMixin
    ],

    props: {
      value: {
        required: true
      },

      multiple: Boolean,

      displayValue: [String, Number],
      displayValueSanitize: Boolean,
      dropdownIcon: String,

      options: {
        type: Array,
        default: () => []
      },

      optionValue: [Function, String],
      optionLabel: [Function, String],
      optionDisable: [Function, String],

      hideSelected: Boolean,
      hideDropdownIcon: Boolean,
      fillInput: Boolean,

      maxValues: [Number, String],

      optionsDense: Boolean,
      optionsDark: {
        type: Boolean,
        default: null
      },
      optionsSelectedClass: String,
      optionsSanitize: Boolean,

      optionsCover: Boolean,

      menuShrink: Boolean,
      menuAnchor: String,
      menuSelf: String,
      menuOffset: Array,

      popupContentClass: String,
      popupContentStyle: [String, Array, Object],

      useInput: Boolean,
      useChips: Boolean,

      newValueMode: {
        type: String,
        validator: validateNewValueMode
      },

      mapOptions: Boolean,
      emitValue: Boolean,

      inputDebounce: {
        type: [Number, String],
        default: 500
      },

      inputClass: [Array, String, Object],
      inputStyle: [Array, String, Object],

      tabindex: {
        type: [String, Number],
        default: 0
      },

      autocomplete: String,

      transitionShow: String,
      transitionHide: String,

      behavior: {
        type: String,
        validator: v => ['default', 'menu', 'dialog'].includes(v),
        default: 'default'
      },

      virtualScrollItemSize: {
        type: [ Number, String ],
        default: void 0
      }
    },

    data () {
      return {
        menu: false,
        dialog: false,
        optionIndex: -1,
        inputValue: '',
        dialogFieldFocused: false
      }
    },

    watch: {
      innerValue: {
        handler (val) {
          this.innerValueCache = val;

          if (
            this.useInput === true &&
            this.fillInput === true &&
            this.multiple !== true &&
            // Prevent re-entering in filter while filtering
            // Also prevent clearing inputValue while filtering
            this.innerLoading !== true &&
            ((this.dialog !== true && this.menu !== true) || this.hasValue !== true)
          ) {
            this.userInputValue !== true && this.__resetInputValue();
            if (this.dialog === true || this.menu === true) {
              this.filter('');
            }
          }
        },
        immediate: true
      },

      fillInput () {
        this.__resetInputValue();
      },

      menu (show) {
        this.__updateMenu(show);
      },

      virtualScrollLength (newLength, oldLength) {
        if (this.menu === true && this.innerLoading === false) {
          this.__resetVirtualScroll(-1, true);

          this.$nextTick(() => {
            if (this.menu === true && this.innerLoading === false) {
              if (newLength > oldLength) {
                this.__resetVirtualScroll();
              }
              else {
                this.__updateMenu(true);
              }
            }
          });
        }
      }
    },

    computed: {
      isOptionsDark () {
        return this.optionsDark === null
          ? this.isDark
          : this.optionsDark
      },

      virtualScrollLength () {
        return Array.isArray(this.options)
          ? this.options.length
          : 0
      },

      fieldClass () {
        return `q-select q-field--auto-height q-select--with${this.useInput !== true ? 'out' : ''}-input` +
          ` q-select--with${this.useChips !== true ? 'out' : ''}-chips` +
          ` q-select--${this.multiple === true ? 'multiple' : 'single'}`
      },

      computedInputClass () {
        if (this.hideSelected === true || this.innerValue.length === 0) {
          return this.inputClass
        }

        return this.inputClass === void 0
          ? 'q-field__input--padding'
          : [this.inputClass, 'q-field__input--padding']
      },

      menuContentClass () {
        return (this.virtualScrollHorizontal === true ? 'q-virtual-scroll--horizontal' : '') +
          (this.popupContentClass ? ' ' + this.popupContentClass : '')
      },

      innerValue () {
        const
          mapNull = this.mapOptions === true && this.multiple !== true,
          val = this.value !== void 0 && (this.value !== null || mapNull === true)
            ? (this.multiple === true && Array.isArray(this.value) ? this.value : [ this.value ])
            : [];

        if (this.mapOptions === true && Array.isArray(this.options) === true) {
          const cache = this.mapOptions === true && this.innerValueCache !== void 0
            ? this.innerValueCache
            : [];
          const values = val.map(v => this.__getOption(v, cache));

          return this.value === null && mapNull === true
            ? values.filter(v => v !== null)
            : values
        }

        return val
      },

      noOptions () {
        return this.virtualScrollLength === 0
      },

      selectedString () {
        return this.innerValue
          .map(opt => this.getOptionLabel(opt))
          .join(', ')
      },

      sanitizeFn () {
        return this.optionsSanitize === true
          ? () => true
          : opt => opt !== void 0 && opt !== null && opt.sanitize === true
      },

      displayAsText () {
        return this.displayValueSanitize === true || (
          this.displayValue === void 0 && (
            this.optionsSanitize === true ||
            this.innerValue.some(this.sanitizeFn)
          )
        )
      },

      computedTabindex () {
        return this.focused === true ? this.tabindex : -1
      },

      selectedScope () {
        return this.innerValue.map((opt, i) => ({
          index: i,
          opt,
          sanitize: this.sanitizeFn(opt),
          selected: true,
          removeAtIndex: this.__removeAtIndexAndFocus,
          toggleOption: this.toggleOption,
          tabindex: this.computedTabindex
        }))
      },

      optionScope () {
        if (this.virtualScrollLength === 0) {
          return []
        }

        const { from, to } = this.virtualScrollSliceRange;
        const { options, optionEls } = this.__optionScopeCache;

        return this.options.slice(from, to).map((opt, i) => {
          const disable = this.isOptionDisabled(opt);
          const index = from + i;

          const itemProps = {
            clickable: true,
            active: false,
            activeClass: this.computedOptionsSelectedClass,
            manualFocus: true,
            focused: false,
            disable,
            tabindex: -1,
            dense: this.optionsDense,
            dark: this.isOptionsDark
          };

          const itemAttrs = {
            role: 'option',
            id: `${this.targetUid}_${index}`
          };

          if (disable !== true) {
            this.isOptionSelected(opt) === true && (itemProps.active = true);
            itemAttrs['aria-selected'] = itemProps.active === true ? 'true' : 'false';

            this.optionIndex === index && (itemProps.focused = true);
          }

          const itemEvents = {
            click: () => { this.toggleOption(opt); }
          };

          if (this.$q.platform.is.desktop === true) {
            itemEvents.mousemove = () => { this.menu === true && this.setOptionIndex(index); };
          }

          const option = {
            index,
            opt,
            sanitize: this.sanitizeFn(opt),
            selected: itemProps.active,
            focused: itemProps.focused,
            toggleOption: this.toggleOption,
            setOptionIndex: this.setOptionIndex,
            itemProps,
            itemAttrs
          };

          if (options[i] === void 0 || isDeepEqual(option, options[i]) !== true) {
            options[i] = option;
            optionEls[i] = void 0;
          }

          return {
            ...option,
            itemEvents
          }
        })
      },

      dropdownArrowIcon () {
        return this.dropdownIcon !== void 0
          ? this.dropdownIcon
          : this.$q.iconSet.arrow.dropdown
      },

      squaredMenu () {
        return this.optionsCover === false &&
          this.outlined !== true &&
          this.standout !== true &&
          this.borderless !== true &&
          this.rounded !== true
      },

      computedOptionsSelectedClass () {
        return this.optionsSelectedClass !== void 0
          ? this.optionsSelectedClass
          : (this.color !== void 0 ? `text-${this.color}` : '')
      },

      innerOptionsValue () {
        return this.innerValue.map(opt => this.getOptionValue(opt))
      },

      // returns method to get value of an option;
      // takes into account 'option-value' prop
      getOptionValue () {
        return this.__getPropValueFn('optionValue', 'value')
      },

      // returns method to get label of an option;
      // takes into account 'option-label' prop
      getOptionLabel () {
        return this.__getPropValueFn('optionLabel', 'label')
      },

      // returns method to tell if an option is disabled;
      // takes into account 'option-disable' prop
      isOptionDisabled () {
        const fn = this.__getPropValueFn('optionDisable', 'disable');
        return (...args) => fn.apply(null, args) === true
      },

      inputControlEvents () {
        const on = {
          input: this.__onInput,
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          change: this.__onChange,
          keydown: this.__onTargetKeydown,
          keyup: this.__onTargetAutocomplete,
          keypress: this.__onTargetKeypress,
          focus: this.__selectInputText,
          click: e => {
            this.hasDialog === true && stop(e);
          }
        };

        on.compositionstart = on.compositionupdate = on.compositionend = this.__onComposition;

        return on
      },

      virtualScrollItemSizeComputed () {
        return this.virtualScrollItemSize === void 0
          ? (this.optionsDense === true ? 24 : 48)
          : this.virtualScrollItemSize
      },

      comboboxAttrs () {
        const attrs = {
          tabindex: this.tabindex,
          role: 'combobox',
          'aria-label': this.label,
          'aria-autocomplete': this.useInput === true ? 'list' : 'none',
          'aria-expanded': this.menu === true ? 'true' : 'false',
          'aria-owns': `${this.targetUid}_lb`,
          'aria-controls': `${this.targetUid}_lb`
        };

        if (this.optionIndex >= 0) {
          attrs['aria-activedescendant'] = `${this.targetUid}_${this.optionIndex}`;
        }

        return attrs
      },

      listboxAttrs () {
        const attrs = {
          id: `${this.targetUid}_lb`,
          role: 'listbox',
          'aria-multiselectable': this.multiple === true ? 'true' : 'false'
        };

        if (this.optionIndex >= 0) {
          attrs['aria-activedescendant'] = `${this.targetUid}_${this.optionIndex}`;
        }

        return attrs
      }
    },

    methods: {
      getEmittingOptionValue (opt) {
        return this.emitValue === true
          ? this.getOptionValue(opt)
          : opt
      },

      removeAtIndex (index) {
        if (index > -1 && index < this.innerValue.length) {
          if (this.multiple === true) {
            const model = this.value.slice();
            this.$emit('remove', { index, value: model.splice(index, 1)[0] });
            this.$emit('input', model);
          }
          else {
            this.$emit('input', null);
          }
        }
      },

      __removeAtIndexAndFocus (index) {
        this.removeAtIndex(index);
        this.__focus();
      },

      add (opt, unique) {
        const val = this.getEmittingOptionValue(opt);

        if (this.multiple !== true) {
          this.fillInput === true && this.updateInputValue(
            this.getOptionLabel(opt),
            true,
            true
          );

          this.$emit('input', val);
          return
        }

        if (this.innerValue.length === 0) {
          this.$emit('add', { index: 0, value: val });
          this.$emit('input', this.multiple === true ? [ val ] : val);
          return
        }

        if (unique === true && this.isOptionSelected(opt) === true) {
          return
        }

        if (this.maxValues !== void 0 && this.value.length >= this.maxValues) {
          return
        }

        const model = this.value.slice();

        this.$emit('add', { index: model.length, value: val });
        model.push(val);
        this.$emit('input', model);
      },

      toggleOption (opt, keepOpen) {
        if (this.editable !== true || opt === void 0 || this.isOptionDisabled(opt) === true) {
          return
        }

        const optValue = this.getOptionValue(opt);

        if (this.multiple !== true) {
          if (keepOpen !== true) {
            this.updateInputValue(
              this.fillInput === true ? this.getOptionLabel(opt) : '',
              true,
              true
            );

            this.dialogFieldFocused = false;
            document.activeElement.blur();

            this.hidePopup();
          }

          this.$refs.target !== void 0 && this.$refs.target.focus();

          if (
            this.innerValue.length === 0 ||
            isDeepEqual(this.getOptionValue(this.innerValue[0]), optValue) !== true
          ) {
            this.$emit('input', this.emitValue === true ? optValue : opt);
          }
          return
        }

        (this.hasDialog !== true || this.dialogFieldFocused === true) && this.__focus();

        this.__selectInputText();

        if (this.innerValue.length === 0) {
          const val = this.emitValue === true ? optValue : opt;
          this.$emit('add', { index: 0, value: val });
          this.$emit('input', this.multiple === true ? [ val ] : val);
          return
        }

        const
          model = this.value.slice(),
          index = this.innerOptionsValue.findIndex(v => isDeepEqual(v, optValue));

        if (index > -1) {
          this.$emit('remove', { index, value: model.splice(index, 1)[0] });
        }
        else {
          if (this.maxValues !== void 0 && model.length >= this.maxValues) {
            return
          }

          const val = this.emitValue === true ? optValue : opt;

          this.$emit('add', { index: model.length, value: val });
          model.push(val);
        }

        this.$emit('input', model);
      },

      setOptionIndex (index) {
        if (this.$q.platform.is.desktop !== true) { return }

        const val = index > -1 && index < this.virtualScrollLength
          ? index
          : -1;

        if (this.optionIndex !== val) {
          this.optionIndex = val;
        }
      },

      moveOptionSelection (offset = 1, skipInputValue) {
        if (this.menu === true) {
          let index = this.optionIndex;
          do {
            index = normalizeToInterval(
              index + offset,
              -1,
              this.virtualScrollLength - 1
            );
          }
          while (index !== -1 && index !== this.optionIndex && this.isOptionDisabled(this.options[index]) === true)

          if (this.optionIndex !== index) {
            cancelAnimationFrame(this.moveAnimationFrame);
            this.moveAnimationFrame = requestAnimationFrame(() => {
              this.setOptionIndex(index);
              this.scrollTo(index);

              if (skipInputValue !== true && this.useInput === true && this.fillInput === true) {
                this.__setInputValue(index >= 0
                  ? this.getOptionLabel(this.options[index])
                  : this.defaultInputValue
                );
              }
            });
          }
        }
      },

      __getOption (value, innerValueCache) {
        const fn = opt => isDeepEqual(this.getOptionValue(opt), value);
        return this.options.find(fn) || innerValueCache.find(fn) || value
      },

      __getPropValueFn (propName, defaultVal) {
        const val = this[propName] !== void 0
          ? this[propName]
          : defaultVal;

        return typeof val === 'function'
          ? val
          : opt => (opt !== null && typeof opt === 'object' && val in opt ? opt[ val ] : opt)
      },

      isOptionSelected (opt) {
        const val = this.getOptionValue(opt);
        return this.innerOptionsValue.find(v => isDeepEqual(v, val)) !== void 0
      },

      __selectInputText (e) {
        if (
          this.useInput === true &&
          this.$refs.target !== void 0 &&
          (e === void 0 || (this.$refs.target === e.target && e.target.value === this.selectedString))
        ) {
          this.$refs.target.select();
        }
      },

      __onTargetKeyup (e) {
        // if ESC and we have an opened menu
        // then stop propagation (might be caught by a QDialog
        // and so it will also close the QDialog, which is wrong)
        if (isKeyCode(e, 27) === true && this.menu === true) {
          stop(e);
          // on ESC we need to close the dialog also
          this.hidePopup();
          this.__resetInputValue();
        }

        this.$emit('keyup', e);
      },

      __onTargetAutocomplete (e) {
        const { value } = e.target;

        if (e.keyCode !== void 0) {
          this.__onTargetKeyup(e);
          return
        }

        e.target.value = '';
        clearTimeout(this.inputTimer);
        this.__resetInputValue();

        if (typeof value === 'string' && value.length > 0) {
          const needle = value.toLocaleLowerCase();
          const findFn = extractFn => {
            const option = this.options.find(opt => extractFn(opt).toLocaleLowerCase() === needle);

            if (option === void 0) {
              return false
            }

            if (this.innerValue.indexOf(option) === -1) {
              this.toggleOption(option);
            }
            else {
              this.hidePopup();
            }

            return true
          };
          const fillFn = afterFilter => {
            if (findFn(this.getOptionValue) === true) {
              return
            }
            if (findFn(this.getOptionLabel) === true || afterFilter === true) {
              return
            }

            this.filter(value, true, () => fillFn(true));
          };

          fillFn();
        }
        else {
          this.__clearValue(e);
        }
      },

      __onTargetKeypress (e) {
        this.$emit('keypress', e);
      },

      __onTargetKeydown (e) {
        this.$emit('keydown', e);

        if (shouldIgnoreKey(e) === true) {
          return
        }

        const newValueModeValid = this.inputValue.length > 0 &&
          (this.newValueMode !== void 0 || this.qListeners['new-value'] !== void 0);
        const tabShouldSelect = e.shiftKey !== true &&
          this.multiple !== true &&
          (this.optionIndex > -1 || newValueModeValid === true);

        // escape
        if (e.keyCode === 27) {
          prevent(e); // prevent clearing the inputValue
          return
        }

        // tab
        if (e.keyCode === 9 && tabShouldSelect === false) {
          this.__closeMenu();
          return
        }

        if (e.target === void 0 || e.target.id !== this.targetUid) { return }

        // down
        if (
          e.keyCode === 40 &&
          this.innerLoading !== true &&
          this.menu === false
        ) {
          stopAndPrevent(e);
          this.showPopup();
          return
        }

        // backspace
        if (
          e.keyCode === 8 &&
          this.hideSelected !== true &&
          this.inputValue.length === 0
        ) {
          if (this.multiple === true && Array.isArray(this.value)) {
            this.removeAtIndex(this.value.length - 1);
          }
          else if (this.multiple !== true && this.value !== null) {
            this.$emit('input', null);
          }
          return
        }

        // home, end - 36, 35
        if (
          (e.keyCode === 35 || e.keyCode === 36) &&
          (typeof this.inputValue !== 'string' || this.inputValue.length === 0)
        ) {
          stopAndPrevent(e);
          this.optionIndex = -1;
          this.moveOptionSelection(e.keyCode === 36 ? 1 : -1, this.multiple);
        }

        // pg up, pg down - 33, 34
        if (
          (e.keyCode === 33 || e.keyCode === 34) &&
          this.virtualScrollSliceSizeComputed !== void 0
        ) {
          stopAndPrevent(e);
          this.optionIndex = Math.max(
            -1,
            Math.min(
              this.virtualScrollLength,
              this.optionIndex + (e.keyCode === 33 ? -1 : 1) * this.virtualScrollSliceSizeComputed.view
            )
          );
          this.moveOptionSelection(e.keyCode === 33 ? 1 : -1, this.multiple);
        }

        // up, down
        if (e.keyCode === 38 || e.keyCode === 40) {
          stopAndPrevent(e);
          this.moveOptionSelection(e.keyCode === 38 ? -1 : 1, this.multiple);
        }

        const optionsLength = this.virtualScrollLength;

        // clear search buffer if expired
        if (this.searchBuffer === void 0 || this.searchBufferExp < Date.now()) {
          this.searchBuffer = '';
        }

        // keyboard search when not having use-input
        if (
          optionsLength > 0 &&
          this.useInput !== true &&
          e.key !== void 0 &&
          e.key.length === 1 && // printable char
          e.altKey === e.ctrlKey && // not kbd shortcut
          (e.keyCode !== 32 || this.searchBuffer.length > 0) // space in middle of search
        ) {
          this.menu !== true && this.showPopup(e);

          const
            char = e.key.toLocaleLowerCase(),
            keyRepeat = this.searchBuffer.length === 1 && this.searchBuffer[0] === char;

          this.searchBufferExp = Date.now() + 1500;
          if (keyRepeat === false) {
            stopAndPrevent(e);
            this.searchBuffer += char;
          }

          const searchRe = new RegExp('^' + this.searchBuffer.split('').map(l => reEscapeList.indexOf(l) > -1 ? '\\' + l : l).join('.*'), 'i');

          let index = this.optionIndex;

          if (keyRepeat === true || index < 0 || searchRe.test(this.getOptionLabel(this.options[index])) !== true) {
            do {
              index = normalizeToInterval(index + 1, -1, optionsLength - 1);
            }
            while (index !== this.optionIndex && (
              this.isOptionDisabled(this.options[index]) === true ||
              searchRe.test(this.getOptionLabel(this.options[index])) !== true
            ))
          }

          if (this.optionIndex !== index) {
            this.$nextTick(() => {
              this.setOptionIndex(index);
              this.scrollTo(index);

              if (index >= 0 && this.useInput === true && this.fillInput === true) {
                this.__setInputValue(this.getOptionLabel(this.options[index]));
              }
            });
          }

          return
        }

        // enter, space (when not using use-input and not in search), or tab (when not using multiple and option selected)
        // same target is checked above
        if (
          e.keyCode !== 13 &&
          (e.keyCode !== 32 || this.useInput === true || this.searchBuffer !== '') &&
          (e.keyCode !== 9 || tabShouldSelect === false)
        ) { return }

        e.keyCode !== 9 && stopAndPrevent(e);

        if (this.optionIndex > -1 && this.optionIndex < optionsLength) {
          this.toggleOption(this.options[this.optionIndex]);
          return
        }

        if (newValueModeValid === true) {
          const done = (val, mode) => {
            if (mode) {
              if (validateNewValueMode(mode) !== true) {
                return
              }
            }
            else {
              mode = this.newValueMode;
            }

            if (val === void 0 || val === null) {
              return
            }

            this.updateInputValue('', this.multiple !== true, true);

            this[mode === 'toggle' ? 'toggleOption' : 'add'](
              val,
              mode === 'add-unique'
            );

            if (this.multiple !== true) {
              this.$refs.target !== void 0 && this.$refs.target.focus();
              this.hidePopup();
            }
          };

          if (this.qListeners['new-value'] !== void 0) {
            this.$emit('new-value', this.inputValue, done);
          }
          else {
            done(this.inputValue);
          }

          if (this.multiple !== true) {
            return
          }
        }

        if (this.menu === true) {
          this.__closeMenu();
        }
        else if (this.innerLoading !== true) {
          this.showPopup();
        }
      },

      __getVirtualScrollEl () {
        return this.hasDialog === true
          ? this.$refs.menuContent
          : (
            this.$refs.menu !== void 0 && this.$refs.menu.__portal !== void 0
              ? this.$refs.menu.__portal.$el
              : void 0
          )
      },

      __getVirtualScrollTarget () {
        return this.__getVirtualScrollEl()
      },

      __getSelection (h) {
        if (this.hideSelected === true) {
          return []
        }

        if (this.$scopedSlots['selected-item'] !== void 0) {
          return this.selectedScope.map(scope => this.$scopedSlots['selected-item'](scope)).slice()
        }

        if (this.$scopedSlots.selected !== void 0) {
          return [].concat(this.$scopedSlots.selected())
        }

        if (this.useChips === true) {
          return this.selectedScope.map((scope, i) => h(QChip, {
            key: 'rem#' + i,
            props: {
              removable: this.editable === true && this.isOptionDisabled(scope.opt) !== true,
              dense: true,
              textColor: this.color,
              tabindex: this.computedTabindex
            },
            on: cache(this, 'rem#' + i, {
              remove () { scope.removeAtIndex(i); }
            })
          }, [
            h('span', {
              staticClass: 'ellipsis',
              domProps: {
                [scope.sanitize === true ? 'textContent' : 'innerHTML']: this.getOptionLabel(scope.opt)
              }
            })
          ]))
        }

        return [
          h('span', {
            domProps: {
              [this.displayAsText ? 'textContent' : 'innerHTML']: this.displayValue !== void 0
                ? this.displayValue
                : this.selectedString
            }
          })
        ]
      },

      __getControl (h, fromDialog) {
        const child = this.__getSelection(h);
        const isTarget = fromDialog === true || this.dialog !== true || this.hasDialog !== true;

        if (this.useInput === true) {
          child.push(this.__getInput(h, fromDialog, isTarget));
        }
        // there can be only one (when dialog is opened the control in dialog should be target)
        else if (this.editable === true) {
          const attrs = isTarget === true ? this.comboboxAttrs : void 0;

          child.push(
            h('input', {
              ref: isTarget === true ? 'target' : void 0,
              key: 'd_t',
              staticClass: 'q-select__focus-target',
              attrs: {
                id: isTarget === true ? this.targetUid : void 0,
                readonly: true,
                'data-autofocus': (fromDialog === true ? isTarget === true : this.autofocus) || void 0,
                ...attrs
              },
              on: cache(this, 'f-tget', {
                keydown: this.__onTargetKeydown,
                keyup: this.__onTargetKeyup,
                keypress: this.__onTargetKeypress
              })
            })
          );

          if (isTarget === true && typeof this.autocomplete === 'string' && this.autocomplete.length > 0) {
            child.push(
              h('input', {
                key: 'autoinp',
                staticClass: 'q-select__autocomplete-input',
                attrs: { autocomplete: this.autocomplete },
                on: cache(this, 'autoinp', {
                  keyup: this.__onTargetAutocomplete
                })
              })
            );
          }
        }

        if (this.nameProp !== void 0 && this.disable !== true && this.innerOptionsValue.length > 0) {
          const opts = this.innerOptionsValue.map(value => h('option', {
            attrs: { value, selected: true }
          }));

          child.push(
            h('select', {
              staticClass: 'hidden',
              attrs: {
                name: this.nameProp,
                multiple: this.multiple
              }
            }, opts)
          );
        }

        const attrs = this.useInput === true || isTarget !== true ? void 0 : this.qAttrs;

        return h('div', { staticClass: 'q-field__native row items-center', attrs }, child)
      },

      __getOptions (h) {
        if (this.menu !== true) {
          return void 0
        }

        if (this.noOptions === true) {
          return this.$scopedSlots['no-option'] !== void 0
            ? this.$scopedSlots['no-option']({ inputValue: this.inputValue })
            : void 0
        }

        if (
          this.$scopedSlots.option !== void 0 &&
          this.__optionScopeCache.optionSlot !== this.$scopedSlots.option
        ) {
          this.__optionScopeCache.optionSlot = this.$scopedSlots.option;
          this.__optionScopeCache.optionEls = [];
        }

        const fn = this.$scopedSlots.option !== void 0
          ? this.$scopedSlots.option
          : scope => h(QItem, {
            key: scope.index,
            props: scope.itemProps,
            attrs: scope.itemAttrs,
            on: scope.itemEvents
          }, [
            h(QItemSection, [
              h(QItemLabel, {
                domProps: {
                  [scope.sanitize === true ? 'textContent' : 'innerHTML']: this.getOptionLabel(scope.opt)
                }
              })
            ])
          ]);

        const { optionEls } = this.__optionScopeCache;

        let options = this.__padVirtualScroll(h, 'div', this.optionScope.map((scope, i) => {
          if (optionEls[i] === void 0) {
            optionEls[i] = fn(scope);
          }

          return optionEls[i]
        }));

        if (this.$scopedSlots['before-options'] !== void 0) {
          options = this.$scopedSlots['before-options']().concat(options);
        }

        return mergeSlot(options, this, 'after-options')
      },

      __getInnerAppend (h) {
        return this.loading !== true && this.innerLoadingIndicator !== true && this.hideDropdownIcon !== true
          ? [
            h(QIcon, {
              staticClass: 'q-select__dropdown-icon' + (this.menu === true ? ' rotate-180' : ''),
              props: { name: this.dropdownArrowIcon }
            })
          ]
          : null
      },

      __getInput (h, fromDialog, isTarget) {
        const attrs = isTarget === true ? { ...this.comboboxAttrs, ...this.qAttrs } : void 0;

        const options = {
          ref: isTarget === true ? 'target' : void 0,
          key: 'i_t',
          staticClass: 'q-field__input q-placeholder col',
          style: this.inputStyle,
          class: this.computedInputClass,
          domProps: { value: this.inputValue !== void 0 ? this.inputValue : '' },
          attrs: {
            // required for Android in order to show ENTER key when in form
            type: 'search',
            ...attrs,
            id: isTarget === true ? this.targetUid : void 0,
            maxlength: this.maxlength, // this is converted to prop by QField
            autocomplete: this.autocomplete,
            'data-autofocus': (fromDialog === true ? isTarget === true : this.autofocus) || void 0,
            disabled: this.disable === true,
            readonly: this.readonly === true
          },
          on: this.inputControlEvents
        };

        if (fromDialog !== true && this.hasDialog === true) {
          options.staticClass += ' no-pointer-events';
        }

        return h('input', options)
      },

      __onChange (e) {
        this.__onComposition(e);
      },

      __onInput (e) {
        clearTimeout(this.inputTimer);

        if (e && e.target && e.target.qComposing === true) {
          return
        }

        this.__setInputValue(e.target.value || '');
        // mark it here as user input so that if updateInputValue is called
        // before filter is called the indicator is reset
        this.userInputValue = true;
        this.defaultInputValue = this.inputValue;

        if (
          this.focused !== true &&
          (this.hasDialog !== true || this.dialogFieldFocused === true)
        ) {
          this.__focus();
        }

        if (this.qListeners.filter !== void 0) {
          this.inputTimer = setTimeout(() => {
            this.filter(this.inputValue);
          }, this.inputDebounce);
        }
      },

      __setInputValue (inputValue) {
        if (this.inputValue !== inputValue) {
          this.inputValue = inputValue;
          this.$emit('input-value', inputValue);
        }
      },

      updateInputValue (val, noFiltering, internal) {
        this.userInputValue = internal !== true;

        if (this.useInput === true) {
          this.__setInputValue(val);

          if (noFiltering === true || internal !== true) {
            this.defaultInputValue = val;
          }

          noFiltering !== true && this.filter(val);
        }
      },

      filter (val, keepClosed, afterUpdateFn) {
        if (this.qListeners.filter === void 0 || (keepClosed !== true && this.focused !== true)) {
          return
        }

        if (this.innerLoading === true) {
          this.$emit('filter-abort');
        }
        else {
          this.innerLoading = true;
          this.innerLoadingIndicator = true;
        }

        if (
          val !== '' &&
          this.multiple !== true &&
          this.innerValue.length > 0 &&
          this.userInputValue !== true &&
          val === this.getOptionLabel(this.innerValue[0])
        ) {
          val = '';
        }

        const filterId = setTimeout(() => {
          this.menu === true && (this.menu = false);
        }, 10);
        clearTimeout(this.filterId);
        this.filterId = filterId;

        this.$emit(
          'filter',
          val,
          (fn, afterFn) => {
            if ((keepClosed === true || this.focused === true) && this.filterId === filterId) {
              clearTimeout(this.filterId);

              typeof fn === 'function' && fn();

              // hide indicator to allow arrow to animate
              this.innerLoadingIndicator = false;

              this.$nextTick(() => {
                this.innerLoading = false;

                if (this.editable === true) {
                  if (keepClosed === true) {
                    this.menu === true && this.hidePopup();
                  }
                  else if (this.menu === true) {
                    this.__updateMenu(true);
                  }
                  else {
                    this.menu = true;
                    this.hasDialog === true && (this.dialog = true);
                  }
                }

                typeof afterFn === 'function' && this.$nextTick(() => { afterFn(this); });
                typeof afterUpdateFn === 'function' && this.$nextTick(() => { afterUpdateFn(this); });
              });
            }
          },
          () => {
            if (this.focused === true && this.filterId === filterId) {
              clearTimeout(this.filterId);
              this.innerLoading = false;
              this.innerLoadingIndicator = false;
            }
            this.menu === true && (this.menu = false);
          }
        );
      },

      __getControlEvents () {
        const focusout = e => {
          this.__onControlFocusout(e, () => {
            this.__resetInputValue();
            this.__closeMenu();
          });
        };

        return {
          focusin: this.__onControlFocusin,
          focusout,
          'popup-show': this.__onControlPopupShow,
          'popup-hide': e => {
            e !== void 0 && stop(e);
            this.$emit('popup-hide', e);
            this.hasPopupOpen = false;
            focusout(e);
          },
          click: e => {
            // label from QField will propagate click on the input (except IE)
            prevent(e);

            if (this.hasDialog !== true && this.menu === true) {
              this.__closeMenu();
              this.$refs.target !== void 0 && this.$refs.target.focus();
              return
            }

            this.showPopup(e);
          }
        }
      },

      __getControlChild (h) {
        if (
          this.editable !== false && (
            this.dialog === true || // dialog always has menu displayed, so need to render it
            this.noOptions !== true ||
            this.$scopedSlots['no-option'] !== void 0
          )
        ) {
          return this[`__get${this.hasDialog === true ? 'Dialog' : 'Menu'}`](h)
        }
      },

      __getMenu (h) {
        return h(QMenu, {
          key: 'menu',
          ref: 'menu',
          props: {
            value: this.menu,
            fit: this.menuShrink !== true,
            cover: this.optionsCover === true && this.noOptions !== true && this.useInput !== true,
            anchor: this.menuAnchor,
            self: this.menuSelf,
            offset: this.menuOffset,
            contentClass: this.menuContentClass,
            contentStyle: this.popupContentStyle,
            dark: this.isOptionsDark,
            noParentEvent: true,
            noRefocus: true,
            noFocus: true,
            square: this.squaredMenu,
            transitionShow: this.transitionShow,
            transitionHide: this.transitionHide,
            separateClosePopup: true
          },
          attrs: this.listboxAttrs,
          on: cache(this, 'menu', {
            '&scroll': this.__onVirtualScrollEvt,
            'before-hide': this.__closeMenu,
            show: this.__onMenuShow
          })
        }, this.__getOptions(h))
      },

      __onMenuShow () {
        this.__setVirtualScrollSize();
      },

      __onDialogFieldFocus (e) {
        stop(e);
        this.$refs.target !== void 0 && this.$refs.target.focus();
        this.dialogFieldFocused = true;
        window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0);
      },

      __onDialogFieldBlur (e) {
        stop(e);
        this.$nextTick(() => {
          this.dialogFieldFocused = false;
        });
      },

      __getDialog (h) {
        const content = [
          h(QField, {
            staticClass: `col-auto ${this.fieldClass}`,
            props: {
              ...this.$props,
              for: this.targetUid,
              dark: this.isOptionsDark,
              square: true,
              filled: true,
              itemAligned: false,
              loading: this.innerLoadingIndicator,
              stackLabel: this.inputValue.length > 0
            },
            on: {
              ...this.qListeners,
              focus: this.__onDialogFieldFocus,
              blur: this.__onDialogFieldBlur
            },
            scopedSlots: {
              ...this.$scopedSlots,
              rawControl: () => this.__getControl(h, true),
              before: void 0,
              after: void 0
            }
          })
        ];

        this.menu === true && content.push(
          h('div', {
            key: 'virtMenu',
            ref: 'menuContent',
            staticClass: 'col scroll',
            class: this.menuContentClass,
            style: this.popupContentStyle,
            attrs: this.listboxAttrs,
            on: cache(this, 'virtMenu', {
              click: prevent,
              '&scroll': this.__onVirtualScrollEvt
            })
          }, this.__getOptions(h))
        );

        return h(QDialog, {
          key: 'dialog',
          ref: 'dialog',
          props: {
            value: this.dialog,
            dark: this.isOptionsDark,
            position: this.useInput === true ? 'top' : void 0,
            transitionShow: this.transitionShowComputed,
            transitionHide: this.transitionHide
          },
          on: cache(this, 'dialog', {
            'before-hide': this.__onDialogBeforeHide,
            hide: this.__onDialogHide,
            show: this.__onDialogShow
          })
        }, [
          h('div', {
            staticClass: 'q-select__dialog' +
              (this.isOptionsDark === true ? ' q-select__dialog--dark q-dark' : '') +
              (this.dialogFieldFocused === true ? ' q-select__dialog--focused' : '')
          }, content)
        ])
      },

      __onDialogBeforeHide () {
        if (this.useInput !== true || this.$q.platform.is.desktop === true) {
          this.$refs.dialog.__refocusTarget = this.$el.querySelector('.q-field__native > [tabindex]:last-child');
        }
        this.focused = false;
        this.dialogFieldFocused = false;
      },

      __onDialogHide (e) {
        if (this.$q.platform.is.desktop !== true) {
          document.activeElement.blur();
        }
        this.hidePopup();
        this.focused === false && this.$emit('blur', e);
        this.__resetInputValue();
      },

      __onDialogShow () {
        const el = document.activeElement;
        // IE can have null document.activeElement
        if (
          (el === null || el.id !== this.targetUid) &&
          this.$refs.target !== el &&
          this.$refs.target !== void 0
        ) {
          this.$refs.target.focus();
        }

        this.__setVirtualScrollSize();
      },

      __closeMenu () {
        if (this.__optionScopeCache !== void 0) {
          this.__optionScopeCache.optionEls = [];
        }

        if (this.dialog === true) {
          return
        }

        this.optionIndex = -1;

        if (this.menu === true) {
          this.menu = false;
        }

        if (this.focused === false) {
          clearTimeout(this.filterId);
          this.filterId = void 0;

          if (this.innerLoading === true) {
            this.$emit('filter-abort');
            this.innerLoading = false;
            this.innerLoadingIndicator = false;
          }
        }
      },

      showPopup (e) {
        if (this.editable !== true) {
          return
        }

        if (this.hasDialog === true) {
          this.__onControlFocusin(e);
          this.dialog = true;
          this.$nextTick(() => {
            this.__focus();
          });
        }
        else {
          this.__focus();
        }

        if (this.qListeners.filter !== void 0) {
          this.filter(this.inputValue);
        }
        else if (this.noOptions !== true || this.$scopedSlots['no-option'] !== void 0) {
          this.menu = true;
        }
      },

      hidePopup () {
        this.dialog = false;
        this.__closeMenu();
      },

      __resetInputValue () {
        this.useInput === true && this.updateInputValue(
          this.multiple !== true && this.fillInput === true && this.innerValue.length > 0
            ? this.getOptionLabel(this.innerValue[0]) || ''
            : '',
          true,
          true
        );
      },

      __updateMenu (show) {
        let optionIndex = -1;

        if (show === true) {
          if (this.innerValue.length > 0) {
            const val = this.getOptionValue(this.innerValue[0]);
            optionIndex = this.options.findIndex(v => isDeepEqual(this.getOptionValue(v), val));
          }

          this.__resetVirtualScroll(optionIndex);
        }

        this.setOptionIndex(optionIndex);
      },

      __onPreRender () {
        this.hasDialog = this.$q.platform.is.mobile !== true && this.behavior !== 'dialog'
          ? false
          : this.behavior !== 'menu' && (
            this.useInput === true
              ? this.$scopedSlots['no-option'] !== void 0 || this.qListeners.filter !== void 0 || this.noOptions === false
              : true
          );

        this.transitionShowComputed = this.hasDialog === true && this.useInput === true && this.$q.platform.is.ios === true
          ? 'fade'
          : this.transitionShow;
      },

      __onPostRender () {
        if (this.dialog === false && this.$refs.menu !== void 0) {
          this.$refs.menu.updatePosition();
        }
      },

      updateMenuPosition () {
        this.__onPostRender();
      }
    },

    beforeMount () {
      this.__optionScopeCache = {
        optionSlot: this.$scopedSlots.option,
        options: [],
        optionEls: []
      };
    },

    beforeDestroy () {
      this.__optionScopeCache = void 0;
      clearTimeout(this.inputTimer);
    }
  });

  const skeletonTypes = [
    'text', 'rect', 'circle',
    'QBtn', 'QBadge', 'QChip', 'QToolbar',
    'QCheckbox', 'QRadio', 'QToggle',
    'QSlider', 'QRange', 'QInput',
    'QAvatar'
  ];

  const skeletonAnimations = [
    'wave', 'pulse', 'pulse-x', 'pulse-y', 'fade', 'blink', 'none'
  ];

  var QSkeleton = Vue.extend({
    name: 'QSkeleton',

    mixins: [ DarkMixin, TagMixin, ListenersMixin ],

    props: {
      type: {
        type: String,
        validator: v => skeletonTypes.includes(v),
        default: 'rect'
      },

      animation: {
        type: String,
        validator: v => skeletonAnimations.includes(v),
        default: 'wave'
      },

      square: Boolean,
      bordered: Boolean,

      size: String,
      width: String,
      height: String
    },

    computed: {
      style () {
        return this.size !== void 0
          ? { width: this.size, height: this.size }
          : { width: this.width, height: this.height }
      },

      classes () {
        return `q-skeleton--${this.isDark === true ? 'dark' : 'light'} q-skeleton--type-${this.type}` +
          (this.animation !== 'none' ? ` q-skeleton--anim q-skeleton--anim-${this.animation}` : '') +
          (this.square === true ? ' q-skeleton--square' : '') +
          (this.bordered === true ? ' q-skeleton--bordered' : '')
      }
    },

    render (h) {
      return h(this.tag, {
        staticClass: 'q-skeleton',
        class: this.classes,
        style: this.style,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  const slotsDef = [
    ['left', 'center', 'start', 'width'],
    ['right', 'center', 'end', 'width'],
    ['top', 'start', 'center', 'height'],
    ['bottom', 'end', 'center', 'height']
  ];

  var QSlideItem = Vue.extend({
    name: 'QSlideItem',

    mixins: [ DarkMixin, ListenersMixin ],

    props: {
      leftColor: String,
      rightColor: String,
      topColor: String,
      bottomColor: String
    },

    directives: {
      TouchPan
    },

    computed: {
      langDir () {
        return this.$q.lang.rtl === true
          ? { left: 'right', right: 'left' }
          : { left: 'left', right: 'right' }
      }
    },

    methods: {
      reset () {
        this.$refs.content.style.transform = 'translate(0,0)';
        this.__emitSlide(this.__showing, 0, true);
      },

      __emitSlide (side, ratio, isReset) {
        this.qListeners.slide !== void 0 && this.$emit('slide', { side, ratio, isReset });
      },

      __pan (evt) {
        const node = this.$refs.content;

        if (evt.isFirst) {
          this.__dir = null;
          this.__size = { left: 0, right: 0, top: 0, bottom: 0 };
          this.__scale = 0;

          node.classList.add('no-transition');

          slotsDef.forEach(slot => {
            if (this.$scopedSlots[slot[0]] !== void 0) {
              const node = this.$refs[slot[0] + 'Content'];
              node.style.transform = 'scale(1)';
              this.__size[slot[0]] = node.getBoundingClientRect()[slot[3]];
            }
          });

          this.__axis = (evt.direction === 'up' || evt.direction === 'down')
            ? 'Y'
            : 'X';
        }
        else if (evt.isFinal) {
          node.classList.remove('no-transition');

          if (this.__scale === 1) {
            node.style.transform = `translate${this.__axis}(${this.__dir * 100}%)`;

            this.timer = setTimeout(() => {
              this.$emit(this.__showing, { reset: this.reset });
              this.$emit('action', { side: this.__showing, reset: this.reset });
            }, 230);
          }
          else {
            node.style.transform = 'translate(0,0)';
            this.__emitSlide(this.__showing, 0, true);
          }

          return
        }
        else {
          evt.direction = this.__axis === 'X'
            ? evt.offset.x < 0 ? 'left' : 'right'
            : evt.offset.y < 0 ? 'up' : 'down';
        }

        if (
          (this.$scopedSlots.left === void 0 && evt.direction === this.langDir.right) ||
          (this.$scopedSlots.right === void 0 && evt.direction === this.langDir.left) ||
          (this.$scopedSlots.top === void 0 && evt.direction === 'down') ||
          (this.$scopedSlots.bottom === void 0 && evt.direction === 'up')
        ) {
          node.style.transform = 'translate(0,0)';
          return
        }

        let showing, dir, dist;

        if (this.__axis === 'X') {
          dir = evt.direction === 'left' ? -1 : 1;
          showing = dir === 1 ? this.langDir.left : this.langDir.right;
          dist = evt.distance.x;
        }
        else {
          dir = evt.direction === 'up' ? -2 : 2;
          showing = dir === 2 ? 'top' : 'bottom';
          dist = evt.distance.y;
        }

        if (this.__dir !== null && Math.abs(dir) !== Math.abs(this.__dir)) {
          return
        }

        if (this.__dir !== dir) {
          ['left', 'right', 'top', 'bottom'].forEach(d => {
            if (this.$refs[d] !== void 0) {
              this.$refs[d].style.visibility = showing === d
                ? 'visible'
                : 'hidden';
            }
          });
          this.__showing = showing;
          this.__dir = dir;
        }

        this.__scale = Math.max(0, Math.min(1, (dist - 40) / this.__size[showing]));

        node.style.transform = `translate${this.__axis}(${dist * dir / Math.abs(dir)}px)`;
        this.$refs[`${showing}Content`].style.transform = `scale(${this.__scale})`;

        this.__emitSlide(showing, this.__scale, false);
      }
    },

    render (h) {
      const
        content = [],
        slots = {
          left: this.$scopedSlots[this.langDir.right] !== void 0,
          right: this.$scopedSlots[this.langDir.left] !== void 0,
          up: this.$scopedSlots.bottom !== void 0,
          down: this.$scopedSlots.top !== void 0
        },
        dirs = Object.keys(slots).filter(key => slots[key] === true);

      slotsDef.forEach(slot => {
        const dir = slot[0];

        if (this.$scopedSlots[dir] !== void 0) {
          content.push(
            h('div', {
              ref: dir,
              class: `q-slide-item__${dir} absolute-full row no-wrap items-${slot[1]} justify-${slot[2]}` +
                (this[dir + 'Color'] !== void 0 ? ` bg-${this[dir + 'Color']}` : '')
            }, [
              h('div', { ref: dir + 'Content' }, this.$scopedSlots[dir]())
            ])
          );
        }
      });

      content.push(
        h('div', {
          ref: 'content',
          key: 'content',
          staticClass: 'q-slide-item__content',
          directives: dirs.length > 0
            ? cacheWithFn(this, 'dir#' + dirs.join(''), () => {
              const modifiers = {
                prevent: true,
                stop: true,
                mouse: true
              };

              dirs.forEach(dir => {
                modifiers[dir] = true;
              });

              return [{
                name: 'touch-pan',
                value: this.__pan,
                modifiers
              }]
            })
            : null
        }, slot(this, 'default'))
      );

      return h('div', {
        staticClass: 'q-slide-item q-item-type overflow-hidden',
        class: this.isDark === true ? 'q-slide-item--dark q-dark' : '',
        on: { ...this.qListeners }
      }, content)
    },

    beforeDestroy () {
      clearTimeout(this.timer);
    }
  });

  var QSpace = Vue.extend({
    name: 'QSpace',

    mixins: [ ListenersMixin ],

    render (h) {
      return h('div', {
        staticClass: 'q-space',
        on: { ...this.qListeners }
      })
    }
  });

  var QSpinnerAudio = Vue.extend({
    name: 'QSpinnerAudio',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'fill': 'currentColor',
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 55 80',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('g', {
          attrs: {
            'transform': 'matrix(1 0 0 -1 0 80)'
          }
        }, [
          h('rect', {
            attrs: {
              'width': '10',
              'height': '20',
              'rx': '3'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'height',
                'begin': '0s',
                'dur': '4.3s',
                'values': '20;45;57;80;64;32;66;45;64;23;66;13;64;56;34;34;2;23;76;79;20',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('rect', {
            attrs: {
              'x': '15',
              'width': '10',
              'height': '80',
              'rx': '3'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'height',
                'begin': '0s',
                'dur': '2s',
                'values': '80;55;33;5;75;23;73;33;12;14;60;80',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('rect', {
            attrs: {
              'x': '30',
              'width': '10',
              'height': '50',
              'rx': '3'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'height',
                'begin': '0s',
                'dur': '1.4s',
                'values': '50;34;78;23;56;23;34;76;80;54;21;50',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('rect', {
            attrs: {
              'x': '45',
              'width': '10',
              'height': '30',
              'rx': '3'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'height',
                'begin': '0s',
                'dur': '2s',
                'values': '30;45;13;80;56;72;45;76;34;23;67;30',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSpinnerBall = Vue.extend({
    name: 'QSpinnerBall',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'stroke': 'currentColor',
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 57 57',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('g', {
          attrs: {
            'transform': 'translate(1 1)',
            'stroke-width': '2',
            'fill': 'none',
            'fill-rule': 'evenodd'
          }
        }, [
          h('circle', {
            attrs: {
              'cx': '5',
              'cy': '50',
              'r': '5'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'cy',
                'begin': '0s',
                'dur': '2.2s',
                'values': '50;5;50;50',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            }),
            h('animate', {
              attrs: {
                'attributeName': 'cx',
                'begin': '0s',
                'dur': '2.2s',
                'values': '5;27;49;5',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('circle', {
            attrs: {
              'cx': '27',
              'cy': '5',
              'r': '5'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'cy',
                'begin': '0s',
                'dur': '2.2s',
                'from': '5',
                'to': '5',
                'values': '5;50;50;5',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            }),
            h('animate', {
              attrs: {
                'attributeName': 'cx',
                'begin': '0s',
                'dur': '2.2s',
                'from': '27',
                'to': '27',
                'values': '27;49;5;27',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('circle', {
            attrs: {
              'cx': '49',
              'cy': '50',
              'r': '5'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'cy',
                'begin': '0s',
                'dur': '2.2s',
                'values': '50;50;5;50',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            }),
            h('animate', {
              attrs: {
                'attributeName': 'cx',
                'from': '49',
                'to': '49',
                'begin': '0s',
                'dur': '2.2s',
                'values': '49;5;27;49',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSpinnerBars = Vue.extend({
    name: 'QSpinnerBars',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'fill': 'currentColor',
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 135 140',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('rect', {
          attrs: {
            'y': '10',
            'width': '15',
            'height': '120',
            'rx': '6'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'height',
              'begin': '0.5s',
              'dur': '1s',
              'values': '120;110;100;90;80;70;60;50;40;140;120',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          }),
          h('animate', {
            attrs: {
              'attributeName': 'y',
              'begin': '0.5s',
              'dur': '1s',
              'values': '10;15;20;25;30;35;40;45;50;0;10',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('rect', {
          attrs: {
            'x': '30',
            'y': '10',
            'width': '15',
            'height': '120',
            'rx': '6'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'height',
              'begin': '0.25s',
              'dur': '1s',
              'values': '120;110;100;90;80;70;60;50;40;140;120',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          }),
          h('animate', {
            attrs: {
              'attributeName': 'y',
              'begin': '0.25s',
              'dur': '1s',
              'values': '10;15;20;25;30;35;40;45;50;0;10',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('rect', {
          attrs: {
            'x': '60',
            'width': '15',
            'height': '140',
            'rx': '6'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'height',
              'begin': '0s',
              'dur': '1s',
              'values': '120;110;100;90;80;70;60;50;40;140;120',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          }),
          h('animate', {
            attrs: {
              'attributeName': 'y',
              'begin': '0s',
              'dur': '1s',
              'values': '10;15;20;25;30;35;40;45;50;0;10',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('rect', {
          attrs: {
            'x': '90',
            'y': '10',
            'width': '15',
            'height': '120',
            'rx': '6'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'height',
              'begin': '0.25s',
              'dur': '1s',
              'values': '120;110;100;90;80;70;60;50;40;140;120',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          }),
          h('animate', {
            attrs: {
              'attributeName': 'y',
              'begin': '0.25s',
              'dur': '1s',
              'values': '10;15;20;25;30;35;40;45;50;0;10',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('rect', {
          attrs: {
            'x': '120',
            'y': '10',
            'width': '15',
            'height': '120',
            'rx': '6'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'height',
              'begin': '0.5s',
              'dur': '1s',
              'values': '120;110;100;90;80;70;60;50;40;140;120',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          }),
          h('animate', {
            attrs: {
              'attributeName': 'y',
              'begin': '0.5s',
              'dur': '1s',
              'values': '10;15;20;25;30;35;40;45;50;0;10',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ])
      ])
    }
  });

  var QSpinnerBox = Vue.extend({
    name: 'QSpinnerBox',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'xmlns': 'http://www.w3.org/2000/svg',
          'viewBox': '0 0 100 100',
          'preserveAspectRatio': 'xMidYMid'
        }
      }, [
        h('rect', {
          attrs: {
            'x': '25',
            'y': '25',
            'width': '50',
            'height': '50',
            'fill': 'none',
            'stroke-width': '4',
            'stroke': 'currentColor'
          }
        }, [
          h('animateTransform', {
            attrs: {
              'id': 'spinnerBox',
              'attributeName': 'transform',
              'type': 'rotate',
              'from': '0 50 50',
              'to': '180 50 50',
              'dur': '0.5s',
              'begin': 'rectBox.end'
            }
          })
        ]),
        h('rect', {
          attrs: {
            'x': '27',
            'y': '27',
            'width': '46',
            'height': '50',
            'fill': 'currentColor'
          }
        }, [
          h('animate', {
            attrs: {
              'id': 'rectBox',
              'attributeName': 'height',
              'begin': '0s;spinnerBox.end',
              'dur': '1.3s',
              'from': '50',
              'to': '0',
              'fill': 'freeze'
            }
          })
        ])
      ])
    }
  });

  var QSpinnerClock = Vue.extend({
    name: 'QSpinnerClock',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'xmlns': 'http://www.w3.org/2000/svg',
          'viewBox': '0 0 100 100',
          'preserveAspectRatio': 'xMidYMid'
        }
      }, [
        h('circle', {
          attrs: {
            'cx': '50',
            'cy': '50',
            'r': '48',
            'fill': 'none',
            'stroke-width': '4',
            'stroke-miterlimit': '10',
            'stroke': 'currentColor'
          }
        }),
        h('line', {
          attrs: {
            'stroke-linecap': 'round',
            'stroke-width': '4',
            'stroke-miterlimit': '10',
            'stroke': 'currentColor',
            'x1': '50',
            'y1': '50',
            'x2': '85',
            'y2': '50.5'
          }
        }, [
          h('animateTransform', {
            attrs: {
              'attributeName': 'transform',
              'type': 'rotate',
              'from': '0 50 50',
              'to': '360 50 50',
              'dur': '2s',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('line', {
          attrs: {
            'stroke-linecap': 'round',
            'stroke-width': '4',
            'stroke-miterlimit': '10',
            'stroke': 'currentColor',
            'x1': '50',
            'y1': '50',
            'x2': '49.5',
            'y2': '74'
          }
        }, [
          h('animateTransform', {
            attrs: {
              'attributeName': 'transform',
              'type': 'rotate',
              'from': '0 50 50',
              'to': '360 50 50',
              'dur': '15s',
              'repeatCount': 'indefinite'
            }
          })
        ])
      ])
    }
  });

  var QSpinnerComment = Vue.extend({
    name: 'QSpinnerComment',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'xmlns': 'http://www.w3.org/2000/svg',
          'viewBox': '0 0 100 100',
          'preserveAspectRatio': 'xMidYMid'
        }
      }, [
        h('rect', {
          attrs: {
            'x': '0',
            'y': '0',
            'width': '100',
            'height': '100',
            'fill': 'none'
          }
        }),
        h('path', {
          attrs: {
            'd': 'M78,19H22c-6.6,0-12,5.4-12,12v31c0,6.6,5.4,12,12,12h37.2c0.4,3,1.8,5.6,3.7,7.6c2.4,2.5,5.1,4.1,9.1,4 c-1.4-2.1-2-7.2-2-10.3c0-0.4,0-0.8,0-1.3h8c6.6,0,12-5.4,12-12V31C90,24.4,84.6,19,78,19z',
            'fill': 'currentColor'
          }
        }),
        h('circle', {
          attrs: {
            'cx': '30',
            'cy': '47',
            'r': '5',
            'fill': '#fff'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'opacity',
              'from': '0',
              'to': '1',
              'values': '0;1;1',
              'keyTimes': '0;0.2;1',
              'dur': '1s',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '50',
            'cy': '47',
            'r': '5',
            'fill': '#fff'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'opacity',
              'from': '0',
              'to': '1',
              'values': '0;0;1;1',
              'keyTimes': '0;0.2;0.4;1',
              'dur': '1s',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '70',
            'cy': '47',
            'r': '5',
            'fill': '#fff'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'opacity',
              'from': '0',
              'to': '1',
              'values': '0;0;1;1',
              'keyTimes': '0;0.4;0.6;1',
              'dur': '1s',
              'repeatCount': 'indefinite'
            }
          })
        ])
      ])
    }
  });

  var QSpinnerCube = Vue.extend({
    name: 'QSpinnerCube',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'xmlns': 'http://www.w3.org/2000/svg',
          'viewBox': '0 0 100 100',
          'preserveAspectRatio': 'xMidYMid'
        }
      }, [
        h('rect', {
          attrs: {
            'x': '0',
            'y': '0',
            'width': '100',
            'height': '100',
            'fill': 'none'
          }
        }),
        h('g', {
          attrs: {
            'transform': 'translate(25 25)'
          }
        }, [
          h('rect', {
            attrs: {
              'x': '-20',
              'y': '-20',
              'width': '40',
              'height': '40',
              'fill': 'currentColor',
              'opacity': '0.9'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'scale',
                'from': '1.5',
                'to': '1',
                'repeatCount': 'indefinite',
                'begin': '0s',
                'dur': '1s',
                'calcMode': 'spline',
                'keySplines': '0.2 0.8 0.2 0.8',
                'keyTimes': '0;1'
              }
            })
          ])
        ]),
        h('g', {
          attrs: {
            'transform': 'translate(75 25)'
          }
        }, [
          h('rect', {
            attrs: {
              'x': '-20',
              'y': '-20',
              'width': '40',
              'height': '40',
              'fill': 'currentColor',
              'opacity': '0.8'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'scale',
                'from': '1.5',
                'to': '1',
                'repeatCount': 'indefinite',
                'begin': '0.1s',
                'dur': '1s',
                'calcMode': 'spline',
                'keySplines': '0.2 0.8 0.2 0.8',
                'keyTimes': '0;1'
              }
            })
          ])
        ]),
        h('g', {
          attrs: {
            'transform': 'translate(25 75)'
          }
        }, [
          h('rect', {
            staticClass: 'cube',
            attrs: {
              'x': '-20',
              'y': '-20',
              'width': '40',
              'height': '40',
              'fill': 'currentColor',
              'opacity': '0.7'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'scale',
                'from': '1.5',
                'to': '1',
                'repeatCount': 'indefinite',
                'begin': '0.3s',
                'dur': '1s',
                'calcMode': 'spline',
                'keySplines': '0.2 0.8 0.2 0.8',
                'keyTimes': '0;1'
              }
            })
          ])
        ]),
        h('g', {
          attrs: {
            'transform': 'translate(75 75)'
          }
        }, [
          h('rect', {
            staticClass: 'cube',
            attrs: {
              'x': '-20',
              'y': '-20',
              'width': '40',
              'height': '40',
              'fill': 'currentColor',
              'opacity': '0.6'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'scale',
                'from': '1.5',
                'to': '1',
                'repeatCount': 'indefinite',
                'begin': '0.2s',
                'dur': '1s',
                'calcMode': 'spline',
                'keySplines': '0.2 0.8 0.2 0.8',
                'keyTimes': '0;1'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSpinnerDots = Vue.extend({
    name: 'QSpinnerDots',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'fill': 'currentColor',
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 120 30',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('circle', {
          attrs: {
            'cx': '15',
            'cy': '15',
            'r': '15'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'r',
              'from': '15',
              'to': '15',
              'begin': '0s',
              'dur': '0.8s',
              'values': '15;9;15',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          }),
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'from': '1',
              'to': '1',
              'begin': '0s',
              'dur': '0.8s',
              'values': '1;.5;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '60',
            'cy': '15',
            'r': '9',
            'fill-opacity': '.3'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'r',
              'from': '9',
              'to': '9',
              'begin': '0s',
              'dur': '0.8s',
              'values': '9;15;9',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          }),
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'from': '.5',
              'to': '.5',
              'begin': '0s',
              'dur': '0.8s',
              'values': '.5;1;.5',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '105',
            'cy': '15',
            'r': '15'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'r',
              'from': '15',
              'to': '15',
              'begin': '0s',
              'dur': '0.8s',
              'values': '15;9;15',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          }),
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'from': '1',
              'to': '1',
              'begin': '0s',
              'dur': '0.8s',
              'values': '1;.5;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ])
      ])
    }
  });

  var QSpinnerFacebook = Vue.extend({
    name: 'QSpinnerFacebook',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 100 100',
          'xmlns': 'http://www.w3.org/2000/svg',
          'preserveAspectRatio': 'xMidYMid'
        }
      }, [
        h('g', {
          attrs: {
            'transform': 'translate(20 50)'
          }
        }, [
          h('rect', {
            attrs: {
              'x': '-10',
              'y': '-30',
              'width': '20',
              'height': '60',
              'fill': 'currentColor',
              'opacity': '0.6'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'scale',
                'from': '2',
                'to': '1',
                'begin': '0s',
                'repeatCount': 'indefinite',
                'dur': '1s',
                'calcMode': 'spline',
                'keySplines': '0.1 0.9 0.4 1',
                'keyTimes': '0;1',
                'values': '2;1'
              }
            })
          ])
        ]),
        h('g', {
          attrs: {
            'transform': 'translate(50 50)'
          }
        }, [
          h('rect', {
            attrs: {
              'x': '-10',
              'y': '-30',
              'width': '20',
              'height': '60',
              'fill': 'currentColor',
              'opacity': '0.8'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'scale',
                'from': '2',
                'to': '1',
                'begin': '0.1s',
                'repeatCount': 'indefinite',
                'dur': '1s',
                'calcMode': 'spline',
                'keySplines': '0.1 0.9 0.4 1',
                'keyTimes': '0;1',
                'values': '2;1'
              }
            })
          ])
        ]),
        h('g', {
          attrs: {
            'transform': 'translate(80 50)'
          }
        }, [
          h('rect', {
            attrs: {
              'x': '-10',
              'y': '-30',
              'width': '20',
              'height': '60',
              'fill': 'currentColor',
              'opacity': '0.9'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'scale',
                'from': '2',
                'to': '1',
                'begin': '0.2s',
                'repeatCount': 'indefinite',
                'dur': '1s',
                'calcMode': 'spline',
                'keySplines': '0.1 0.9 0.4 1',
                'keyTimes': '0;1',
                'values': '2;1'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSpinnerGears = Vue.extend({
    name: 'QSpinnerGears',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 100 100',
          'preserveAspectRatio': 'xMidYMid',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('g', {
          attrs: {
            'transform': 'translate(-20,-20)'
          }
        }, [
          h('path', {
            attrs: {
              'd': 'M79.9,52.6C80,51.8,80,50.9,80,50s0-1.8-0.1-2.6l-5.1-0.4c-0.3-2.4-0.9-4.6-1.8-6.7l4.2-2.9c-0.7-1.6-1.6-3.1-2.6-4.5 L70,35c-1.4-1.9-3.1-3.5-4.9-4.9l2.2-4.6c-1.4-1-2.9-1.9-4.5-2.6L59.8,27c-2.1-0.9-4.4-1.5-6.7-1.8l-0.4-5.1C51.8,20,50.9,20,50,20 s-1.8,0-2.6,0.1l-0.4,5.1c-2.4,0.3-4.6,0.9-6.7,1.8l-2.9-4.1c-1.6,0.7-3.1,1.6-4.5,2.6l2.1,4.6c-1.9,1.4-3.5,3.1-5,4.9l-4.5-2.1 c-1,1.4-1.9,2.9-2.6,4.5l4.1,2.9c-0.9,2.1-1.5,4.4-1.8,6.8l-5,0.4C20,48.2,20,49.1,20,50s0,1.8,0.1,2.6l5,0.4 c0.3,2.4,0.9,4.7,1.8,6.8l-4.1,2.9c0.7,1.6,1.6,3.1,2.6,4.5l4.5-2.1c1.4,1.9,3.1,3.5,5,4.9l-2.1,4.6c1.4,1,2.9,1.9,4.5,2.6l2.9-4.1 c2.1,0.9,4.4,1.5,6.7,1.8l0.4,5.1C48.2,80,49.1,80,50,80s1.8,0,2.6-0.1l0.4-5.1c2.3-0.3,4.6-0.9,6.7-1.8l2.9,4.2 c1.6-0.7,3.1-1.6,4.5-2.6L65,69.9c1.9-1.4,3.5-3,4.9-4.9l4.6,2.2c1-1.4,1.9-2.9,2.6-4.5L73,59.8c0.9-2.1,1.5-4.4,1.8-6.7L79.9,52.6 z M50,65c-8.3,0-15-6.7-15-15c0-8.3,6.7-15,15-15s15,6.7,15,15C65,58.3,58.3,65,50,65z',
              'fill': 'currentColor'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'rotate',
                'from': '90 50 50',
                'to': '0 50 50',
                'dur': '1s',
                'repeatCount': 'indefinite'
              }
            })
          ])
        ]),
        h('g', {
          attrs: {
            'transform': 'translate(20,20) rotate(15 50 50)'
          }
        }, [
          h('path', {
            attrs: {
              'd': 'M79.9,52.6C80,51.8,80,50.9,80,50s0-1.8-0.1-2.6l-5.1-0.4c-0.3-2.4-0.9-4.6-1.8-6.7l4.2-2.9c-0.7-1.6-1.6-3.1-2.6-4.5 L70,35c-1.4-1.9-3.1-3.5-4.9-4.9l2.2-4.6c-1.4-1-2.9-1.9-4.5-2.6L59.8,27c-2.1-0.9-4.4-1.5-6.7-1.8l-0.4-5.1C51.8,20,50.9,20,50,20 s-1.8,0-2.6,0.1l-0.4,5.1c-2.4,0.3-4.6,0.9-6.7,1.8l-2.9-4.1c-1.6,0.7-3.1,1.6-4.5,2.6l2.1,4.6c-1.9,1.4-3.5,3.1-5,4.9l-4.5-2.1 c-1,1.4-1.9,2.9-2.6,4.5l4.1,2.9c-0.9,2.1-1.5,4.4-1.8,6.8l-5,0.4C20,48.2,20,49.1,20,50s0,1.8,0.1,2.6l5,0.4 c0.3,2.4,0.9,4.7,1.8,6.8l-4.1,2.9c0.7,1.6,1.6,3.1,2.6,4.5l4.5-2.1c1.4,1.9,3.1,3.5,5,4.9l-2.1,4.6c1.4,1,2.9,1.9,4.5,2.6l2.9-4.1 c2.1,0.9,4.4,1.5,6.7,1.8l0.4,5.1C48.2,80,49.1,80,50,80s1.8,0,2.6-0.1l0.4-5.1c2.3-0.3,4.6-0.9,6.7-1.8l2.9,4.2 c1.6-0.7,3.1-1.6,4.5-2.6L65,69.9c1.9-1.4,3.5-3,4.9-4.9l4.6,2.2c1-1.4,1.9-2.9,2.6-4.5L73,59.8c0.9-2.1,1.5-4.4,1.8-6.7L79.9,52.6 z M50,65c-8.3,0-15-6.7-15-15c0-8.3,6.7-15,15-15s15,6.7,15,15C65,58.3,58.3,65,50,65z',
              'fill': 'currentColor'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'rotate',
                'from': '0 50 50',
                'to': '90 50 50',
                'dur': '1s',
                'repeatCount': 'indefinite'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSpinnerGrid = Vue.extend({
    name: 'QSpinnerGrid',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'fill': 'currentColor',
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 105 105',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('circle', {
          attrs: {
            'cx': '12.5',
            'cy': '12.5',
            'r': '12.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '0s',
              'dur': '1s',
              'values': '1;.2;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '12.5',
            'cy': '52.5',
            'r': '12.5',
            'fill-opacity': '.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '100ms',
              'dur': '1s',
              'values': '1;.2;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '52.5',
            'cy': '12.5',
            'r': '12.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '300ms',
              'dur': '1s',
              'values': '1;.2;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '52.5',
            'cy': '52.5',
            'r': '12.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '600ms',
              'dur': '1s',
              'values': '1;.2;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '92.5',
            'cy': '12.5',
            'r': '12.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '800ms',
              'dur': '1s',
              'values': '1;.2;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '92.5',
            'cy': '52.5',
            'r': '12.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '400ms',
              'dur': '1s',
              'values': '1;.2;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '12.5',
            'cy': '92.5',
            'r': '12.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '700ms',
              'dur': '1s',
              'values': '1;.2;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '52.5',
            'cy': '92.5',
            'r': '12.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '500ms',
              'dur': '1s',
              'values': '1;.2;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('circle', {
          attrs: {
            'cx': '92.5',
            'cy': '92.5',
            'r': '12.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '200ms',
              'dur': '1s',
              'values': '1;.2;1',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ])
      ])
    }
  });

  var QSpinnerHearts = Vue.extend({
    name: 'QSpinnerHearts',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'fill': 'currentColor',
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 140 64',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('path', {
          attrs: {
            'd': 'M30.262 57.02L7.195 40.723c-5.84-3.976-7.56-12.06-3.842-18.063 3.715-6 11.467-7.65 17.306-3.68l4.52 3.76 2.6-5.274c3.716-6.002 11.47-7.65 17.304-3.68 5.84 3.97 7.56 12.054 3.842 18.062L34.49 56.118c-.897 1.512-2.793 1.915-4.228.9z',
            'fill-opacity': '.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '0s',
              'dur': '1.4s',
              'values': '0.5;1;0.5',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('path', {
          attrs: {
            'd': 'M105.512 56.12l-14.44-24.272c-3.716-6.008-1.996-14.093 3.843-18.062 5.835-3.97 13.588-2.322 17.306 3.68l2.6 5.274 4.52-3.76c5.84-3.97 13.593-2.32 17.308 3.68 3.718 6.003 1.998 14.088-3.842 18.064L109.74 57.02c-1.434 1.014-3.33.61-4.228-.9z',
            'fill-opacity': '.5'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'fill-opacity',
              'begin': '0.7s',
              'dur': '1.4s',
              'values': '0.5;1;0.5',
              'calcMode': 'linear',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('path', {
          attrs: {
            'd': 'M67.408 57.834l-23.01-24.98c-5.864-6.15-5.864-16.108 0-22.248 5.86-6.14 15.37-6.14 21.234 0L70 16.168l4.368-5.562c5.863-6.14 15.375-6.14 21.235 0 5.863 6.14 5.863 16.098 0 22.247l-23.007 24.98c-1.43 1.556-3.757 1.556-5.188 0z'
          }
        })
      ])
    }
  });

  var QSpinnerHourglass = Vue.extend({
    name: 'QSpinnerHourglass',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 100 100',
          'preserveAspectRatio': 'xMidYMid',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('g', [
          h('path', {
            staticClass: 'glass',
            attrs: {
              'fill': 'none',
              'stroke': 'currentColor',
              'stroke-width': '5',
              'stroke-miterlimit': '10',
              'd': 'M58.4,51.7c-0.9-0.9-1.4-2-1.4-2.3s0.5-0.4,1.4-1.4 C70.8,43.8,79.8,30.5,80,15.5H70H30H20c0.2,15,9.2,28.1,21.6,32.3c0.9,0.9,1.4,1.2,1.4,1.5s-0.5,1.6-1.4,2.5 C29.2,56.1,20.2,69.5,20,85.5h10h40h10C79.8,69.5,70.8,55.9,58.4,51.7z'
            }
          }),
          h('clipPath', {
            attrs: {
              'id': 'uil-hourglass-clip1'
            }
          }, [
            h('rect', {
              staticClass: 'clip',
              attrs: {
                'x': '15',
                'y': '20',
                'width': '70',
                'height': '25'
              }
            }, [
              h('animate', {
                attrs: {
                  'attributeName': 'height',
                  'from': '25',
                  'to': '0',
                  'dur': '1s',
                  'repeatCount': 'indefinite',
                  'values': '25;0;0',
                  'keyTimes': '0;0.5;1'
                }
              }),
              h('animate', {
                attrs: {
                  'attributeName': 'y',
                  'from': '20',
                  'to': '45',
                  'dur': '1s',
                  'repeatCount': 'indefinite',
                  'values': '20;45;45',
                  'keyTimes': '0;0.5;1'
                }
              })
            ])
          ]),
          h('clipPath', {
            attrs: {
              'id': 'uil-hourglass-clip2'
            }
          }, [
            h('rect', {
              staticClass: 'clip',
              attrs: {
                'x': '15',
                'y': '55',
                'width': '70',
                'height': '25'
              }
            }, [
              h('animate', {
                attrs: {
                  'attributeName': 'height',
                  'from': '0',
                  'to': '25',
                  'dur': '1s',
                  'repeatCount': 'indefinite',
                  'values': '0;25;25',
                  'keyTimes': '0;0.5;1'
                }
              }),
              h('animate', {
                attrs: {
                  'attributeName': 'y',
                  'from': '80',
                  'to': '55',
                  'dur': '1s',
                  'repeatCount': 'indefinite',
                  'values': '80;55;55',
                  'keyTimes': '0;0.5;1'
                }
              })
            ])
          ]),
          h('path', {
            staticClass: 'sand',
            attrs: {
              'd': 'M29,23c3.1,11.4,11.3,19.5,21,19.5S67.9,34.4,71,23H29z',
              'clip-path': 'url(#uil-hourglass-clip1)',
              'fill': 'currentColor'
            }
          }),
          h('path', {
            staticClass: 'sand',
            attrs: {
              'd': 'M71.6,78c-3-11.6-11.5-20-21.5-20s-18.5,8.4-21.5,20H71.6z',
              'clip-path': 'url(#uil-hourglass-clip2)',
              'fill': 'currentColor'
            }
          }),
          h('animateTransform', {
            attrs: {
              'attributeName': 'transform',
              'type': 'rotate',
              'from': '0 50 50',
              'to': '180 50 50',
              'repeatCount': 'indefinite',
              'dur': '1s',
              'values': '0 50 50;0 50 50;180 50 50',
              'keyTimes': '0;0.7;1'
            }
          })
        ])
      ])
    }
  });

  var QSpinnerInfinity = Vue.extend({
    name: 'QSpinnerInfinity',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 100 100',
          'preserveAspectRatio': 'xMidYMid'
        }
      }, [
        h('path', {
          attrs: {
            'd': 'M24.3,30C11.4,30,5,43.3,5,50s6.4,20,19.3,20c19.3,0,32.1-40,51.4-40C88.6,30,95,43.3,95,50s-6.4,20-19.3,20C56.4,70,43.6,30,24.3,30z',
            'fill': 'none',
            'stroke': 'currentColor',
            'stroke-width': '8',
            'stroke-dasharray': '10.691205342610678 10.691205342610678',
            'stroke-dashoffset': '0'
          }
        }, [
          h('animate', {
            attrs: {
              'attributeName': 'stroke-dashoffset',
              'from': '0',
              'to': '21.382410685221355',
              'begin': '0',
              'dur': '2s',
              'repeatCount': 'indefinite',
              'fill': 'freeze'
            }
          })
        ])
      ])
    }
  });

  var QSpinnerIos = Vue.extend({
    name: 'QSpinnerIos',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'stroke': 'currentColor',
          'fill': 'currentColor',
          'viewBox': '0 0 64 64'
        }
      }, [
        h('g', {
          attrs: {
            'stroke-width': '4',
            'stroke-linecap': 'round'
          }
        }, [
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(180)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(210)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(240)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '.1;0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(270)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '.15;.1;0;1;.85;.7;.65;.55;.45;.35;.25;.15',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(300)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '.25;.15;.1;0;1;.85;.7;.65;.55;.45;.35;.25',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(330)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '.35;.25;.15;.1;0;1;.85;.7;.65;.55;.45;.35',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(0)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '.45;.35;.25;.15;.1;0;1;.85;.7;.65;.55;.45',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(30)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '.55;.45;.35;.25;.15;.1;0;1;.85;.7;.65;.55',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(60)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '.65;.55;.45;.35;.25;.15;.1;0;1;.85;.7;.65',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(90)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '.7;.65;.55;.45;.35;.25;.15;.1;0;1;.85;.7',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(120)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1;.85',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('line', {
            attrs: {
              'y1': '17',
              'y2': '29',
              'transform': 'translate(32,32) rotate(150)'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'dur': '750ms',
                'values': '1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1',
                'repeatCount': 'indefinite'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSpinnerOrbit = Vue.extend({
    name: 'QSpinnerOrbit',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'xmlns': 'http://www.w3.org/2000/svg',
          'viewBox': '0 0 100 100',
          'preserveAspectRatio': 'xMidYMid'
        }
      }, [
        h('circle', {
          attrs: {
            'cx': '50',
            'cy': '50',
            'r': '44',
            'fill': 'none',
            'stroke-width': '4',
            'stroke-opacity': '.5',
            'stroke': 'currentColor'
          }
        }),
        h('circle', {
          attrs: {
            'cx': '8',
            'cy': '54',
            'r': '6',
            'fill': 'currentColor',
            'stroke-width': '3',
            'stroke': 'currentColor'
          }
        }, [
          h('animateTransform', {
            attrs: {
              'attributeName': 'transform',
              'type': 'rotate',
              'from': '0 50 48',
              'to': '360 50 52',
              'dur': '2s',
              'repeatCount': 'indefinite'
            }
          })
        ])
      ])
    }
  });

  var QSpinnerOval = Vue.extend({
    name: 'QSpinnerOval',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'stroke': 'currentColor',
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 38 38',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('g', {
          attrs: {
            'transform': 'translate(1 1)',
            'stroke-width': '2',
            'fill': 'none',
            'fill-rule': 'evenodd'
          }
        }, [
          h('circle', {
            attrs: {
              'stroke-opacity': '.5',
              'cx': '18',
              'cy': '18',
              'r': '18'
            }
          }),
          h('path', {
            attrs: {
              'd': 'M36 18c0-9.94-8.06-18-18-18'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'rotate',
                'from': '0 18 18',
                'to': '360 18 18',
                'dur': '1s',
                'repeatCount': 'indefinite'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSpinnerPie = Vue.extend({
    name: 'QSpinnerPie',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 100 100',
          'preserveAspectRatio': 'xMidYMid',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('path', {
          attrs: {
            'd': 'M0 50A50 50 0 0 1 50 0L50 50L0 50',
            'fill': 'currentColor',
            'opacity': '0.5'
          }
        }, [
          h('animateTransform', {
            attrs: {
              'attributeName': 'transform',
              'type': 'rotate',
              'from': '0 50 50',
              'to': '360 50 50',
              'dur': '0.8s',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('path', {
          attrs: {
            'd': 'M50 0A50 50 0 0 1 100 50L50 50L50 0',
            'fill': 'currentColor',
            'opacity': '0.5'
          }
        }, [
          h('animateTransform', {
            attrs: {
              'attributeName': 'transform',
              'type': 'rotate',
              'from': '0 50 50',
              'to': '360 50 50',
              'dur': '1.6s',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('path', {
          attrs: {
            'd': 'M100 50A50 50 0 0 1 50 100L50 50L100 50',
            'fill': 'currentColor',
            'opacity': '0.5'
          }
        }, [
          h('animateTransform', {
            attrs: {
              'attributeName': 'transform',
              'type': 'rotate',
              'from': '0 50 50',
              'to': '360 50 50',
              'dur': '2.4s',
              'repeatCount': 'indefinite'
            }
          })
        ]),
        h('path', {
          attrs: {
            'd': 'M50 100A50 50 0 0 1 0 50L50 50L50 100',
            'fill': 'currentColor',
            'opacity': '0.5'
          }
        }, [
          h('animateTransform', {
            attrs: {
              'attributeName': 'transform',
              'type': 'rotate',
              'from': '0 50 50',
              'to': '360 50 50',
              'dur': '3.2s',
              'repeatCount': 'indefinite'
            }
          })
        ])
      ])
    }
  });

  var QSpinnerPuff = Vue.extend({
    name: 'QSpinnerPuff',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'stroke': 'currentColor',
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 44 44',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('g', {
          attrs: {
            'fill': 'none',
            'fill-rule': 'evenodd',
            'stroke-width': '2'
          }
        }, [
          h('circle', {
            attrs: {
              'cx': '22',
              'cy': '22',
              'r': '1'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'r',
                'begin': '0s',
                'dur': '1.8s',
                'values': '1; 20',
                'calcMode': 'spline',
                'keyTimes': '0; 1',
                'keySplines': '0.165, 0.84, 0.44, 1',
                'repeatCount': 'indefinite'
              }
            }),
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'begin': '0s',
                'dur': '1.8s',
                'values': '1; 0',
                'calcMode': 'spline',
                'keyTimes': '0; 1',
                'keySplines': '0.3, 0.61, 0.355, 1',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('circle', {
            attrs: {
              'cx': '22',
              'cy': '22',
              'r': '1'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'r',
                'begin': '-0.9s',
                'dur': '1.8s',
                'values': '1; 20',
                'calcMode': 'spline',
                'keyTimes': '0; 1',
                'keySplines': '0.165, 0.84, 0.44, 1',
                'repeatCount': 'indefinite'
              }
            }),
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'begin': '-0.9s',
                'dur': '1.8s',
                'values': '1; 0',
                'calcMode': 'spline',
                'keyTimes': '0; 1',
                'keySplines': '0.3, 0.61, 0.355, 1',
                'repeatCount': 'indefinite'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSpinnerRadio = Vue.extend({
    name: 'QSpinnerRadio',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 100 100',
          'preserveAspectRatio': 'xMidYMid',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('g', {
          attrs: {
            'transform': 'scale(0.55)'
          }
        }, [
          h('circle', {
            attrs: {
              'cx': '30',
              'cy': '150',
              'r': '30',
              'fill': 'currentColor'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'opacity',
                'from': '0',
                'to': '1',
                'dur': '1s',
                'begin': '0',
                'repeatCount': 'indefinite',
                'keyTimes': '0;0.5;1',
                'values': '0;1;1'
              }
            })
          ]),
          h('path', {
            attrs: {
              'd': 'M90,150h30c0-49.7-40.3-90-90-90v30C63.1,90,90,116.9,90,150z',
              'fill': 'currentColor'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'opacity',
                'from': '0',
                'to': '1',
                'dur': '1s',
                'begin': '0.1',
                'repeatCount': 'indefinite',
                'keyTimes': '0;0.5;1',
                'values': '0;1;1'
              }
            })
          ]),
          h('path', {
            attrs: {
              'd': 'M150,150h30C180,67.2,112.8,0,30,0v30C96.3,30,150,83.7,150,150z',
              'fill': 'currentColor'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'opacity',
                'from': '0',
                'to': '1',
                'dur': '1s',
                'begin': '0.2',
                'repeatCount': 'indefinite',
                'keyTimes': '0;0.5;1',
                'values': '0;1;1'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSpinnerRings = Vue.extend({
    name: 'QSpinnerRings',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'stroke': 'currentColor',
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 45 45',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('g', {
          attrs: {
            'fill': 'none',
            'fill-rule': 'evenodd',
            'transform': 'translate(1 1)',
            'stroke-width': '2'
          }
        }, [
          h('circle', {
            attrs: {
              'cx': '22',
              'cy': '22',
              'r': '6'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'r',
                'begin': '1.5s',
                'dur': '3s',
                'values': '6;22',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            }),
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'begin': '1.5s',
                'dur': '3s',
                'values': '1;0',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            }),
            h('animate', {
              attrs: {
                'attributeName': 'stroke-width',
                'begin': '1.5s',
                'dur': '3s',
                'values': '2;0',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('circle', {
            attrs: {
              'cx': '22',
              'cy': '22',
              'r': '6'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'r',
                'begin': '3s',
                'dur': '3s',
                'values': '6;22',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            }),
            h('animate', {
              attrs: {
                'attributeName': 'stroke-opacity',
                'begin': '3s',
                'dur': '3s',
                'values': '1;0',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            }),
            h('animate', {
              attrs: {
                'attributeName': 'stroke-width',
                'begin': '3s',
                'dur': '3s',
                'values': '2;0',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('circle', {
            attrs: {
              'cx': '22',
              'cy': '22',
              'r': '8'
            }
          }, [
            h('animate', {
              attrs: {
                'attributeName': 'r',
                'begin': '0s',
                'dur': '1.5s',
                'values': '6;1;2;3;4;5;6',
                'calcMode': 'linear',
                'repeatCount': 'indefinite'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSpinnerTail = Vue.extend({
    name: 'QSpinnerTail',

    mixins: [mixin],

    render (h) {
      return h('svg', {
        staticClass: 'q-spinner',
        class: this.classes,
        on: { ...this.qListeners },
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          'width': this.cSize,
          'height': this.cSize,
          'viewBox': '0 0 38 38',
          'xmlns': 'http://www.w3.org/2000/svg'
        }
      }, [
        h('defs', [
          h('linearGradient', {
            attrs: {
              'x1': '8.042%',
              'y1': '0%',
              'x2': '65.682%',
              'y2': '23.865%',
              'id': 'a'
            }
          }, [
            h('stop', {
              attrs: {
                'stop-color': 'currentColor',
                'stop-opacity': '0',
                'offset': '0%'
              }
            }),
            h('stop', {
              attrs: {
                'stop-color': 'currentColor',
                'stop-opacity': '.631',
                'offset': '63.146%'
              }
            }),
            h('stop', {
              attrs: {
                'stop-color': 'currentColor',
                'offset': '100%'
              }
            })
          ])
        ]),
        h('g', {
          attrs: {
            'transform': 'translate(1 1)',
            'fill': 'none',
            'fill-rule': 'evenodd'
          }
        }, [
          h('path', {
            attrs: {
              'd': 'M36 18c0-9.94-8.06-18-18-18',
              'stroke': 'url(#a)',
              'stroke-width': '2'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'rotate',
                'from': '0 18 18',
                'to': '360 18 18',
                'dur': '0.9s',
                'repeatCount': 'indefinite'
              }
            })
          ]),
          h('circle', {
            attrs: {
              'fill': 'currentColor',
              'cx': '36',
              'cy': '18',
              'r': '1'
            }
          }, [
            h('animateTransform', {
              attrs: {
                'attributeName': 'transform',
                'type': 'rotate',
                'from': '0 18 18',
                'to': '360 18 18',
                'dur': '0.9s',
                'repeatCount': 'indefinite'
              }
            })
          ])
        ])
      ])
    }
  });

  var QSplitter = Vue.extend({
    name: 'QSplitter',

    mixins: [ DarkMixin, ListenersMixin ],

    directives: {
      TouchPan
    },

    props: {
      value: {
        type: Number,
        required: true
      },
      reverse: Boolean,
      unit: {
        type: String,
        default: '%',
        validator: v => [ '%', 'px' ].includes(v)
      },

      limits: {
        type: Array,
        validator: v => {
          if (v.length !== 2) return false
          if (typeof v[0] !== 'number' || typeof v[1] !== 'number') return false
          return v[0] >= 0 && v[0] <= v[1]
        }
      },

      emitImmediately: Boolean,

      horizontal: Boolean,
      disable: Boolean,

      beforeClass: [Array, String, Object],
      afterClass: [Array, String, Object],

      separatorClass: [Array, String, Object],
      separatorStyle: [Array, String, Object]
    },

    watch: {
      value: {
        immediate: true,
        handler (v) {
          this.__normalize(v, this.computedLimits);
        }
      },

      limits: {
        deep: true,
        handler () {
          this.$nextTick(() => {
            this.__normalize(this.value, this.computedLimits);
          });
        }
      }
    },

    computed: {
      classes () {
        return (this.horizontal === true ? 'column' : 'row') +
          ` q-splitter--${this.horizontal === true ? 'horizontal' : 'vertical'}` +
          ` q-splitter--${this.disable === true ? 'disabled' : 'workable'}` +
          (this.isDark === true ? ' q-splitter--dark' : '')
      },

      prop () {
        return this.horizontal === true ? 'height' : 'width'
      },

      side () {
        return this.reverse !== true ? 'before' : 'after'
      },

      computedLimits () {
        return this.limits !== void 0
          ? this.limits
          : (this.unit === '%' ? [ 10, 90 ] : [ 50, Infinity ])
      },

      styles () {
        return {
          [this.side]: {
            [this.prop]: this.__getCSSValue(this.value)
          }
        }
      },

      separatorDirectives () {
        if (this.disable !== true) {
          return [{
            name: 'touch-pan',
            value: this.__pan,
            modifiers: {
              [ this.horizontal === true ? 'vertical' : 'horizontal' ]: true,
              prevent: true,
              stop: true,
              mouse: true,
              mouseAllDir: true
            }
          }]
        }
      }
    },

    methods: {
      __pan (evt) {
        if (evt.isFirst === true) {
          const size = this.$el.getBoundingClientRect()[this.prop];

          this.__dir = this.horizontal === true ? 'up' : 'left';
          this.__maxValue = this.unit === '%' ? 100 : size;
          this.__value = Math.min(this.__maxValue, this.computedLimits[1], Math.max(this.computedLimits[0], this.value));
          this.__multiplier = (this.reverse !== true ? 1 : -1) *
            (this.horizontal === true ? 1 : (this.$q.lang.rtl === true ? -1 : 1)) *
            (this.unit === '%' ? (size === 0 ? 0 : 100 / size) : 1);

          this.$el.classList.add('q-splitter--active');
          return
        }

        if (evt.isFinal === true) {
          if (this.__normalized !== this.value) {
            this.$emit('input', this.__normalized);
          }

          this.$el.classList.remove('q-splitter--active');
          return
        }

        const val = this.__value +
          this.__multiplier *
          (evt.direction === this.__dir ? -1 : 1) *
          evt.distance[this.horizontal === true ? 'y' : 'x'];

        this.__normalized = Math.min(this.__maxValue, this.computedLimits[1], Math.max(this.computedLimits[0], val));

        this.$refs[this.side].style[this.prop] = this.__getCSSValue(this.__normalized);

        if (this.emitImmediately === true && this.value !== this.__normalized) {
          this.$emit('input', this.__normalized);
        }
      },

      __normalize (val, limits) {
        if (val < limits[0]) {
          this.$emit('input', limits[0]);
        }
        else if (val > limits[1]) {
          this.$emit('input', limits[1]);
        }
      },

      __getCSSValue (value) {
        return (this.unit === '%' ? value : Math.round(value)) + this.unit
      }
    },

    render (h) {
      const attrs = this.disable === true ? { 'aria-disabled': 'true' } : void 0;
      const child = [
        h('div', {
          ref: 'before',
          staticClass: 'q-splitter__panel q-splitter__before' + (this.reverse === true ? ' col' : ''),
          style: this.styles.before,
          class: this.beforeClass,
          on: cache(this, 'stop', { input: stop })
        }, slot(this, 'before')),

        h('div', {
          staticClass: 'q-splitter__separator',
          style: this.separatorStyle,
          class: this.separatorClass,
          attrs
        }, [
          h('div', {
            staticClass: 'absolute-full q-splitter__separator-area',
            directives: this.separatorDirectives
          }, slot(this, 'separator'))
        ]),

        h('div', {
          ref: 'after',
          staticClass: 'q-splitter__panel q-splitter__after' + (this.reverse === true ? '' : ' col'),
          style: this.styles.after,
          class: this.afterClass,
          on: cache(this, 'stop', { input: stop })
        }, slot(this, 'after'))
      ];

      return h('div', {
        staticClass: 'q-splitter no-wrap',
        class: this.classes,
        on: { ...this.qListeners }
      }, mergeSlot(child, this, 'default'))
    }
  });

  var StepHeader = Vue.extend({
    name: 'StepHeader',

    mixins: [ AttrsMixin ],

    directives: {
      Ripple
    },

    props: {
      stepper: {},
      step: {}
    },

    computed: {
      isActive () {
        return this.stepper.value === this.step.name
      },

      isDisable () {
        const opt = this.step.disable;
        return opt === true || opt === ''
      },

      isError () {
        const opt = this.step.error;
        return opt === true || opt === ''
      },

      isDone () {
        const opt = this.step.done;
        return this.isDisable === false && (opt === true || opt === '')
      },

      headerNav () {
        const
          opt = this.step.headerNav,
          nav = opt === true || opt === '' || opt === void 0;

        return this.isDisable === false &&
          this.stepper.headerNav &&
          nav
      },

      hasPrefix () {
        return this.step.prefix &&
          (this.isActive === false || this.stepper.activeIcon === 'none') &&
          (this.isError === false || this.stepper.errorIcon === 'none') &&
          (this.isDone === false || this.stepper.doneIcon === 'none')
      },

      icon () {
        const defaultIcon = this.step.icon || this.stepper.inactiveIcon;

        if (this.isActive === true) {
          const icon = this.step.activeIcon || this.stepper.activeIcon;
          return icon === 'none'
            ? defaultIcon
            : icon || this.$q.iconSet.stepper.active
        }

        if (this.isError === true) {
          const icon = this.step.errorIcon || this.stepper.errorIcon;
          return icon === 'none'
            ? defaultIcon
            : icon || this.$q.iconSet.stepper.error
        }

        if (this.isDisable === false && this.isDone === true) {
          const icon = this.step.doneIcon || this.stepper.doneIcon;
          return icon === 'none'
            ? defaultIcon
            : icon || this.$q.iconSet.stepper.done
        }

        return defaultIcon
      },

      color () {
        const errorColor = this.isError === true
          ? this.step.errorColor || this.stepper.errorColor
          : void 0;

        if (this.isActive === true) {
          const color = this.step.activeColor || this.stepper.activeColor || this.step.color;
          return color !== void 0
            ? color
            : errorColor
        }
        if (errorColor !== void 0) {
          return errorColor
        }
        if (this.isDisable === false && this.isDone === true) {
          return this.step.doneColor || this.stepper.doneColor || this.step.color || this.stepper.inactiveColor
        }

        return this.step.color || this.stepper.inactiveColor
      },

      classes () {
        return 'q-stepper__tab col-grow flex items-center no-wrap relative-position' +
          (this.color !== void 0 ? ` text-${this.color}` : '') +
          (this.isError === true
            ? ' q-stepper__tab--error q-stepper__tab--error-with-' + (this.hasPrefix === true ? 'prefix' : 'icon')
            : '') +
          (this.isActive === true ? ' q-stepper__tab--active' : '') +
          (this.isDone === true ? ' q-stepper__tab--done' : '') +
          (this.headerNav === true ? ' q-stepper__tab--navigation q-focusable q-hoverable' : '') +
          (this.isDisable === true ? ' q-stepper__tab--disabled' : '')
      }
    },

    methods: {
      activate () {
        this.$refs.blurTarget !== void 0 && this.$refs.blurTarget.focus();
        this.isActive === false && this.stepper.goTo(this.step.name);
      },

      keyup (e) {
        if (e.keyCode === 13 && this.isActive === false) {
          this.stepper.goTo(this.step.name);
        }
      }
    },

    render (h) {
      const data = { class: this.classes };

      if (this.stepper.headerNav === true) {
        data.directives = [{
          name: 'ripple',
          value: this.headerNav
        }];
      }

      this.headerNav === true && Object.assign(data, {
        on: cache(this, 'headnavon', {
          click: this.activate,
          keyup: this.keyup
        }),
        attrs: this.isDisable === true
          ? { tabindex: -1, 'aria-disabled': 'true' }
          : { tabindex: this.qAttrs.tabindex || 0 }
      });

      const child = [
        h('div', { staticClass: 'q-focus-helper', attrs: { tabindex: -1 }, ref: 'blurTarget' }),

        h('div', { staticClass: 'q-stepper__dot row flex-center q-stepper__line relative-position' }, [
          h('span', { staticClass: 'row flex-center' }, [
            this.hasPrefix === true
              ? this.step.prefix
              : h(QIcon, { props: { name: this.icon } })
          ])
        ])
      ];

      if (this.step.title !== void 0 && this.step.title !== null) {
        const content = [
          h('div', { staticClass: 'q-stepper__title' }, [ this.step.title ])
        ];

        if (this.step.caption !== void 0 && this.step.caption !== null) {
          content.push(
            h('div', { staticClass: 'q-stepper__caption' }, [ this.step.caption ])
          );
        }

        child.push(
          h('div', {
            staticClass: 'q-stepper__label q-stepper__line relative-position'
          }, content)
        );
      }

      return h('div', data, child)
    }
  });

  const StepWrapper = Vue.extend({
    name: 'QStepWrapper',

    render (h) {
      return h('div', {
        staticClass: 'q-stepper__step-content'
      }, [
        h('div', {
          staticClass: 'q-stepper__step-inner'
        }, slot(this, 'default'))
      ])
    }
  });

  var QStep = Vue.extend({
    name: 'QStep',

    inject: {
      stepper: {
        default () {
          console.error('QStep needs to be child of QStepper');
        }
      }
    },

    mixins: [ PanelChildMixin ],

    props: {
      icon: String,
      color: String,
      title: {
        type: String,
        required: true
      },
      caption: String,
      prefix: [ String, Number ],

      doneIcon: String,
      doneColor: String,
      activeIcon: String,
      activeColor: String,
      errorIcon: String,
      errorColor: String,

      headerNav: {
        type: Boolean,
        default: true
      },
      done: Boolean,
      error: Boolean
    },

    computed: {
      isActive () {
        return this.stepper.value === this.name
      },

      onEvents () {
        return this.isActive !== true ||
          this.stepper.vertical !== true ||
          (this.$q.platform.is.ios !== true && this.$q.platform.is.chrome === true)
          ? { ...this.qListeners }
          : { ...this.qListeners, scroll: this.__keepScroll }
      }
    },

    methods: {
      __keepScroll (ev) {
        const { target } = ev;
        if (target.scrollTop > 0) {
          target.scrollTop = 0;
        }
        this.qListeners.scroll !== void 0 && this.qListeners.scroll(ev);
      }
    },

    render (h) {
      const vertical = this.stepper.vertical;
      const content = vertical === true && this.stepper.keepAlive === true
        ? h(
          'keep-alive',
          this.isActive === true
            ? [ h(StepWrapper, { key: this.name }, slot(this, 'default')) ]
            : void 0
        )
        : (
          vertical !== true || this.isActive === true
            ? StepWrapper.options.render.call(this, h)
            : void 0
        );

      return h(
        'div',
        {
          staticClass: 'q-stepper__step',
          on: this.onEvents
        },
        vertical === true
          ? [
            h(StepHeader, {
              props: {
                stepper: this.stepper,
                step: this
              }
            }),

            this.stepper.animated === true
              ? h(QSlideTransition, [ content ])
              : content
          ]
          : [ content ]
      )
    }
  });

  var QStepper = Vue.extend({
    name: 'QStepper',

    provide () {
      return {
        stepper: this
      }
    },

    mixins: [ DarkMixin, PanelParentMixin ],

    props: {
      flat: Boolean,
      bordered: Boolean,
      alternativeLabels: Boolean,
      headerNav: Boolean,
      contracted: Boolean,
      headerClass: String,

      inactiveColor: String,
      inactiveIcon: String,
      doneIcon: String,
      doneColor: String,
      activeIcon: String,
      activeColor: String,
      errorIcon: String,
      errorColor: String
    },

    computed: {
      classes () {
        return `q-stepper q-stepper--${this.vertical === true ? 'vertical' : 'horizontal'}` +
          (this.flat === true || this.isDark === true ? ' q-stepper--flat no-shadow' : '') +
          (this.bordered === true || (this.isDark === true && this.flat === false) ? ' q-stepper--bordered' : '') +
          (this.isDark === true ? ' q-stepper--dark q-dark' : '')
      },

      headerClasses () {
        return 'q-stepper__header row items-stretch justify-between' +
          ` q-stepper__header--${this.alternativeLabels === true ? 'alternative' : 'standard'}-labels` +
          (this.flat === false || this.bordered === true ? ' q-stepper__header--border' : '') +
          (this.contracted === true ? ' q-stepper__header--contracted' : '') +
          (this.headerClass !== void 0 ? ` ${this.headerClass}` : '')
      }
    },

    methods: {
      __getContent (h) {
        const top = slot(this, 'message', []);

        if (this.vertical === true) {
          this.__isValidPanelName(this.value) && this.__updatePanelIndex();

          const content = h('div', {
            staticClass: 'q-stepper__content',
            // stop propagation of content emitted @input
            // which would tamper with Panel's model
            on: cache(this, 'stop', { input: stop })
          }, slot(this, 'default'));

          return top === void 0
            ? [ content ]
            : top.concat(content)
        }

        return [
          h('div', { class: this.headerClasses }, this.panels.map(panel => {
            const step = panel.componentOptions.propsData;

            return h(StepHeader, {
              key: step.name,
              props: {
                stepper: this,
                step
              }
            })
          }))
        ].concat(
          top,

          h('div', {
            staticClass: 'q-stepper__content q-panel-parent',
            directives: this.panelDirectives
          }, this.__getPanelContent(h))
        )
      },

      __renderPanels (h) {
        return h('div', {
          class: this.classes,
          on: { ...this.qListeners }
        }, mergeSlot(this.__getContent(h), this, 'navigation'))
      }
    }
  });

  var QStepperNavigation = Vue.extend({
    name: 'QStepperNavigation',

    mixins: [ ListenersMixin ],

    render (h) {
      return h('div', {
        staticClass: 'q-stepper__nav',
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var Top = {
    computed: {
      marginalsScope () {
        return {
          pagination: this.computedPagination,
          pagesNumber: this.pagesNumber,
          isFirstPage: this.isFirstPage,
          isLastPage: this.isLastPage,
          firstPage: this.firstPage,
          prevPage: this.prevPage,
          nextPage: this.nextPage,
          lastPage: this.lastPage,

          inFullscreen: this.inFullscreen,
          toggleFullscreen: this.toggleFullscreen
        }
      }
    },

    methods: {
      __getTopDiv (h) {
        const
          top = this.$scopedSlots.top,
          topLeft = this.$scopedSlots['top-left'],
          topRight = this.$scopedSlots['top-right'],
          topSelection = this.$scopedSlots['top-selection'],
          hasSelection = this.hasSelectionMode === true &&
            topSelection !== void 0 &&
            this.rowsSelectedNumber > 0,
          staticClass = 'q-table__top relative-position row items-center';

        if (top !== void 0) {
          return h('div', { staticClass }, [ top(this.marginalsScope) ])
        }

        let child;

        if (hasSelection === true) {
          child = topSelection(this.marginalsScope).slice();
        }
        else {
          child = [];

          if (topLeft !== void 0) {
            child.push(
              h('div', { staticClass: 'q-table-control' }, [
                topLeft(this.marginalsScope)
              ])
            );
          }
          else if (this.title) {
            child.push(
              h('div', { staticClass: 'q-table__control' }, [
                h('div', { staticClass: 'q-table__title', class: this.titleClass }, this.title)
              ])
            );
          }
        }

        if (topRight !== void 0) {
          child.push(h('div', { staticClass: 'q-table__separator col' }));
          child.push(
            h('div', { staticClass: 'q-table__control' }, [
              topRight(this.marginalsScope)
            ])
          );
        }

        if (child.length === 0) {
          return
        }

        return h('div', { staticClass }, child)
      }
    }
  };

  var QTh = Vue.extend({
    name: 'QTh',

    mixins: [ ListenersMixin ],

    props: {
      props: Object,
      autoWidth: Boolean
    },

    render (h) {
      const on = { ...this.qListeners };

      if (this.props === void 0) {
        return h('th', {
          on,
          class: this.autoWidth === true ? 'q-table--col-auto-width' : null
        }, slot(this, 'default'))
      }

      let col, child;
      const name = this.$vnode.key;

      if (name) {
        col = this.props.colsMap[name];
        if (col === void 0) { return }
      }
      else {
        col = this.props.col;
      }

      if (col.sortable === true) {
        const action = col.align === 'right'
          ? 'unshift'
          : 'push';

        child = uniqueSlot(this, 'default', []);
        child[action](
          h(QIcon, {
            props: { name: this.$q.iconSet.table.arrowUp },
            staticClass: col.__iconClass
          })
        );
      }
      else {
        child = slot(this, 'default');
      }

      const evt = col.sortable === true
        ? {
          click: evt => {
            this.props.sort(col);
            this.$emit('click', evt);
          }
        }
        : {};

      return h('th', {
        on: { ...on, ...evt },
        style: col.headerStyle,
        class: col.__thClass +
          (this.autoWidth === true ? ' q-table--col-auto-width' : '')
      }, child)
    }
  });

  var TableHeader = {
    computed: {
      headerSelectedValue () {
        return this.someRowsSelected === true
          ? null
          : this.allRowsSelected
      }
    },

    methods: {
      __getTHead (h) {
        const child = this.__getTHeadTR(h);

        if (this.loading === true && this.$scopedSlots.loading === void 0) {
          child.push(
            h('tr', { staticClass: 'q-table__progress' }, [
              h('th', {
                staticClass: 'relative-position',
                attrs: { colspan: this.computedColspan }
              }, this.__getProgress(h))
            ])
          );
        }

        return h('thead', child)
      },

      __getTHeadTR (h) {
        const
          header = this.$scopedSlots.header,
          headerCell = this.$scopedSlots['header-cell'];

        if (header !== void 0) {
          return header(
            this.__getHeaderScope({ header: true })
          ).slice()
        }

        const child = this.computedCols.map(col => {
          const
            headerCellCol = this.$scopedSlots[`header-cell-${col.name}`],
            slot = headerCellCol !== void 0 ? headerCellCol : headerCell,
            props = this.__getHeaderScope({ col });

          return slot !== void 0
            ? slot(props)
            : h(QTh, {
              key: col.name,
              props: { props }
            }, col.label)
        });

        if (this.singleSelection === true && this.grid !== true) {
          child.unshift(h('th', { staticClass: 'q-table--col-auto-width' }, [' ']));
        }
        else if (this.multipleSelection === true) {
          const slot = this.$scopedSlots['header-selection'];
          const content = slot !== void 0
            ? slot(this.__getHeaderScope({}))
            : [
              h(QCheckbox, {
                props: {
                  color: this.color,
                  value: this.headerSelectedValue,
                  dark: this.isDark,
                  dense: this.dense
                },
                on: cache(this, 'inp', {
                  input: this.__onMultipleSelectionSet
                })
              })
            ];

          child.unshift(
            h('th', { staticClass: 'q-table--col-auto-width' }, content)
          );
        }

        return [
          h('tr', {
            style: this.tableHeaderStyle,
            class: this.tableHeaderClass
          }, child)
        ]
      },

      __getHeaderScope (data) {
        Object.assign(data, {
          cols: this.computedCols,
          sort: this.sort,
          colsMap: this.computedColsMap,
          color: this.color,
          dark: this.isDark,
          dense: this.dense
        });

        if (this.multipleSelection === true) {
          Object.defineProperty(data, 'selected', {
            get: () => this.headerSelectedValue,
            set: this.__onMultipleSelectionSet,
            configurable: true,
            enumerable: true
          });

          // TODO: remove in v2
          data.partialSelected = this.someRowsSelected;
          data.multipleSelect = true;
        }

        return data
      },

      __onMultipleSelectionSet (val) {
        if (this.someRowsSelected === true) {
          val = false;
        }
        this.__updateSelection(
          this.computedRows.map(this.getRowKey),
          this.computedRows,
          val
        );
      }
    }
  };

  var TableBody = {
    methods: {
      __getTBodyTR (h, row, bodySlot, pageIndex) {
        const
          key = this.getRowKey(row),
          selected = this.isRowSelected(key);

        if (bodySlot !== void 0) {
          return bodySlot(
            this.__getBodyScope({
              key,
              row,
              pageIndex,
              __trClass: selected ? 'selected' : ''
            })
          )
        }

        const
          bodyCell = this.$scopedSlots['body-cell'],
          child = this.computedCols.map(col => {
            const
              bodyCellCol = this.$scopedSlots[`body-cell-${col.name}`],
              slot = bodyCellCol !== void 0 ? bodyCellCol : bodyCell;

            return slot !== void 0
              ? slot(this.__getBodyCellScope({ key, row, pageIndex, col }))
              : h('td', {
                class: col.__tdClass(row),
                style: col.__tdStyle(row)
              }, this.getCellValue(col, row))
          });

        if (this.hasSelectionMode === true) {
          const slot = this.$scopedSlots['body-selection'];
          const content = slot !== void 0
            ? slot(this.__getBodySelectionScope({ key, row, pageIndex }))
            : [
              h(QCheckbox, {
                props: {
                  value: selected,
                  color: this.color,
                  dark: this.isDark,
                  dense: this.dense
                },
                on: {
                  input: (adding, evt) => {
                    this.__updateSelection([ key ], [ row ], adding, evt);
                  }
                }
              })
            ];

          child.unshift(
            h('td', { staticClass: 'q-table--col-auto-width' }, content)
          );
        }

        const data = { key, class: { selected }, on: {} };

        if (this.qListeners['row-click'] !== void 0) {
          data.class['cursor-pointer'] = true;
          data.on.click = evt => {
            this.$emit('row-click', evt, row, pageIndex);
          };
        }

        if (this.qListeners['row-dblclick'] !== void 0) {
          data.class['cursor-pointer'] = true;
          data.on.dblclick = evt => {
            this.$emit('row-dblclick', evt, row, pageIndex);
          };
        }

        if (this.qListeners['row-contextmenu'] !== void 0) {
          data.class['cursor-pointer'] = true;
          data.on.contextmenu = evt => {
            this.$emit('row-contextmenu', evt, row, pageIndex);
          };
        }

        return h('tr', data, child)
      },

      __getTBody (h) {
        const
          body = this.$scopedSlots.body,
          topRow = this.$scopedSlots['top-row'],
          bottomRow = this.$scopedSlots['bottom-row'];

        let child = this.computedRows.map(
          (row, pageIndex) => this.__getTBodyTR(h, row, body, pageIndex)
        );

        if (topRow !== void 0) {
          child = topRow({ cols: this.computedCols }).concat(child);
        }
        if (bottomRow !== void 0) {
          child = child.concat(bottomRow({ cols: this.computedCols }));
        }

        return h('tbody', child)
      },

      __getVirtualTBodyTR (h) {
        const body = this.$scopedSlots.body;
        return props => this.__getTBodyTR(h, props.item, body, props.index)
      },

      __getBodyScope (data) {
        this.__injectBodyCommonScope(data);

        data.cols = data.cols.map(col => {
          const c = { ...col };
          Object.defineProperty(c, 'value', {
            get: () => this.getCellValue(col, data.row),
            configurable: true,
            enumerable: true
          });
          return c
        });

        return data
      },

      __getBodyCellScope (data) {
        this.__injectBodyCommonScope(data);

        Object.defineProperty(data, 'value', {
          get: () => this.getCellValue(data.col, data.row),
          configurable: true,
          enumerable: true
        });

        return data
      },

      __getBodySelectionScope (data) {
        this.__injectBodyCommonScope(data);
        return data
      },

      __injectBodyCommonScope (data) {
        Object.assign(data, {
          cols: this.computedCols,
          colsMap: this.computedColsMap,
          sort: this.sort,
          rowIndex: this.firstRowIndex + data.pageIndex,
          color: this.color,
          dark: this.isDark,
          dense: this.dense
        });

        this.hasSelectionMode === true && Object.defineProperty(data, 'selected', {
          get: () => this.isRowSelected(data.key),
          set: (adding, evt) => {
            this.__updateSelection([ data.key ], [ data.row ], adding, evt);
          },
          configurable: true,
          enumerable: true
        });

        Object.defineProperty(data, 'expand', {
          get: () => this.isRowExpanded(data.key),
          set: adding => {
            this.__updateExpanded(data.key, adding);
          },
          configurable: true,
          enumerable: true
        });
      },

      getCellValue (col, row) {
        const val = typeof col.field === 'function' ? col.field(row) : row[col.field];
        return col.format !== void 0 ? col.format(val, row) : val
      }
    }
  };

  const staticClass = 'q-table__bottom row items-center';

  var Bottom = {
    props: {
      hideBottom: Boolean,
      hideSelectedBanner: Boolean,
      hideNoData: Boolean,
      hidePagination: Boolean
    },

    computed: {
      navIcon () {
        const ico = [
          this.iconFirstPage || this.$q.iconSet.table.firstPage,
          this.iconPrevPage || this.$q.iconSet.table.prevPage,
          this.iconNextPage || this.$q.iconSet.table.nextPage,
          this.iconLastPage || this.$q.iconSet.table.lastPage
        ];
        return this.$q.lang.rtl === true ? ico.reverse() : ico
      }
    },

    methods: {
      __getBottomDiv (h) {
        if (this.hideBottom === true) {
          return
        }

        if (this.nothingToDisplay === true) {
          if (this.hideNoData === true) {
            return
          }

          const message = this.loading === true
            ? this.loadingLabel || this.$q.lang.table.loading
            : (this.filter ? this.noResultsLabel || this.$q.lang.table.noResults : this.noDataLabel || this.$q.lang.table.noData);

          const noData = this.$scopedSlots['no-data'];
          const children = noData !== void 0
            ? [ noData({ message, icon: this.$q.iconSet.table.warning, filter: this.filter }) ]
            : [
              h(QIcon, {
                staticClass: 'q-table__bottom-nodata-icon',
                props: { name: this.$q.iconSet.table.warning }
              }),
              message
            ];

          return h('div', {
            staticClass: staticClass + ' q-table__bottom--nodata'
          }, children)
        }

        const bottom = this.$scopedSlots.bottom;

        if (bottom !== void 0) {
          return h('div', { staticClass }, [ bottom(this.marginalsScope) ])
        }

        const child = this.hideSelectedBanner !== true && this.hasSelectionMode === true && this.rowsSelectedNumber > 0
          ? [
            h('div', { staticClass: 'q-table__control' }, [
              h('div', [
                (this.selectedRowsLabel || this.$q.lang.table.selectedRecords)(this.rowsSelectedNumber)
              ])
            ])
          ]
          : [];

        if (this.hidePagination !== true) {
          return h('div', {
            staticClass: staticClass + ' justify-end'
          }, this.__getPaginationDiv(h, child))
        }

        if (child.length > 0) {
          return h('div', { staticClass }, child)
        }
      },

      __getPaginationDiv (h, child) {
        let control;
        const
          { rowsPerPage } = this.computedPagination,
          paginationLabel = this.paginationLabel || this.$q.lang.table.pagination,
          paginationSlot = this.$scopedSlots.pagination,
          hasOpts = this.rowsPerPageOptions.length > 1;

        child.push(
          h('div', { staticClass: 'q-table__separator col' })
        );

        if (hasOpts === true) {
          child.push(
            h('div', { staticClass: 'q-table__control' }, [
              h('span', { staticClass: 'q-table__bottom-item' }, [
                this.rowsPerPageLabel || this.$q.lang.table.recordsPerPage
              ]),
              h(QSelect, {
                staticClass: 'q-table__select inline q-table__bottom-item',
                props: {
                  color: this.color,
                  value: rowsPerPage,
                  options: this.computedRowsPerPageOptions,
                  displayValue: rowsPerPage === 0
                    ? this.$q.lang.table.allRows
                    : rowsPerPage,
                  dark: this.isDark,
                  borderless: true,
                  dense: true,
                  optionsDense: true,
                  optionsCover: true
                },
                on: cache(this, 'pgSize', {
                  input: pag => {
                    this.setPagination({
                      page: 1,
                      rowsPerPage: pag.value
                    });
                  }
                })
              })
            ])
          );
        }

        if (paginationSlot !== void 0) {
          control = paginationSlot(this.marginalsScope);
        }
        else {
          control = [
            h('span', rowsPerPage !== 0 ? { staticClass: 'q-table__bottom-item' } : {}, [
              rowsPerPage
                ? paginationLabel(this.firstRowIndex + 1, Math.min(this.lastRowIndex, this.computedRowsNumber), this.computedRowsNumber)
                : paginationLabel(1, this.filteredSortedRowsNumber, this.computedRowsNumber)
            ])
          ];

          if (rowsPerPage !== 0 && this.pagesNumber > 1) {
            const btnProps = {
              color: this.color,
              round: true,
              dense: true,
              flat: true
            };

            if (this.dense === true) {
              btnProps.size = 'sm';
            }

            this.pagesNumber > 2 && control.push(
              h(QBtn, {
                key: 'pgFirst',
                props: {
                  ...btnProps,
                  icon: this.navIcon[0],
                  disable: this.isFirstPage
                },
                on: cache(this, 'pgFirst', { click: this.firstPage })
              })
            );

            control.push(
              h(QBtn, {
                key: 'pgPrev',
                props: {
                  ...btnProps,
                  icon: this.navIcon[1],
                  disable: this.isFirstPage
                },
                on: cache(this, 'pgPrev', { click: this.prevPage })
              }),

              h(QBtn, {
                key: 'pgNext',
                props: {
                  ...btnProps,
                  icon: this.navIcon[2],
                  disable: this.isLastPage
                },
                on: cache(this, 'pgNext', { click: this.nextPage })
              })
            );

            this.pagesNumber > 2 && control.push(
              h(QBtn, {
                key: 'pgLast',
                props: {
                  ...btnProps,
                  icon: this.navIcon[3],
                  disable: this.isLastPage
                },
                on: cache(this, 'pgLast', { click: this.lastPage })
              })
            );
          }
        }

        child.push(
          h('div', { staticClass: 'q-table__control' }, control)
        );

        return child
      }
    }
  };

  var TableGrid = {
    methods: {
      __getGridHeader (h) {
        const child = this.gridHeader === true
          ? [
            h('table', { staticClass: 'q-table' }, [
              this.__getTHead(h)
            ])
          ]
          : (
            this.loading === true && this.$scopedSlots.loading === void 0
              ? this.__getProgress(h)
              : void 0
          );

        return h('div', { staticClass: 'q-table__middle' }, child)
      },

      __getGridBody (h) {
        const item = this.$scopedSlots.item !== void 0
          ? this.$scopedSlots.item
          : scope => {
            const child = scope.cols.map(
              col => h('div', { staticClass: 'q-table__grid-item-row' }, [
                h('div', { staticClass: 'q-table__grid-item-title' }, [ col.label ]),
                h('div', { staticClass: 'q-table__grid-item-value' }, [ col.value ])
              ])
            );

            if (this.hasSelectionMode === true) {
              const slot = this.$scopedSlots['body-selection'];
              const content = slot !== void 0
                ? slot(scope)
                : [
                  h(QCheckbox, {
                    props: {
                      value: scope.selected,
                      color: this.color,
                      dark: this.isDark,
                      dense: this.dense
                    },
                    on: {
                      input: (adding, evt) => {
                        this.__updateSelection([ scope.key ], [ scope.row ], adding, evt);
                      }
                    }
                  })
                ];

              child.unshift(
                h('div', { staticClass: 'q-table__grid-item-row' }, content),
                h(QSeparator, { props: { dark: this.isDark } })
              );
            }

            const data = {
              staticClass: 'q-table__grid-item-card' + this.cardDefaultClass,
              class: this.cardClass,
              style: this.cardStyle,
              on: {}
            };

            if (this.qListeners['row-click'] !== void 0 || this.qListeners['row-dblclick'] !== void 0) {
              data.staticClass += ' cursor-pointer';
            }

            if (this.qListeners['row-click'] !== void 0) {
              data.on.click = evt => {
                this.$emit('row-click', evt, scope.row, scope.pageIndex);
              };
            }

            if (this.qListeners['row-dblclick'] !== void 0) {
              data.on.dblclick = evt => {
                this.$emit('row-dblclick', evt, scope.row, scope.pageIndex);
              };
            }

            return h('div', {
              staticClass: 'q-table__grid-item col-xs-12 col-sm-6 col-md-4 col-lg-3',
              class: scope.selected === true ? 'q-table__grid-item--selected' : ''
            }, [
              h('div', data, child)
            ])
          };

        return h('div', {
          staticClass: 'q-table__grid-content row',
          class: this.cardContainerClass,
          style: this.cardContainerStyle
        }, this.computedRows.map((row, pageIndex) => {
          return item(this.__getBodyScope({
            key: this.getRowKey(row),
            row,
            pageIndex
          }))
        }))
      }
    }
  };

  function getTableMiddle (h, conf, content) {
    return h('div', {
      ...conf,
      staticClass: 'q-table__middle' + (conf.staticClass !== void 0 ? ' ' + conf.staticClass : '')
    }, [
      h('table', { staticClass: 'q-table' }, content)
    ])
  }

  const comps = {
    list: QList,
    table: QMarkupTable
  };

  var QVirtualScroll = Vue.extend({
    name: 'QVirtualScroll',

    mixins: [ AttrsMixin, ListenersMixin, VirtualScroll ],

    props: {
      type: {
        type: String,
        default: 'list',
        validator: v => ['list', 'table', '__qtable'].includes(v)
      },

      items: {
        type: Array,
        default: () => []
      },

      itemsFn: Function,
      itemsSize: Number,

      scrollTarget: {
        default: void 0
      }
    },

    computed: {
      virtualScrollLength () {
        return this.itemsSize >= 0 && this.itemsFn !== void 0
          ? parseInt(this.itemsSize, 10)
          : (Array.isArray(this.items) ? this.items.length : 0)
      },

      virtualScrollScope () {
        if (this.virtualScrollLength === 0) {
          return []
        }

        const mapFn = (item, i) => ({
          index: this.virtualScrollSliceRange.from + i,
          item
        });

        if (this.itemsFn === void 0) {
          return this.items.slice(this.virtualScrollSliceRange.from, this.virtualScrollSliceRange.to).map(mapFn)
        }

        return this.itemsFn(this.virtualScrollSliceRange.from, this.virtualScrollSliceRange.to - this.virtualScrollSliceRange.from).map(mapFn)
      },

      classes () {
        return 'q-virtual-scroll q-virtual-scroll' + (this.virtualScrollHorizontal === true ? '--horizontal' : '--vertical') +
          (this.scrollTarget !== void 0 ? '' : ' scroll')
      },

      attrs () {
        return this.scrollTarget !== void 0 ? void 0 : { tabindex: 0 }
      }
    },

    watch: {
      virtualScrollLength () {
        this.__resetVirtualScroll();
      },

      scrollTarget () {
        this.__unconfigureScrollTarget();
        this.__configureScrollTarget();
      }
    },

    methods: {
      __getVirtualScrollEl () {
        return this.$el
      },

      __getVirtualScrollTarget () {
        return this.__scrollTarget
      },

      __configureScrollTarget () {
        this.__scrollTarget = getScrollTarget(this.$el, this.scrollTarget);
        this.__scrollTarget.addEventListener('scroll', this.__onVirtualScrollEvt, listenOpts.passive);
      },

      __unconfigureScrollTarget () {
        if (this.__scrollTarget !== void 0) {
          this.__scrollTarget.removeEventListener('scroll', this.__onVirtualScrollEvt, listenOpts.passive);
          this.__scrollTarget = void 0;
        }
      }
    },

    beforeMount () {
      this.__resetVirtualScroll();
    },

    mounted () {
      this.__configureScrollTarget();
    },

    activated () {
      this.__configureScrollTarget();
    },

    deactivated () {
      this.__unconfigureScrollTarget();
    },

    beforeDestroy () {
      this.__unconfigureScrollTarget();
    },

    render (h) {
      if (this.$scopedSlots.default === void 0) {
        console.error('QVirtualScroll: default scoped slot is required for rendering', this);
        return
      }

      let child = this.__padVirtualScroll(
        h,
        this.type === 'list' ? 'div' : 'tbody',
        this.virtualScrollScope.map(this.$scopedSlots.default)
      );

      if (this.$scopedSlots.before !== void 0) {
        child = this.$scopedSlots.before().concat(child);
      }

      child = mergeSlot(child, this, 'after');

      return this.type === '__qtable'
        ? getTableMiddle(h, { staticClass: this.classes }, child)
        : h(comps[this.type], {
          class: this.classes,
          attrs: this.attrs,
          props: this.qAttrs,
          on: { ...this.qListeners }
        }, child)
    }
  });

  function sortDate (a, b) {
    return (new Date(a)) - (new Date(b))
  }

  var Sort = {
    props: {
      sortMethod: {
        type: Function,
        default (data, sortBy, descending) {
          const col = this.colList.find(def => def.name === sortBy);
          if (col === void 0 || col.field === void 0) {
            return data
          }

          const
            dir = descending === true ? -1 : 1,
            val = typeof col.field === 'function'
              ? v => col.field(v)
              : v => v[col.field];

          return data.sort((a, b) => {
            let
              A = val(a),
              B = val(b);

            if (A === null || A === void 0) {
              return -1 * dir
            }
            if (B === null || B === void 0) {
              return 1 * dir
            }
            if (col.sort !== void 0) {
              return col.sort(A, B, a, b) * dir
            }
            if (isNumber(A) === true && isNumber(B) === true) {
              return (A - B) * dir
            }
            if (isDate(A) === true && isDate(B) === true) {
              return sortDate(A, B) * dir
            }
            if (typeof A === 'boolean' && typeof B === 'boolean') {
              return (A - B) * dir
            }

            [A, B] = [A, B].map(s => (s + '').toLocaleString().toLowerCase());

            return A < B
              ? -1 * dir
              : (A === B ? 0 : dir)
          })
        }
      },

      columnSortOrder: {
        type: String,
        validator: v => v === 'ad' || v === 'da',
        default: 'ad'
      }
    },

    computed: {
      columnToSort () {
        const { sortBy } = this.computedPagination;

        if (sortBy) {
          return this.colList.find(def => def.name === sortBy) || null
        }
      }
    },

    methods: {
      sort (col /* String(col name) or Object(col definition) */) {
        let sortOrder = this.columnSortOrder;

        if (isObject(col) === true) {
          if (col.sortOrder) {
            sortOrder = col.sortOrder;
          }

          col = col.name;
        }
        else {
          const def = this.colList.find(def => def.name === col);
          if (def !== void 0 && def.sortOrder) {
            sortOrder = def.sortOrder;
          }
        }

        let { sortBy, descending } = this.computedPagination;

        if (sortBy !== col) {
          sortBy = col;
          descending = sortOrder === 'da';
        }
        else if (this.binaryStateSort === true) {
          descending = !descending;
        }
        else if (descending === true) {
          if (sortOrder === 'ad') {
            sortBy = null;
          }
          else {
            descending = false;
          }
        }
        else { // ascending
          if (sortOrder === 'ad') {
            descending = true;
          }
          else {
            sortBy = null;
          }
        }

        this.setPagination({ sortBy, descending, page: 1 });
      }
    }
  };

  var Filter = {
    props: {
      filter: [String, Object],
      filterMethod: {
        type: Function,
        default (rows, terms, cols = this.computedCols, cellValue = this.getCellValue) {
          const lowerTerms = terms ? terms.toLowerCase() : '';
          return rows.filter(
            row => cols.some(col => {
              const val = cellValue(col, row) + '';
              const haystack = (val === 'undefined' || val === 'null') ? '' : val.toLowerCase();
              return haystack.indexOf(lowerTerms) !== -1
            })
          )
        }
      }
    },

    watch: {
      filter: {
        handler () {
          this.$nextTick(() => {
            this.setPagination({ page: 1 }, true);
          });
        },
        deep: true
      }
    }
  };

  function samePagination (oldPag, newPag) {
    for (const prop in newPag) {
      if (newPag[prop] !== oldPag[prop]) {
        return false
      }
    }
    return true
  }

  function fixPagination (p) {
    if (p.page < 1) {
      p.page = 1;
    }
    if (p.rowsPerPage !== void 0 && p.rowsPerPage < 1) {
      p.rowsPerPage = 0;
    }
    return p
  }

  var Pagination = {
    props: {
      pagination: Object,
      rowsPerPageOptions: {
        type: Array,
        default: () => [ 5, 7, 10, 15, 20, 25, 50, 0 ]
      }
    },

    computed: {
      computedPagination () {
        const pag = this.qListeners['update:pagination'] !== void 0
          ? { ...this.innerPagination, ...this.pagination }
          : this.innerPagination;

        return fixPagination(pag)
      },

      firstRowIndex () {
        const { page, rowsPerPage } = this.computedPagination;
        return (page - 1) * rowsPerPage
      },

      lastRowIndex () {
        const { page, rowsPerPage } = this.computedPagination;
        return page * rowsPerPage
      },

      isFirstPage () {
        return this.computedPagination.page === 1
      },

      pagesNumber () {
        return this.computedPagination.rowsPerPage === 0
          ? 1
          : Math.max(
            1,
            Math.ceil(this.computedRowsNumber / this.computedPagination.rowsPerPage)
          )
      },

      isLastPage () {
        return this.lastRowIndex === 0
          ? true
          : this.computedPagination.page >= this.pagesNumber
      },

      computedRowsPerPageOptions () {
        const opts = this.rowsPerPageOptions.includes(this.innerPagination.rowsPerPage)
          ? this.rowsPerPageOptions
          : [ this.innerPagination.rowsPerPage ].concat(this.rowsPerPageOptions);

        return opts.map(count => ({
          label: count === 0 ? this.$q.lang.table.allRows : '' + count,
          value: count
        }))
      }
    },

    watch: {
      pagesNumber (lastPage, oldLastPage) {
        if (lastPage === oldLastPage) {
          return
        }

        const currentPage = this.computedPagination.page;
        if (lastPage && !currentPage) {
          this.setPagination({ page: 1 });
        }
        else if (lastPage < currentPage) {
          this.setPagination({ page: lastPage });
        }
      }
    },

    methods: {
      __sendServerRequest (pagination) {
        this.requestServerInteraction({
          pagination,
          filter: this.filter
        });
      },

      setPagination (val, forceServerRequest) {
        const newPagination = fixPagination({
          ...this.computedPagination,
          ...val
        });

        if (samePagination(this.computedPagination, newPagination)) {
          if (this.isServerSide === true && forceServerRequest === true) {
            this.__sendServerRequest(newPagination);
          }
          return
        }

        if (this.isServerSide === true) {
          this.__sendServerRequest(newPagination);
          return
        }

        if (this.pagination !== void 0 && this.qListeners['update:pagination'] !== void 0) {
          this.$emit('update:pagination', newPagination);
        }
        else {
          this.innerPagination = newPagination;
        }
      },

      firstPage () {
        this.setPagination({ page: 1 });
      },

      prevPage () {
        const { page } = this.computedPagination;
        if (page > 1) {
          this.setPagination({ page: page - 1 });
        }
      },

      nextPage () {
        const { page, rowsPerPage } = this.computedPagination;
        if (this.lastRowIndex > 0 && page * rowsPerPage < this.computedRowsNumber) {
          this.setPagination({ page: page + 1 });
        }
      },

      lastPage () {
        this.setPagination({ page: this.pagesNumber });
      }
    },

    created () {
      if (this.qListeners['update:pagination'] !== void 0) {
        this.$emit('update:pagination', { ...this.computedPagination });
      }
    }
  };

  var RowSelection = {
    props: {
      selection: {
        type: String,
        default: 'none',
        validator: v => ['single', 'multiple', 'none'].includes(v)
      },
      selected: {
        type: Array,
        default: () => []
      }
    },

    computed: {
      selectedKeys () {
        const keys = {};
        this.selected.map(this.getRowKey).forEach(key => {
          keys[key] = true;
        });
        return keys
      },

      hasSelectionMode () {
        return this.selection !== 'none'
      },

      singleSelection () {
        return this.selection === 'single'
      },

      multipleSelection () {
        return this.selection === 'multiple'
      },

      allRowsSelected () {
        return this.computedRows.length > 0 && this.computedRows.every(
          row => this.selectedKeys[ this.getRowKey(row) ] === true
        )
      },

      someRowsSelected () {
        return this.allRowsSelected !== true &&
          this.computedRows.some(row => this.selectedKeys[ this.getRowKey(row) ] === true)
      },

      rowsSelectedNumber () {
        return this.selected.length
      }
    },

    methods: {
      isRowSelected (key) {
        return this.selectedKeys[key] === true
      },

      clearSelection () {
        this.$emit('update:selected', []);
      },

      __updateSelection (keys, rows, added, evt) {
        this.$emit('selection', { rows, added, keys, evt });

        const payload = this.singleSelection === true
          ? (added === true ? rows : [])
          : (
            added === true
              ? this.selected.concat(rows)
              : this.selected.filter(
                row => keys.includes(this.getRowKey(row)) === false
              )
          );

        this.$emit('update:selected', payload);
      }
    }
  };

  function getVal (val) {
    return Array.isArray(val)
      ? val.slice()
      : []
  }

  var RowExpand = {
    props: {
      expanded: Array // sync
    },

    data () {
      return {
        innerExpanded: getVal(this.expanded)
      }
    },

    watch: {
      expanded (val) {
        this.innerExpanded = getVal(val);
      }
    },

    methods: {
      isRowExpanded (key) {
        return this.innerExpanded.includes(key)
      },

      setExpanded (val) {
        if (this.expanded !== void 0) {
          this.$emit('update:expanded', val);
        }
        else {
          this.innerExpanded = val;
        }
      },

      __updateExpanded (key, add) {
        const target = this.innerExpanded.slice();
        const index = target.indexOf(key);

        if (add === true) {
          if (index === -1) {
            target.push(key);
            this.setExpanded(target);
          }
        }
        else if (index !== -1) {
          target.splice(index, 1);
          this.setExpanded(target);
        }
      }
    }
  };

  var ColumnSelection = {
    props: {
      visibleColumns: Array
    },

    computed: {
      colList () {
        if (this.columns !== void 0) {
          return this.columns
        }

        // we infer columns from first row
        const row = this.data[0];

        return row !== void 0
          ? Object.keys(row).map(name => ({
            name,
            label: name.toUpperCase(),
            field: name,
            align: isNumber(row[name]) ? 'right' : 'left',
            sortable: true
          }))
          : []
      },

      computedCols () {
        const { sortBy, descending } = this.computedPagination;

        const cols = this.visibleColumns !== void 0
          ? this.colList.filter(col => col.required === true || this.visibleColumns.includes(col.name) === true)
          : this.colList;

        return cols.map(col => {
          const align = col.align || 'right';
          const alignClass = `text-${align}`;

          return {
            ...col,
            align,
            __iconClass: `q-table__sort-icon q-table__sort-icon--${align}`,
            __thClass: alignClass +
              (col.headerClasses !== void 0 ? ' ' + col.headerClasses : '') +
              (col.sortable === true ? ' sortable' : '') +
              (col.name === sortBy ? ` sorted ${descending === true ? 'sort-desc' : ''}` : ''),

            __tdStyle: col.style !== void 0
              ? (
                typeof col.style !== 'function'
                  ? () => col.style
                  : col.style
              )
              : () => null,

            __tdClass: col.classes !== void 0
              ? (
                typeof col.classes !== 'function'
                  ? () => alignClass + ' ' + col.classes
                  : row => alignClass + ' ' + col.classes(row)
              )
              : () => alignClass
          }
        })
      },

      computedColsMap () {
        const names = {};
        this.computedCols.forEach(col => {
          names[col.name] = col;
        });
        return names
      },

      computedColspan () {
        return this.tableColspan !== void 0
          ? this.tableColspan
          : this.computedCols.length + (this.hasSelectionMode === true ? 1 : 0)
      }
    }
  };

  const commonVirtPropsObj = {};
  commonVirtPropsList.forEach(p => { commonVirtPropsObj[p] = {}; });

  var QTable = Vue.extend({
    name: 'QTable',

    mixins: [
      DarkMixin,
      ListenersMixin,

      FullscreenMixin,
      Top,
      TableHeader,
      TableBody,
      Bottom,
      TableGrid,
      Sort,
      Filter,
      Pagination,
      RowSelection,
      RowExpand,
      ColumnSelection
    ],

    props: {
      data: {
        type: Array,
        default: () => []
      },
      rowKey: {
        type: [ String, Function ],
        default: 'id'
      },

      columns: Array,
      loading: Boolean,
      binaryStateSort: Boolean,

      iconFirstPage: String,
      iconPrevPage: String,
      iconNextPage: String,
      iconLastPage: String,

      title: String,

      hideHeader: Boolean,

      grid: Boolean,
      gridHeader: Boolean,

      dense: Boolean,
      flat: Boolean,
      bordered: Boolean,
      square: Boolean,
      separator: {
        type: String,
        default: 'horizontal',
        validator: v => ['horizontal', 'vertical', 'cell', 'none'].includes(v)
      },
      wrapCells: Boolean,

      virtualScroll: Boolean,
      ...commonVirtPropsObj,

      noDataLabel: String,
      noResultsLabel: String,
      loadingLabel: String,
      selectedRowsLabel: Function,
      rowsPerPageLabel: String,
      paginationLabel: Function,

      color: {
        type: String,
        default: 'grey-8'
      },

      titleClass: [String, Array, Object],
      tableStyle: [String, Array, Object],
      tableClass: [String, Array, Object],
      tableHeaderStyle: [String, Array, Object],
      tableHeaderClass: [String, Array, Object],
      cardContainerClass: [String, Array, Object],
      cardContainerStyle: [String, Array, Object],
      cardStyle: [String, Array, Object],
      cardClass: [String, Array, Object]
    },

    data () {
      return {
        innerPagination: Object.assign({
          sortBy: null,
          descending: false,
          page: 1,
          rowsPerPage: this.rowsPerPageOptions.length > 0
            ? this.rowsPerPageOptions[0]
            : 5
        }, this.pagination)
      }
    },

    watch: {
      needsReset () {
        this.hasVirtScroll === true && this.$refs.virtScroll !== void 0 && this.$refs.virtScroll.reset();
      }
    },

    computed: {
      getRowKey () {
        return typeof this.rowKey === 'function'
          ? this.rowKey
          : row => row[this.rowKey]
      },

      hasVirtScroll () {
        return this.grid !== true && this.virtualScroll === true
      },

      needsReset () {
        return ['tableStyle', 'tableClass', 'tableHeaderStyle', 'tableHeaderClass', '__containerClass']
          .map(p => this[p]).join(';')
      },

      filteredSortedRows () {
        let rows = this.data;

        if (this.isServerSide === true || rows.length === 0) {
          return rows
        }

        const { sortBy, descending } = this.computedPagination;

        if (this.filter) {
          rows = this.filterMethod(rows, this.filter, this.computedCols, this.getCellValue);
        }

        if (this.columnToSort !== void 0) {
          rows = this.sortMethod(
            this.data === rows ? rows.slice() : rows,
            sortBy,
            descending
          );
        }

        return rows
      },

      filteredSortedRowsNumber () {
        return this.filteredSortedRows.length
      },

      computedRows () {
        let rows = this.filteredSortedRows;

        if (this.isServerSide === true) {
          return rows
        }

        const { rowsPerPage } = this.computedPagination;

        if (rowsPerPage !== 0) {
          if (this.firstRowIndex === 0 && this.data !== rows) {
            if (rows.length > this.lastRowIndex) {
              rows = rows.slice(0, this.lastRowIndex);
            }
          }
          else {
            rows = rows.slice(this.firstRowIndex, this.lastRowIndex);
          }
        }

        return rows
      },

      computedRowsNumber () {
        return this.isServerSide === true
          ? this.computedPagination.rowsNumber || 0
          : this.filteredSortedRowsNumber
      },

      nothingToDisplay () {
        return this.computedRows.length === 0
      },

      isServerSide () {
        return this.computedPagination.rowsNumber !== void 0
      },

      cardDefaultClass () {
        return ' q-table__card' +
          (this.isDark === true ? ' q-table__card--dark q-dark' : '') +
          (this.square === true ? ' q-table--square' : '') +
          (this.flat === true ? ' q-table--flat' : '') +
          (this.bordered === true ? ' q-table--bordered' : '')
      },

      __containerClass () {
        return `q-table__container q-table--${this.separator}-separator column no-wrap` +
          (this.grid === true ? ' q-table--grid' : this.cardDefaultClass) +
          (this.isDark === true ? ' q-table--dark' : '') +
          (this.dense === true ? ' q-table--dense' : '') +
          (this.wrapCells === false ? ' q-table--no-wrap' : '') +
          (this.inFullscreen === true ? ' fullscreen scroll' : '')
      },

      containerClass () {
        // do not trigger a refresh of the table when the loading status is changed
        return this.__containerClass +
          (this.loading === true ? ' q-table--loading' : '')
      },

      virtProps () {
        const props = {};

        commonVirtPropsList
          .forEach(p => { props[p] = this[p]; });

        if (props.virtualScrollItemSize === void 0) {
          props.virtualScrollItemSize = this.dense === true ? 28 : 48;
        }

        return props
      }
    },

    render (h) {
      const child = [ this.__getTopDiv(h) ];
      const data = { staticClass: this.containerClass };

      if (this.grid === true) {
        child.push(this.__getGridHeader(h));
      }
      else {
        Object.assign(data, {
          class: this.cardClass,
          style: this.cardStyle
        });
      }

      child.push(
        this.__getBody(h),
        this.__getBottomDiv(h)
      );

      if (this.loading === true && this.$scopedSlots.loading !== void 0) {
        child.push(
          this.$scopedSlots.loading()
        );
      }

      return h('div', data, child)
    },

    methods: {
      requestServerInteraction (prop = {}) {
        this.$nextTick(() => {
          this.$emit('request', {
            pagination: prop.pagination || this.computedPagination,
            filter: prop.filter || this.filter,
            getCellValue: this.getCellValue
          });
        });
      },

      resetVirtualScroll () {
        this.hasVirtScroll === true && this.$refs.virtScroll.reset();
      },

      __getBody (h) {
        if (this.grid === true) {
          return this.__getGridBody(h)
        }

        const header = this.hideHeader !== true ? this.__getTHead(h) : null;

        if (this.hasVirtScroll === true) {
          const topRow = this.$scopedSlots['top-row'];
          const bottomRow = this.$scopedSlots['bottom-row'];

          const virtSlots = {
            default: this.__getVirtualTBodyTR(h)
          };

          if (topRow !== void 0) {
            const topContent = h('tbody', topRow({ cols: this.computedCols }));

            virtSlots.before = header === null
              ? () => [topContent]
              : () => [header].concat(topContent);
          }
          else if (header !== null) {
            virtSlots.before = () => header;
          }

          if (bottomRow !== void 0) {
            virtSlots.after = () => h('tbody', bottomRow({ cols: this.computedCols }));
          }

          return h(QVirtualScroll, {
            ref: 'virtScroll',
            props: {
              ...this.virtProps,
              items: this.computedRows,
              type: '__qtable',
              tableColspan: this.computedColspan
            },
            on: cache(this, 'vs', {
              'virtual-scroll': this.__onVScroll
            }),
            class: this.tableClass,
            style: this.tableStyle,
            scopedSlots: virtSlots
          })
        }

        return getTableMiddle(h, {
          staticClass: 'scroll',
          class: this.tableClass,
          style: this.tableStyle
        }, [
          header,
          this.__getTBody(h)
        ])
      },

      scrollTo (toIndex, edge) {
        if (this.$refs.virtScroll !== void 0) {
          this.$refs.virtScroll.scrollTo(toIndex, edge);
          return
        }

        toIndex = parseInt(toIndex, 10);
        const rowEl = this.$el.querySelector(`tbody tr:nth-of-type(${toIndex + 1})`);

        if (rowEl !== null) {
          const scrollTarget = this.$el.querySelector('.q-table__middle.scroll');
          const { offsetTop } = rowEl;
          const direction = offsetTop < scrollTarget.scrollTop ? 'decrease' : 'increase';

          scrollTarget.scrollTop = offsetTop;

          this.$emit('virtual-scroll', {
            index: toIndex,
            from: 0,
            to: this.pagination.rowsPerPage - 1,
            direction
          });
        }
      },

      __onVScroll (info) {
        this.$emit('virtual-scroll', info);
      },

      __getProgress (h) {
        return [
          h(QLinearProgress, {
            staticClass: 'q-table__linear-progress',
            props: {
              color: this.color,
              dark: this.isDark,
              indeterminate: true,
              trackColor: 'transparent'
            }
          })
        ]
      }
    }
  });

  var QTr = Vue.extend({
    name: 'QTr',

    mixins: [ ListenersMixin ],

    props: {
      props: Object,
      noHover: Boolean
    },

    computed: {
      classes () {
        return 'q-tr' + (this.props === void 0 || this.props.header === true ? '' : ' ' + this.props.__trClass) +
          (this.noHover === true ? ' q-tr--no-hover' : '')
      }
    },

    render (h) {
      return h('tr', {
        on: { ...this.qListeners },
        class: this.classes
      }, slot(this, 'default'))
    }
  });

  var QTd = Vue.extend({
    name: 'QTd',

    mixins: [ ListenersMixin ],

    props: {
      props: Object,
      autoWidth: Boolean,
      noHover: Boolean
    },

    computed: {
      classes () {
        return 'q-td' + (this.autoWidth === true ? ' q-table--col-auto-width' : '') +
          (this.noHover === true ? ' q-td--no-hover' : '') + ' '
      }
    },

    render (h) {
      const on = this.qListeners;

      if (this.props === void 0) {
        return h('td', {
          on,
          class: this.classes
        }, slot(this, 'default'))
      }

      const name = this.$vnode.key;

      const col = this.props.colsMap !== void 0 && name
        ? this.props.colsMap[name]
        : this.props.col;

      if (col === void 0) { return }

      const row = this.props.row;

      return h('td', {
        on,
        style: col.__tdStyle(row),
        class: this.classes + col.__tdClass(row)
      }, slot(this, 'default'))
    }
  });

  const trailingSlashRE = /\/?$/;

  function equals (current, target) {
    if (Object.keys(current).length !== Object.keys(target).length) {
      return false
    }

    // route query and params are strings when read from URL
    for (const key in target) {
      if (!(key in current) || String(current[key]) !== String(target[key])) {
        return false
      }
    }
    return true
  }

  function includes (current, target) {
    for (const key in target) {
      if (!(key in current)) {
        return false
      }
    }
    return true
  }

  function isSameRoute (current, target) {
    if (!target) {
      return false
    }

    if (current.path && target.path) {
      return (
        current.path.replace(trailingSlashRE, '') === target.path.replace(trailingSlashRE, '') &&
        current.hash === target.hash &&
        equals(current.query, target.query)
      )
    }

    return typeof current.name === 'string' &&
      current.name === target.name &&
      current.hash === target.hash &&
      equals(current.query, target.query) === true &&
      equals(current.params, target.params) === true
  }

  function isIncludedRoute (current, target) {
    return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 &&
      (typeof target.hash !== 'string' || target.hash.length < 2 || current.hash === target.hash) &&
      includes(current.query, target.query) === true
  }

  var QRouteTab = Vue.extend({
    name: 'QRouteTab',

    mixins: [ QTab, RouterLinkMixin ],

    inject: {
      __activateRoute: {},
      __recalculateScroll: {}
    },

    watch: {
      $route () {
        this.__checkActivation();
      }
    },

    computed: {
      routerTabLinkProps () {
        return {
          ...this.linkProps.props,
          custom: true
        }
      }
    },

    methods: {
      __activate (e, keyboard) {
        if (this.disable !== true) {
          if (
            e !== void 0 && (
              e.ctrlKey === true ||
              e.shiftKey === true ||
              e.altKey === true ||
              e.metaKey === true
            )
          ) {
            // if it has meta keys, let vue-router link
            // handle this by its own
            this.__checkActivation(true);
          }
          else if (this.hasRouterLink === true) {
            // we use programatic navigation instead of letting vue-router handle it
            // so we can check for activation when the navigation is complete
            e !== void 0 && stopAndPrevent(e);

            const go = (to = this.to, append = this.append, replace = this.replace) => {
              const { route } = this.$router.resolve(to, this.$route, append);
              const checkFn = to === this.to && append === this.append
                ? this.__checkActivation
                : noop;

              // vue-router now throwing error if navigating
              // to the same route that the user is currently at
              // https://github.com/vuejs/vue-router/issues/2872
              this.$router[replace === true ? 'replace' : 'push'](
                route,
                () => { checkFn(true); },
                err => {
                  if (err && err.name === 'NavigationDuplicated') {
                    checkFn(true);
                  }
                }
              );
            };

            this.qListeners.click !== void 0 && this.$emit('click', e, go);
            if (e === void 0 || e.navigate !== false) {
              go();
            }
          }
        }

        if (keyboard === true) {
          this.$el.focus({ preventScroll: true });
        }
        else if (this.$refs.blurTarget !== void 0) {
          this.$refs.blurTarget.focus({ preventScroll: true });
        }
      },

      __checkActivation (selected = false) {
        if (this.hasRouterLink !== true) {
          return
        }

        const
          current = this.$route,
          { href, location, route } = this.$router.resolve(this.to, current, this.append),
          redirected = route.redirectedFrom !== void 0,
          isSameRouteCheck = isSameRoute(current, route),
          checkFunction = this.exact === true ? isSameRoute : isIncludedRoute,
          params = {
            name: this.name,
            selected,
            exact: this.exact,
            priorityMatched: route.matched.length,
            priorityHref: href.length
          };

        if (isSameRouteCheck === true || (this.exact !== true && isIncludedRoute(current, route) === true)) {
          this.__activateRoute({
            ...params,
            redirected,
            // if it's an exact match give higher priority
            // even if the tab is not marked as exact
            exact: this.exact === true || isSameRouteCheck === true
          });
        }

        if (
          redirected === true &&
          checkFunction(current, {
            path: route.redirectedFrom,
            ...location
          }) === true
        ) {
          this.__activateRoute(params);
        }

        this.isActive === true && this.__activateRoute();
      }
    },

    mounted () {
      this.__recalculateScroll();
      this.$router !== void 0 && this.__checkActivation();
    },

    beforeDestroy () {
      this.__recalculateScroll();
      this.__activateRoute({ remove: true, name: this.name });
    },

    render (h) {
      return this.__renderTab(h, this.linkTag)
    }
  });

  var QTime = Vue.extend({
    name: 'QTime',

    mixins: [ DateTimeMixin ],

    directives: {
      TouchPan
    },

    props: {
      mask: {
        default: null
      },

      format24h: {
        type: Boolean,
        default: null
      },

      defaultDate: {
        type: String,
        validator: v => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v)
      },

      options: Function,
      hourOptions: Array,
      minuteOptions: Array,
      secondOptions: Array,

      withSeconds: Boolean,
      nowBtn: Boolean
    },

    data () {
      const model = __splitDate(
        this.value,
        this.__getMask(),
        this.__getLocale(),
        this.calendar,
        this.__getDefaultDateModel()
      );

      let view = 'Hour';

      if (model.hour !== null) {
        if (model.minute === null) {
          view = 'Minute';
        }
        else if (this.withSeconds === true && model.second === null) {
          view = 'Second';
        }
      }

      return {
        view,
        isAM: model.hour === null || model.hour < 12,
        innerModel: model
      }
    },

    watch: {
      value (v) {
        const model = __splitDate(
          v,
          this.computedMask,
          this.computedLocale,
          this.calendar,
          this.defaultDateModel
        );

        if (
          model.dateHash !== this.innerModel.dateHash ||
          model.timeHash !== this.innerModel.timeHash
        ) {
          this.innerModel = model;

          if (model.hour === null) {
            this.view = 'Hour';
          }
          else {
            this.isAM = model.hour < 12;
          }
        }
      },

      computedMask () {
        this.$nextTick(() => {
          this.__updateValue();
        });
      },

      computedLocale () {
        this.$nextTick(() => {
          this.__updateValue();
        });
      }
    },

    computed: {
      classes () {
        return `q-time q-time--${this.landscape === true ? 'landscape' : 'portrait'}` +
          (this.isDark === true ? ' q-time--dark q-dark' : '') +
          (this.disable === true ? ' disabled' : (this.readonly === true ? ' q-time--readonly' : '')) +
          (this.bordered === true ? ' q-time--bordered' : '') +
          (this.square === true ? ' q-time--square no-border-radius' : '') +
          (this.flat === true ? ' q-time--flat no-shadow' : '')
      },

      stringModel () {
        const time = this.innerModel;

        return {
          hour: time.hour === null
            ? '--'
            : (
              this.computedFormat24h === true
                ? pad(time.hour)
                : String(
                  this.isAM === true
                    ? (time.hour === 0 ? 12 : time.hour)
                    : (time.hour > 12 ? time.hour - 12 : time.hour)
                )
            ),
          minute: time.minute === null
            ? '--'
            : pad(time.minute),
          second: time.second === null
            ? '--'
            : pad(time.second)
        }
      },

      defaultDateModel () {
        return this.__getDefaultDateModel()
      },

      computedFormat24h () {
        return this.format24h !== null
          ? this.format24h
          : this.$q.lang.date.format24h
      },

      pointerStyle () {
        const
          forHour = this.view === 'Hour',
          divider = forHour === true ? 12 : 60,
          amount = this.innerModel[this.view.toLowerCase()],
          degrees = Math.round(amount * (360 / divider)) - 180;

        let transform = `rotate(${degrees}deg) translateX(-50%)`;

        if (
          forHour === true &&
          this.computedFormat24h === true &&
          this.innerModel.hour >= 12
        ) {
          transform += ' scale(.7)';
        }

        return { transform }
      },

      minLink () {
        return this.innerModel.hour !== null
      },

      secLink () {
        return this.minLink === true && this.innerModel.minute !== null
      },

      hourInSelection () {
        return this.hourOptions !== void 0
          ? val => this.hourOptions.includes(val)
          : (
            this.options !== void 0
              ? val => this.options(val, null, null)
              : void 0
          )
      },

      minuteInSelection () {
        return this.minuteOptions !== void 0
          ? val => this.minuteOptions.includes(val)
          : (
            this.options !== void 0
              ? val => this.options(this.innerModel.hour, val, null)
              : void 0
          )
      },

      secondInSelection () {
        return this.secondOptions !== void 0
          ? val => this.secondOptions.includes(val)
          : (
            this.options !== void 0
              ? val => this.options(this.innerModel.hour, this.innerModel.minute, val)
              : void 0
          )
      },

      validHours () {
        if (this.hourInSelection !== void 0) {
          const am = this.__getValidValues(0, 11, this.hourInSelection);
          const pm = this.__getValidValues(12, 11, this.hourInSelection);
          return { am, pm, values: am.values.concat(pm.values) }
        }
      },

      validMinutes () {
        if (this.minuteInSelection !== void 0) {
          return this.__getValidValues(0, 59, this.minuteInSelection)
        }
      },

      validSeconds () {
        if (this.secondInSelection !== void 0) {
          return this.__getValidValues(0, 59, this.secondInSelection)
        }
      },

      viewValidOptions () {
        switch (this.view) {
          case 'Hour':
            return this.validHours
          case 'Minute':
            return this.validMinutes
          case 'Second':
            return this.validSeconds
        }
      },

      positions () {
        let start, end, offset = 0, step = 1;
        const values = this.viewValidOptions !== void 0
          ? this.viewValidOptions.values
          : void 0;

        if (this.view === 'Hour') {
          if (this.computedFormat24h === true) {
            start = 0;
            end = 23;
          }
          else {
            start = 0;
            end = 11;

            if (this.isAM === false) {
              offset = 12;
            }
          }
        }
        else {
          start = 0;
          end = 55;
          step = 5;
        }

        const pos = [];

        for (let val = start, index = start; val <= end; val += step, index++) {
          const
            actualVal = val + offset,
            disable = values !== void 0 && values.includes(actualVal) === false,
            label = this.view === 'Hour' && val === 0
              ? (this.computedFormat24h === true ? '00' : '12')
              : val;

          pos.push({ val: actualVal, index, disable, label });
        }

        return pos
      }
    },

    methods: {
      setNow () {
        const date = {
          ...this.__getCurrentDate(),
          ...this.__getCurrentTime()
        };

        this.__updateValue(date);
        Object.assign(this.innerModel, date); // reset any pending changes to innerModel

        this.view = 'Hour';
      },

      __getValidValues (start, count, testFn) {
        const values = Array.apply(null, { length: count + 1 })
          .map((_, index) => {
            const i = index + start;
            return {
              index: i,
              val: testFn(i) === true // force boolean
            }
          })
          .filter(v => v.val === true)
          .map(v => v.index);

        return {
          min: values[0],
          max: values[values.length - 1],
          values,
          threshold: count + 1
        }
      },

      __getWheelDist (a, b, threshold) {
        const diff = Math.abs(a - b);
        return Math.min(diff, threshold - diff)
      },

      __getNormalizedClockValue (val, { min, max, values, threshold }) {
        if (val === min) {
          return min
        }

        if (val < min || val > max) {
          return this.__getWheelDist(val, min, threshold) <= this.__getWheelDist(val, max, threshold)
            ? min
            : max
        }

        const
          index = values.findIndex(v => val <= v),
          before = values[index - 1],
          after = values[index];

        return val - before <= after - val
          ? before
          : after
      },

      __getMask () {
        return this.calendar !== 'persian' && this.mask !== null
          ? this.mask
          : `HH:mm${this.withSeconds === true ? ':ss' : ''}`
      },

      __getDefaultDateModel () {
        if (typeof this.defaultDate !== 'string') {
          const date = this.__getCurrentDate(true);
          date.dateHash = this.__getDayHash(date);
          return date
        }

        return __splitDate(this.defaultDate, 'YYYY/MM/DD', void 0, this.calendar)
      },

      __click (evt) {
        if (this.__shouldAbortInteraction() !== true) {
          // __activate() has already updated the offset
          // (on desktop only, through mousedown event)
          if (this.$q.platform.is.desktop !== true) {
            this.__updateClock(evt, this.__getClockRect());
          }

          this.__goToNextView();
        }
      },

      __activate (evt) {
        if (this.__shouldAbortInteraction() !== true) {
          this.__updateClock(evt, this.__getClockRect());
        }
      },

      __shouldAbortInteraction () {
        return this._isBeingDestroyed === true ||
          this._isDestroyed === true ||
          // if we have limited options, can we actually set any?
          (
            this.viewValidOptions !== void 0 &&
            (
              this.viewValidOptions.values.length === 0 ||
              (
                this.view === 'Hour' && this.computedFormat24h !== true &&
                this.validHours[this.isAM === true ? 'am' : 'pm'].values.length === 0
              )
            )
          )
      },

      __getClockRect () {
        const
          clock = this.$refs.clock,
          { top, left, width } = clock.getBoundingClientRect(),
          dist = width / 2;

        return {
          top: top + dist,
          left: left + dist,
          dist: dist * 0.7
        }
      },

      __goToNextView () {
        if (this.view === 'Hour') {
          this.view = 'Minute';
        }
        else if (this.withSeconds && this.view === 'Minute') {
          this.view = 'Second';
        }
      },

      __drag (event) {
        if (this.__shouldAbortInteraction() === true) {
          return
        }

        if (event.isFirst === true) {
          this.draggingClockRect = this.__getClockRect();
          this.dragCache = this.__updateClock(event.evt, this.draggingClockRect);
          return
        }

        this.dragCache = this.__updateClock(event.evt, this.draggingClockRect, this.dragCache);

        if (event.isFinal === true) {
          this.draggingClockRect = false;
          this.dragCache = null;
          this.__goToNextView();
        }
      },

      __updateClock (evt, clockRect, cacheVal) {
        const
          pos = position(evt),
          height = Math.abs(pos.top - clockRect.top),
          distance = Math.sqrt(
            Math.pow(Math.abs(pos.top - clockRect.top), 2) +
            Math.pow(Math.abs(pos.left - clockRect.left), 2)
          );

        let
          val,
          angle = Math.asin(height / distance) * (180 / Math.PI);

        if (pos.top < clockRect.top) {
          angle = clockRect.left < pos.left ? 90 - angle : 270 + angle;
        }
        else {
          angle = clockRect.left < pos.left ? angle + 90 : 270 - angle;
        }

        if (this.view === 'Hour') {
          val = angle / 30;

          if (this.validHours !== void 0) {
            const am = this.computedFormat24h !== true
              ? this.isAM === true
              : (
                this.validHours.am.values.length > 0 && this.validHours.pm.values.length > 0
                  ? distance >= clockRect.dist
                  : this.validHours.am.values.length > 0
              );

            val = this.__getNormalizedClockValue(
              val + (am === true ? 0 : 12),
              this.validHours[am === true ? 'am' : 'pm']
            );
          }
          else {
            val = Math.round(val);

            if (this.computedFormat24h === true) {
              if (distance < clockRect.dist) {
                if (val < 12) {
                  val += 12;
                }
              }
              else if (val === 12) {
                val = 0;
              }
            }
            else if (this.isAM === true && val === 12) {
              val = 0;
            }
            else if (this.isAM === false && val !== 12) {
              val += 12;
            }
          }

          if (this.computedFormat24h === true) {
            this.isAM = val < 12;
          }
        }
        else {
          val = Math.round(angle / 6) % 60;

          if (this.view === 'Minute' && this.validMinutes !== void 0) {
            val = this.__getNormalizedClockValue(val, this.validMinutes);
          }
          else if (this.view === 'Second' && this.validSeconds !== void 0) {
            val = this.__getNormalizedClockValue(val, this.validSeconds);
          }
        }

        if (cacheVal !== val) {
          this[`__set${this.view}`](val);
        }

        return val
      },

      __onKeyupHour (e) {
        if (e.keyCode === 13) { // ENTER
          this.view = 'Hour';
        }
        else if ([ 37, 39 ].includes(e.keyCode)) {
          const payload = e.keyCode === 37 ? -1 : 1;

          if (this.validHours !== void 0) {
            const values = this.computedFormat24h === true
              ? this.validHours.values
              : this.validHours[this.isAM === true ? 'am' : 'pm'].values;

            if (values.length === 0) { return }

            if (this.innerModel.hour === null) {
              this.__setHour(values[0]);
            }
            else {
              const index = (
                values.length +
                values.indexOf(this.innerModel.hour) +
                payload
              ) % values.length;

              this.__setHour(values[index]);
            }
          }
          else {
            const
              wrap = this.computedFormat24h === true ? 24 : 12,
              offset = this.computedFormat24h !== true && this.isAM === false ? 12 : 0,
              val = this.innerModel.hour === null ? -payload : this.innerModel.hour;

            this.__setHour(offset + (24 + val + payload) % wrap);
          }
        }
      },

      __onKeyupMinute (e) {
        if (e.keyCode === 13) { // ENTER
          this.view = 'Minute';
        }
        else if ([ 37, 39 ].includes(e.keyCode)) {
          const payload = e.keyCode === 37 ? -1 : 1;

          if (this.validMinutes !== void 0) {
            const values = this.validMinutes.values;

            if (values.length === 0) { return }

            if (this.innerModel.minute === null) {
              this.__setMinute(values[0]);
            }
            else {
              const index = (
                values.length +
                values.indexOf(this.innerModel.minute) +
                payload
              ) % values.length;

              this.__setMinute(values[index]);
            }
          }
          else {
            const val = this.innerModel.minute === null ? -payload : this.innerModel.minute;
            this.__setMinute((60 + val + payload) % 60);
          }
        }
      },

      __onKeyupSecond (e) {
        if (e.keyCode === 13) { // ENTER
          this.view = 'Second';
        }
        else if ([ 37, 39 ].includes(e.keyCode)) {
          const payload = e.keyCode === 37 ? -1 : 1;

          if (this.validSeconds !== void 0) {
            const values = this.validSeconds.values;

            if (values.length === 0) { return }

            if (this.innerModel.seconds === null) {
              this.__setSecond(values[0]);
            }
            else {
              const index = (
                values.length +
                values.indexOf(this.innerModel.second) +
                payload
              ) % values.length;

              this.__setSecond(values[index]);
            }
          }
          else {
            const val = this.innerModel.second === null ? -payload : this.innerModel.second;
            this.__setSecond((60 + val + payload) % 60);
          }
        }
      },

      __getHeader (h) {
        const label = [
          h('div', {
            staticClass: 'q-time__link',
            class: this.view === 'Hour' ? 'q-time__link--active' : 'cursor-pointer',
            attrs: { tabindex: this.computedTabindex },
            on: cache(this, 'vH', {
              click: () => { this.view = 'Hour'; },
              keyup: this.__onKeyupHour
            })
          }, [ this.stringModel.hour ]),

          h('div', [ ':' ]),

          h(
            'div',
            this.minLink === true
              ? {
                staticClass: 'q-time__link',
                class: this.view === 'Minute' ? 'q-time__link--active' : 'cursor-pointer',
                attrs: { tabindex: this.computedTabindex },
                on: cache(this, 'vM', {
                  click: () => { this.view = 'Minute'; },
                  keyup: this.__onKeyupMinute
                })
              }
              : { staticClass: 'q-time__link' },
            [ this.stringModel.minute ]
          )
        ];

        if (this.withSeconds === true) {
          label.push(
            h('div', [ ':' ]),

            h(
              'div',
              this.secLink === true
                ? {
                  staticClass: 'q-time__link',
                  class: this.view === 'Second' ? 'q-time__link--active' : 'cursor-pointer',
                  attrs: { tabindex: this.computedTabindex },
                  on: cache(this, 'vS', {
                    click: () => { this.view = 'Second'; },
                    keyup: this.__onKeyupSecond
                  })
                }
                : { staticClass: 'q-time__link' },
              [ this.stringModel.second ]
            )
          );
        }

        return h('div', {
          staticClass: 'q-time__header flex flex-center no-wrap',
          class: this.headerClass
        }, [
          h('div', {
            staticClass: 'q-time__header-label row items-center no-wrap',
            attrs: { dir: 'ltr' }
          }, label),

          this.computedFormat24h === false ? h('div', {
            staticClass: 'q-time__header-ampm column items-between no-wrap'
          }, [
            h('div', {
              staticClass: 'q-time__link',
              class: this.isAM === true ? 'q-time__link--active' : 'cursor-pointer',
              attrs: { tabindex: this.computedTabindex },
              on: cache(this, 'AM', {
                click: this.__setAm,
                keyup: e => { e.keyCode === 13 && this.__setAm(); }
              })
            }, [ 'AM' ]),

            h('div', {
              staticClass: 'q-time__link',
              class: this.isAM !== true ? 'q-time__link--active' : 'cursor-pointer',
              attrs: { tabindex: this.computedTabindex },
              on: cache(this, 'PM', {
                click: this.__setPm,
                keyup: e => { e.keyCode === 13 && this.__setPm(); }
              })
            }, [ 'PM' ])
          ]) : null
        ])
      },

      __getClock (h) {
        const
          view = this.view.toLowerCase(),
          current = this.innerModel[view];

        return h('div', {
          staticClass: 'q-time__content col relative-position'
        }, [
          h('transition', {
            props: { name: 'q-transition--scale' }
          }, [
            h('div', {
              key: 'clock' + this.view,
              staticClass: 'q-time__container-parent absolute-full'
            }, [
              h('div', {
                ref: 'clock',
                staticClass: 'q-time__container-child fit overflow-hidden'
              }, [
                h('div', {
                  staticClass: 'q-time__clock cursor-pointer non-selectable',
                  on: cache(this, 'click', {
                    click: this.__click,
                    mousedown: this.__activate
                  }),
                  directives: cache(this, 'touch', [{
                    name: 'touch-pan',
                    value: this.__drag,
                    modifiers: {
                      stop: true,
                      prevent: true,
                      mouse: true
                    }
                  }])
                }, [
                  h('div', { staticClass: 'q-time__clock-circle fit' }, [
                    h('div', {
                      staticClass: 'q-time__clock-pointer',
                      style: this.pointerStyle,
                      class: this.innerModel[view] === null ? 'hidden' : (this.color !== void 0 ? `text-${this.color}` : '')
                    }),

                    this.positions.map(pos => h('div', {
                      staticClass: `q-time__clock-position row flex-center q-time__clock-pos-${pos.index}`,
                      class: pos.val === current
                        ? this.headerClass.concat(' q-time__clock-position--active')
                        : (pos.disable === true ? 'q-time__clock-position--disable' : null)
                    }, [ h('span', [ pos.label ]) ]))
                  ])
                ])
              ])
            ])
          ]),

          this.nowBtn === true ? h(QBtn, {
            staticClass: 'q-time__now-button absolute',
            props: {
              icon: this.$q.iconSet.datetime.now,
              unelevated: true,
              size: 'sm',
              round: true,
              color: this.color,
              textColor: this.textColor,
              tabindex: this.computedTabindex
            },
            on: cache(this, 'now', {
              click: this.setNow
            })
          }) : null
        ])
      },

      __setHour (hour) {
        if (this.innerModel.hour !== hour) {
          this.innerModel.hour = hour;
          this.innerModel.minute = null;
          this.innerModel.second = null;
        }
      },

      __setMinute (minute) {
        if (this.innerModel.minute !== minute) {
          this.innerModel.minute = minute;
          this.innerModel.second = null;
          this.withSeconds !== true && this.__updateValue({ minute });
        }
      },

      __setSecond (second) {
        this.innerModel.second !== second && this.__updateValue({ second });
      },

      __setAm () {
        if (this.isAM === false) {
          this.isAM = true;

          if (this.innerModel.hour !== null) {
            this.innerModel.hour -= 12;
            this.__verifyAndUpdate();
          }
        }
      },

      __setPm () {
        if (this.isAM === true) {
          this.isAM = false;

          if (this.innerModel.hour !== null) {
            this.innerModel.hour += 12;
            this.__verifyAndUpdate();
          }
        }
      },

      __verifyAndUpdate () {
        if (this.hourInSelection !== void 0 && this.hourInSelection(this.innerModel.hour) !== true) {
          this.innerModel = __splitDate();
          this.view = 'Hour';
          return
        }

        if (this.minuteInSelection !== void 0 && this.minuteInSelection(this.innerModel.minute) !== true) {
          this.innerModel.minute = null;
          this.innerModel.second = null;
          this.view = 'Minute';
          return
        }

        if (this.withSeconds === true && this.secondInSelection !== void 0 && this.secondInSelection(this.innerModel.second) !== true) {
          this.innerModel.second = null;
          this.view = 'Second';
          return
        }

        if (this.innerModel.hour === null || this.innerModel.minute === null || (this.withSeconds === true && this.innerModel.second === null)) {
          return
        }

        this.__updateValue();
      },

      __updateValue (obj) {
        const date = Object.assign({ ...this.innerModel }, obj);

        const val = this.calendar === 'persian'
          ? pad(date.hour) + ':' +
            pad(date.minute) +
            (this.withSeconds === true ? ':' + pad(date.second) : '')
          : formatDate(
            new Date(
              date.year,
              date.month === null ? null : date.month - 1,
              date.day,
              date.hour,
              date.minute,
              date.second,
              date.millisecond
            ),
            this.computedMask,
            this.computedLocale,
            date.year,
            date.timezoneOffset
          );

        date.changed = val !== this.value;
        this.$emit('input', val, date);
      }
    },

    render (h) {
      const child = [
        this.__getClock(h)
      ];

      const def = slot(this, 'default');
      def !== void 0 && child.push(
        h('div', { staticClass: 'q-time__actions' }, def)
      );

      if (this.name !== void 0 && this.disable !== true) {
        this.__injectFormInput(child, 'push');
      }

      return h('div', {
        class: this.classes,
        on: { ...this.qListeners },
        attrs: { tabindex: -1 }
      }, [
        this.__getHeader(h),
        h('div', { staticClass: 'q-time__main col overflow-auto' }, child)
      ])
    }
  });

  var QTimeline = Vue.extend({
    name: 'QTimeline',

    mixins: [ DarkMixin, ListenersMixin ],

    provide () {
      return {
        __timeline: this
      }
    },

    props: {
      color: {
        type: String,
        default: 'primary'
      },
      side: {
        type: String,
        default: 'right',
        validator: v => ['left', 'right'].includes(v)
      },
      layout: {
        type: String,
        default: 'dense',
        validator: v => ['dense', 'comfortable', 'loose'].includes(v)
      }
    },

    computed: {
      classes () {
        return `q-timeline--${this.layout} q-timeline--${this.layout}--${this.side}` +
          (this.isDark === true ? ' q-timeline--dark' : '')
      }
    },

    render (h) {
      return h('ul', {
        staticClass: 'q-timeline',
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var QTimelineEntry = Vue.extend({
    name: 'QTimelineEntry',

    inject: {
      __timeline: {
        default () {
          console.error('QTimelineEntry needs to be child of QTimeline');
        }
      }
    },

    mixins: [ ListenersMixin ],

    props: {
      heading: Boolean,
      tag: {
        type: String,
        default: 'h3'
      },
      side: {
        type: String,
        default: 'right',
        validator: v => ['left', 'right'].includes(v)
      },

      icon: String,
      avatar: String,

      color: String,

      title: String,
      subtitle: String,
      body: String
    },

    computed: {
      colorClass () {
        return `text-${this.color || this.__timeline.color}`
      },

      classes () {
        return `q-timeline__entry--${this.side}` +
          (this.icon !== void 0 || this.avatar !== void 0 ? ' q-timeline__entry--icon' : '')
      },

      reverse () {
        return this.__timeline.layout === 'comfortable' && this.__timeline.side === 'left'
      }
    },

    render (h) {
      const child = uniqueSlot(this, 'default', []);

      if (this.body !== void 0) {
        child.unshift(this.body);
      }

      if (this.heading === true) {
        const content = [
          h('div'),
          h('div'),
          h(
            this.tag,
            { staticClass: 'q-timeline__heading-title' },
            child
          )
        ];

        return h('div', {
          staticClass: 'q-timeline__heading',
          on: { ...this.qListeners }
        }, this.reverse === true ? content.reverse() : content)
      }

      let dot;

      if (this.icon !== void 0) {
        dot = [
          h(QIcon, {
            staticClass: 'row items-center justify-center',
            props: { name: this.icon }
          })
        ];
      }
      else if (this.avatar !== void 0) {
        dot = [
          h('img', {
            staticClass: 'q-timeline__dot-img',
            domProps: { src: this.avatar }
          })
        ];
      }

      const content = [
        h('div', { staticClass: 'q-timeline__subtitle' }, [
          h('span', slot(this, 'subtitle', [ this.subtitle ]))
        ]),

        h('div', {
          staticClass: 'q-timeline__dot',
          class: this.colorClass
        }, dot),

        h('div', { staticClass: 'q-timeline__content' }, [
          h('h6', { staticClass: 'q-timeline__title' }, slot(this, 'title', [ this.title ]))
        ].concat(child))
      ];

      return h('li', {
        staticClass: 'q-timeline__entry',
        class: this.classes,
        on: { ...this.qListeners }
      }, this.reverse === true ? content.reverse() : content)
    }
  });

  var QToolbar = Vue.extend({
    name: 'QToolbar',

    mixins: [ ListenersMixin ],

    props: {
      inset: Boolean
    },

    render (h) {
      return h('div', {
        staticClass: 'q-toolbar row no-wrap items-center',
        class: this.inset ? 'q-toolbar--inset' : null,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  var QToolbarTitle = Vue.extend({
    name: 'QToolbarTitle',

    mixins: [ ListenersMixin ],

    props: {
      shrink: Boolean
    },

    computed: {
      classes () {
        return 'q-toolbar__title ellipsis' +
          (this.shrink === true ? ' col-shrink' : '')
      }
    },

    render (h) {
      return h('div', {
        class: this.classes,
        on: { ...this.qListeners }
      }, slot(this, 'default'))
    }
  });

  const tickStrategyOptions = [ 'none', 'strict', 'leaf', 'leaf-filtered' ];

  var QTree = Vue.extend({
    name: 'QTree',

    mixins: [ DarkMixin ],

    props: {
      nodes: {
        type: Array,
        required: true
      },
      nodeKey: {
        type: String,
        required: true
      },
      labelKey: {
        type: String,
        default: 'label'
      },
      childrenKey: {
        type: String,
        default: 'children'
      },

      dense: Boolean,

      color: String,
      controlColor: String,
      textColor: String,
      selectedColor: String,

      icon: String,

      tickStrategy: {
        type: String,
        default: 'none',
        validator: v => tickStrategyOptions.includes(v)
      },
      ticked: Array, // sync
      expanded: Array, // sync
      selected: {}, // sync

      noSelectionUnset: Boolean,

      defaultExpandAll: Boolean,
      accordion: Boolean,

      filter: String,
      filterMethod: {
        type: Function,
        default (node, filter) {
          const filt = filter.toLowerCase();
          return node[this.labelKey] &&
            node[this.labelKey].toLowerCase().indexOf(filt) > -1
        }
      },

      duration: Number,
      noConnectors: Boolean,

      noNodesLabel: String,
      noResultsLabel: String
    },

    computed: {
      classes () {
        return `q-tree q-tree--${this.dense === true ? 'dense' : 'standard'}` +
          (this.noConnectors === true ? ' q-tree--no-connectors' : '') +
          (this.isDark === true ? ' q-tree--dark' : '') +
          (this.color !== void 0 ? ` text-${this.color}` : '')
      },

      hasSelection () {
        return this.selected !== void 0
      },

      computedIcon () {
        return this.icon || this.$q.iconSet.tree.icon
      },

      computedControlColor () {
        return this.controlColor || this.color
      },

      textColorClass () {
        if (this.textColor !== void 0) {
          return `text-${this.textColor}`
        }
      },

      selectedColorClass () {
        const color = this.selectedColor || this.color;
        if (color) {
          return `text-${color}`
        }
      },

      meta () {
        const meta = {};

        const travel = (node, parent) => {
          const tickStrategy = node.tickStrategy || (parent ? parent.tickStrategy : this.tickStrategy);
          const
            key = node[this.nodeKey],
            isParent = node[this.childrenKey] && node[this.childrenKey].length > 0,
            isLeaf = isParent !== true,
            selectable = node.disabled !== true && this.hasSelection === true && node.selectable !== false,
            expandable = node.disabled !== true && node.expandable !== false,
            hasTicking = tickStrategy !== 'none',
            strictTicking = tickStrategy === 'strict',
            leafFilteredTicking = tickStrategy === 'leaf-filtered',
            leafTicking = tickStrategy === 'leaf' || tickStrategy === 'leaf-filtered';

          let tickable = node.disabled !== true && node.tickable !== false;
          if (leafTicking === true && tickable === true && parent && parent.tickable !== true) {
            tickable = false;
          }

          let lazy = node.lazy;
          if (
            lazy === true &&
            this.lazy[key] !== void 0 &&
            Array.isArray(node[this.childrenKey]) === true
          ) {
            lazy = this.lazy[key];
          }

          const m = {
            key,
            parent,
            isParent,
            isLeaf,
            lazy,
            disabled: node.disabled,
            link: node.disabled !== true && (selectable === true || (expandable === true && (isParent === true || lazy === true))),
            children: [],
            matchesFilter: this.filter ? this.filterMethod(node, this.filter) : true,

            selected: key === this.selected && selectable === true,
            selectable,
            expanded: isParent === true ? this.innerExpanded.includes(key) : false,
            expandable,
            noTick: node.noTick === true || (strictTicking !== true && lazy && lazy !== 'loaded'),
            tickable,
            tickStrategy,
            hasTicking,
            strictTicking,
            leafFilteredTicking,
            leafTicking,
            ticked: strictTicking === true
              ? this.innerTicked.includes(key)
              : (isLeaf === true ? this.innerTicked.includes(key) : false)
          };

          meta[key] = m;

          if (isParent === true) {
            m.children = node[this.childrenKey].map(n => travel(n, m));

            if (this.filter) {
              if (m.matchesFilter !== true) {
                m.matchesFilter = m.children.some(n => n.matchesFilter);
              }
              else if (
                m.noTick !== true &&
                m.disabled !== true &&
                m.tickable === true &&
                leafFilteredTicking === true &&
                m.children.every(n => n.matchesFilter !== true || n.noTick === true || n.tickable !== true) === true
              ) {
                m.tickable = false;
              }
            }

            if (m.matchesFilter === true) {
              if (m.noTick !== true && strictTicking !== true && m.children.every(n => n.noTick) === true) {
                m.noTick = true;
              }

              if (leafTicking) {
                m.ticked = false;
                m.indeterminate = m.children.some(node => node.indeterminate === true);
                m.tickable = m.tickable === true && m.children.some(node => node.tickable);

                if (m.indeterminate !== true) {
                  const sel = m.children
                    .reduce((acc, meta) => meta.ticked === true ? acc + 1 : acc, 0);

                  if (sel === m.children.length) {
                    m.ticked = true;
                  }
                  else if (sel > 0) {
                    m.indeterminate = true;
                  }
                }

                if (m.indeterminate === true) {
                  m.indeterminateNextState = m.children
                    .every(meta => meta.tickable !== true || meta.ticked !== true);
                }
              }
            }
          }

          return m
        };

        this.nodes.forEach(node => travel(node, null));
        return meta
      }
    },

    data () {
      return {
        lazy: {},
        innerTicked: this.ticked || [],
        innerExpanded: this.expanded || []
      }
    },

    watch: {
      ticked (val) {
        this.innerTicked = val;
      },

      expanded (val) {
        this.innerExpanded = val;
      }
    },

    methods: {
      getNodeByKey (key) {
        const reduce = [].reduce;

        const find = (result, node) => {
          if (result || !node) {
            return result
          }
          if (Array.isArray(node) === true) {
            return reduce.call(Object(node), find, result)
          }
          if (node[this.nodeKey] === key) {
            return node
          }
          if (node[this.childrenKey]) {
            return find(null, node[this.childrenKey])
          }
        };

        return find(null, this.nodes)
      },

      getTickedNodes () {
        return this.innerTicked.map(key => this.getNodeByKey(key))
      },

      getExpandedNodes () {
        return this.innerExpanded.map(key => this.getNodeByKey(key))
      },

      isExpanded (key) {
        return key && this.meta[key]
          ? this.meta[key].expanded
          : false
      },

      collapseAll () {
        if (this.expanded !== void 0) {
          this.$emit('update:expanded', []);
        }
        else {
          this.innerExpanded = [];
        }
      },

      expandAll () {
        const
          expanded = this.innerExpanded,
          travel = node => {
            if (node[this.childrenKey] && node[this.childrenKey].length > 0) {
              if (node.expandable !== false && node.disabled !== true) {
                expanded.push(node[this.nodeKey]);
                node[this.childrenKey].forEach(travel);
              }
            }
          };

        this.nodes.forEach(travel);

        if (this.expanded !== void 0) {
          this.$emit('update:expanded', expanded);
        }
        else {
          this.innerExpanded = expanded;
        }
      },

      setExpanded (key, state, node = this.getNodeByKey(key), meta = this.meta[key]) {
        if (meta.lazy && meta.lazy !== 'loaded') {
          if (meta.lazy === 'loading') {
            return
          }

          this.$set(this.lazy, key, 'loading');
          if (Array.isArray(node[this.childrenKey]) !== true) {
            this.$set(node, this.childrenKey, []);
          }
          this.$emit('lazy-load', {
            node,
            key,
            done: children => {
              this.lazy[key] = 'loaded';
              this.$set(node, this.childrenKey, Array.isArray(children) === true ? children : []);
              this.$nextTick(() => {
                const m = this.meta[key];
                if (m && m.isParent === true) {
                  this.__setExpanded(key, true);
                }
              });
            },
            fail: () => {
              this.$delete(this.lazy, key);
              if (node[this.childrenKey].length === 0) {
                this.$delete(node, this.childrenKey);
              }
            }
          });
        }
        else if (meta.isParent === true && meta.expandable === true) {
          this.__setExpanded(key, state);
        }
      },

      __setExpanded (key, state) {
        let target = this.innerExpanded;
        const emit = this.expanded !== void 0;

        if (emit === true) {
          target = target.slice();
        }

        if (state) {
          if (this.accordion) {
            if (this.meta[key]) {
              const collapse = [];
              if (this.meta[key].parent) {
                this.meta[key].parent.children.forEach(m => {
                  if (m.key !== key && m.expandable === true) {
                    collapse.push(m.key);
                  }
                });
              }
              else {
                this.nodes.forEach(node => {
                  const k = node[this.nodeKey];
                  if (k !== key) {
                    collapse.push(k);
                  }
                });
              }
              if (collapse.length > 0) {
                target = target.filter(k => collapse.includes(k) === false);
              }
            }
          }

          target = target.concat([ key ])
            .filter((key, index, self) => self.indexOf(key) === index);
        }
        else {
          target = target.filter(k => k !== key);
        }

        if (emit === true) {
          this.$emit('update:expanded', target);
        }
        else {
          this.innerExpanded = target;
        }
      },

      isTicked (key) {
        return key && this.meta[key]
          ? this.meta[key].ticked
          : false
      },

      setTicked (keys, state) {
        let target = this.innerTicked;
        const emit = this.ticked !== void 0;

        if (emit === true) {
          target = target.slice();
        }

        if (state) {
          target = target.concat(keys)
            .filter((key, index, self) => self.indexOf(key) === index);
        }
        else {
          target = target.filter(k => keys.includes(k) === false);
        }

        if (emit === true) {
          this.$emit('update:ticked', target);
        }
      },

      __getSlotScope (node, meta, key) {
        const scope = { tree: this, node, key, color: this.color, dark: this.isDark };

        Object.defineProperty(scope, 'expanded', {
          get: () => { return meta.expanded },
          set: val => { val !== meta.expanded && this.setExpanded(key, val); },
          configurable: true,
          enumerable: true
        });
        Object.defineProperty(scope, 'ticked', {
          get: () => { return meta.ticked },
          set: val => { val !== meta.ticked && this.setTicked([ key ], val); },
          configurable: true,
          enumerable: true
        });

        return scope
      },

      __getChildren (h, nodes) {
        return (
          this.filter
            ? nodes.filter(n => this.meta[n[this.nodeKey]].matchesFilter)
            : nodes
        ).map(child => this.__getNode(h, child))
      },

      __getNodeMedia (h, node) {
        if (node.icon !== void 0) {
          return h(QIcon, {
            staticClass: 'q-tree__icon q-mr-sm',
            props: { name: node.icon, color: node.iconColor }
          })
        }
        const src = node.img || node.avatar;
        if (src) {
          return h('img', {
            staticClass: `q-tree__${node.img ? 'img' : 'avatar'} q-mr-sm`,
            attrs: { src }
          })
        }
      },

      __getNode (h, node) {
        const
          key = node[this.nodeKey],
          meta = this.meta[key],
          header = node.header
            ? this.$scopedSlots[`header-${node.header}`] || this.$scopedSlots['default-header']
            : this.$scopedSlots['default-header'];

        const children = meta.isParent === true
          ? this.__getChildren(h, node[this.childrenKey])
          : [];

        const isParent = children.length > 0 || (meta.lazy && meta.lazy !== 'loaded');

        let body = node.body
          ? this.$scopedSlots[`body-${node.body}`] || this.$scopedSlots['default-body']
          : this.$scopedSlots['default-body'];
        const slotScope = header !== void 0 || body !== void 0
          ? this.__getSlotScope(node, meta, key)
          : null;

        if (body !== void 0) {
          body = h('div', { staticClass: 'q-tree__node-body relative-position' }, [
            h('div', { class: this.textColorClass }, [
              body(slotScope)
            ])
          ]);
        }

        return h('div', {
          key,
          staticClass: 'q-tree__node relative-position',
          class: { 'q-tree__node--parent': isParent, 'q-tree__node--child': !isParent }
        }, [
          h('div', {
            staticClass: 'q-tree__node-header relative-position row no-wrap items-center',
            class: {
              'q-tree__node--link q-hoverable q-focusable': meta.link,
              'q-tree__node--selected': meta.selected,
              'q-tree__node--disabled': meta.disabled
            },
            attrs: { tabindex: meta.link ? 0 : -1 },
            on: {
              click: (e) => {
                this.__onClick(node, meta, e);
              },
              keypress: e => {
                if (shouldIgnoreKey(e) !== true) {
                  if (e.keyCode === 13) { this.__onClick(node, meta, e, true); }
                  else if (e.keyCode === 32) { this.__onExpandClick(node, meta, e, true); }
                }
              }
            }
          }, [
            h('div', { staticClass: 'q-focus-helper', attrs: { tabindex: -1 }, ref: `blurTarget_${meta.key}` }),

            meta.lazy === 'loading'
              ? h(QSpinner, {
                staticClass: 'q-tree__spinner',
                props: { color: this.computedControlColor }
              })
              : (
                isParent === true
                  ? h(QIcon, {
                    staticClass: 'q-tree__arrow',
                    class: { 'q-tree__arrow--rotate': meta.expanded },
                    props: { name: this.computedIcon },
                    on: {
                      click: e => {
                        this.__onExpandClick(node, meta, e);
                      }
                    }
                  })
                  : null
              ),

            meta.hasTicking === true && meta.noTick !== true
              ? h(QCheckbox, {
                staticClass: 'q-tree__tickbox',
                props: {
                  value: meta.indeterminate === true ? null : meta.ticked,
                  color: this.computedControlColor,
                  dark: this.isDark,
                  dense: true,
                  keepColor: true,
                  disable: meta.tickable !== true
                },
                on: {
                  keydown: stopAndPrevent,
                  input: v => {
                    this.__onTickedClick(meta, v);
                  }
                }
              })
              : null,

            h('div', {
              'staticClass': 'q-tree__node-header-content col row no-wrap items-center',
              class: meta.selected ? this.selectedColorClass : this.textColorClass
            }, [
              header
                ? header(slotScope)
                : [
                  this.__getNodeMedia(h, node),
                  h('div', node[this.labelKey])
                ]
            ])
          ]),

          isParent === true
            ? h(QSlideTransition, {
              props: { duration: this.duration },
              on: cache(this, 'slide', {
                show: () => { this.$emit('after-show'); },
                hide: () => { this.$emit('after-hide'); }
              })
            }, [
              h('div', {
                staticClass: 'q-tree__node-collapsible',
                class: this.textColorClass,
                directives: [{ name: 'show', value: meta.expanded }]
              }, [
                body,

                h('div', {
                  staticClass: 'q-tree__children',
                  class: { 'q-tree__node--disabled': meta.disabled }
                }, children)
              ])
            ])
            : body
        ])
      },

      __blur (key) {
        const blurTarget = this.$refs[`blurTarget_${key}`];
        blurTarget !== void 0 && blurTarget.focus();
      },

      __onClick (node, meta, e, keyboard) {
        keyboard !== true && this.__blur(meta.key);

        if (this.hasSelection && meta.selectable) {
          if (this.noSelectionUnset === false) {
            this.$emit('update:selected', meta.key !== this.selected ? meta.key : null);
          }
          else if (meta.key !== this.selected) {
            this.$emit('update:selected', meta.key || null);
          }
        }
        else {
          this.__onExpandClick(node, meta, e, keyboard);
        }

        if (typeof node.handler === 'function') {
          node.handler(node);
        }
      },

      __onExpandClick (node, meta, e, keyboard) {
        if (e !== void 0) {
          stopAndPrevent(e);
        }
        keyboard !== true && this.__blur(meta.key);
        this.setExpanded(meta.key, !meta.expanded, node, meta);
      },

      __onTickedClick (meta, state) {
        if (meta.indeterminate === true) {
          state = meta.indeterminateNextState;
        }
        if (meta.strictTicking) {
          this.setTicked([ meta.key ], state);
        }
        else if (meta.leafTicking) {
          const keys = [];
          const travel = meta => {
            if (meta.isParent) {
              if (state !== true && meta.noTick !== true && meta.tickable === true) {
                keys.push(meta.key);
              }
              if (meta.leafTicking === true) {
                meta.children.forEach(travel);
              }
            }
            else if (
              meta.noTick !== true &&
              meta.tickable === true &&
              (meta.leafFilteredTicking !== true || meta.matchesFilter === true)
            ) {
              keys.push(meta.key);
            }
          };
          travel(meta);
          this.setTicked(keys, state);
        }
      }
    },

    render (h) {
      const children = this.__getChildren(h, this.nodes);

      return h(
        'div', {
          class: this.classes
        },
        children.length === 0
          ? (
            this.filter
              ? this.noResultsLabel || this.$q.lang.tree.noResults
              : this.noNodesLabel || this.$q.lang.tree.noNodes
          )
          : children
      )
    },

    created () {
      this.defaultExpandAll === true && this.expandAll();
    }
  });

  var QUploaderBase = Vue.extend({
    name: 'QUploaderBase',

    mixins: [ DarkMixin, FileMixin ],

    props: {
      label: String,

      color: String,
      textColor: String,

      square: Boolean,
      flat: Boolean,
      bordered: Boolean,

      noThumbnails: Boolean,
      autoUpload: Boolean,
      hideUploadBtn: Boolean,

      disable: Boolean,
      readonly: Boolean
    },

    provide () {
      return {
        __qUploaderGetInput: this.__getInputControl
      }
    },

    data () {
      return {
        files: [],
        queuedFiles: [],
        uploadedFiles: [],
        dnd: false,
        expanded: false,

        uploadSize: 0,
        uploadedSize: 0
      }
    },

    watch: {
      isUploading (newVal, oldVal) {
        if (oldVal === false && newVal === true) {
          this.$emit('start');
        }
        else if (oldVal === true && newVal === false) {
          this.$emit('finish');
        }
      }
    },

    computed: {
      /*
       * When extending:
       *   Required : isUploading
       *   Optional: isBusy
       */

      canUpload () {
        return this.editable === true &&
          this.isBusy !== true &&
          this.isUploading !== true &&
          this.queuedFiles.length > 0
      },

      canAddFiles () {
        return (
          this.editable === true &&
          this.isUploading !== true &&
          // if single selection and no files are queued:
          (this.multiple === true || this.queuedFiles.length === 0) &&
          // if max-files is set and current number of files does not exceeds it:
          (this.maxFiles === void 0 || this.files.length < this.maxFilesNumber) &&
          // if max-total-size is set and current upload size does not exceeds it:
          (this.maxTotalSize === void 0 || this.uploadSize < this.maxTotalSizeNumber)
        )
      },

      uploadProgress () {
        return this.uploadSize === 0
          ? 0
          : this.uploadedSize / this.uploadSize
      },

      uploadProgressLabel () {
        return this.__getProgressLabel(this.uploadProgress)
      },

      uploadedSizeLabel () {
        return humanStorageSize(this.uploadedSize)
      },

      uploadSizeLabel () {
        return humanStorageSize(this.uploadSize)
      },

      colorClass () {
        const cls = [];
        this.color !== void 0 && cls.push(`bg-${this.color}`);
        this.textColor !== void 0 && cls.push(`text-${this.textColor}`);
        return cls.join(' ')
      },

      editable () {
        return this.disable !== true && this.readonly !== true
      }
    },

    methods: {
      reset () {
        if (!this.disable) {
          this.abort();
          this.uploadedSize = 0;
          this.uploadSize = 0;
          this.__revokeImgURLs();
          this.files = [];
          this.queuedFiles = [];
          this.uploadedFiles = [];
        }
      },

      removeUploadedFiles () {
        this.__removeFiles([ 'uploaded' ], () => {
          this.uploadedFiles = [];
        });
      },

      removeQueuedFiles () {
        this.__removeFiles([ 'idle', 'failed' ], ({ size }) => {
          this.uploadSize -= size;
          this.queuedFiles = [];
        });
      },

      __removeFiles (statusList, cb) {
        if (this.disable === true) {
          return
        }

        const removed = {
          files: [],
          size: 0
        };

        const files = this.files.filter(f => {
          if (statusList.indexOf(f.__status) === -1) {
            return true
          }

          removed.size += f.size;
          removed.files.push(f);

          f.__img !== void 0 && window.URL.revokeObjectURL(f.__img.src);

          return false
        });

        if (removed.files.length > 0) {
          this.files = files;
          cb !== void 0 && cb(removed);
          this.$emit('removed', removed.files);
        }
      },

      removeFile (file) {
        if (this.disable) { return }

        if (file.__status === 'uploaded') {
          this.uploadedFiles = this.uploadedFiles.filter(f => f.__key !== file.__key);
        }
        else if (file.__status === 'uploading') {
          file.__abort();
        }
        else {
          this.uploadSize -= file.size;
        }

        this.files = this.files.filter(f => {
          if (f.__key !== file.__key) {
            return true
          }

          f.__img !== void 0 && window.URL.revokeObjectURL(f.__img.src);

          return false
        });
        this.queuedFiles = this.queuedFiles.filter(f => f.__key !== file.__key);
        this.$emit('removed', [ file ]);
      },

      __revokeImgURLs () {
        this.files.forEach(f => {
          f.__img !== void 0 && window.URL.revokeObjectURL(f.__img.src);
        });
      },

      __getFileInput () {
        return this.$refs.input ||
          this.$el.getElementsByClassName('q-uploader__input')[0]
      },

      __getProgressLabel (p) {
        return (p * 100).toFixed(2) + '%'
      },

      __updateFile (file, status, uploadedSize) {
        file.__status = status;

        if (status === 'idle') {
          file.__uploaded = 0;
          file.__progress = 0;
          file.__sizeLabel = humanStorageSize(file.size);
          file.__progressLabel = '0.00%';
          return
        }
        if (status === 'failed') {
          this.$forceUpdate();
          return
        }

        file.__uploaded = status === 'uploaded'
          ? file.size
          : uploadedSize;

        file.__progress = status === 'uploaded'
          ? 1
          : Math.min(0.9999, file.__uploaded / file.size);

        file.__progressLabel = this.__getProgressLabel(file.__progress);
        this.$forceUpdate();
      },

      __addFiles (e, fileList) {
        const localFiles = this.__processFiles(e, fileList, this.files, true);
        const fileInput = this.__getFileInput();

        if (fileInput !== void 0) {
          fileInput.value = '';
        }

        if (localFiles === void 0) { return }

        localFiles.forEach(file => {
          this.__updateFile(file, 'idle');
          this.uploadSize += file.size;

          if (this.noThumbnails !== true && file.type.toUpperCase().startsWith('IMAGE')) {
            const img = new Image();
            img.src = window.URL.createObjectURL(file);
            file.__img = img;
          }
        });

        this.files = this.files.concat(localFiles);
        this.queuedFiles = this.queuedFiles.concat(localFiles);
        this.$emit('added', localFiles);
        this.autoUpload === true && this.upload();
      },

      __getBtn (h, show, icon, fn) {
        if (show === true) {
          return h(QBtn, {
            props: {
              type: 'a',
              icon: this.$q.iconSet.uploader[icon],
              flat: true,
              dense: true
            },
            on: { click: icon === 'add' ? this.pickFiles : fn }
          }, icon === 'add' ? this.__getInputControl(h) : null)
        }
      },

      __getInputControl (h) {
        return [
          h('input', {
            ref: 'input',
            staticClass: 'q-uploader__input overflow-hidden absolute-full',
            attrs: {
              tabindex: -1,
              type: 'file',
              title: '', // try to remove default tooltip
              accept: this.accept,
              capture: this.capture,
              ...(this.multiple === true ? { multiple: true } : {})
            },
            on: cache(this, 'input', {
              mousedown: stop, // need to stop refocus from QBtn
              click: this.pickFiles,
              change: this.__addFiles
            })
          })
        ]
      },

      __getHeader (h) {
        if (this.$scopedSlots.header !== void 0) {
          return this.$scopedSlots.header(this)
        }

        return [
          h('div', {
            staticClass: 'q-uploader__header-content column'
          }, [
            h('div', {
              staticClass: 'flex flex-center no-wrap q-gutter-xs'
            }, [
              this.__getBtn(h, this.queuedFiles.length > 0, 'removeQueue', this.removeQueuedFiles),
              this.__getBtn(h, this.uploadedFiles.length > 0, 'removeUploaded', this.removeUploadedFiles),

              this.isUploading === true
                ? h(QSpinner, { staticClass: 'q-uploader__spinner' })
                : null,

              h('div', { staticClass: 'col column justify-center' }, [
                this.label !== void 0
                  ? h('div', { staticClass: 'q-uploader__title' }, [ this.label ])
                  : null,

                h('div', { staticClass: 'q-uploader__subtitle' }, [
                  this.uploadSizeLabel + ' / ' + this.uploadProgressLabel
                ])
              ]),

              this.__getBtn(h, this.canAddFiles, 'add', this.pickFiles),
              this.__getBtn(h, this.hideUploadBtn === false && this.canUpload === true, 'upload', this.upload),
              this.__getBtn(h, this.isUploading, 'clear', this.abort)
            ])
          ])
        ]
      },

      __getList (h) {
        if (this.$scopedSlots.list !== void 0) {
          return this.$scopedSlots.list(this)
        }

        return this.files.map(file => h('div', {
          key: file.__key,
          staticClass: 'q-uploader__file relative-position',
          class: {
            'q-uploader__file--img': this.noThumbnails !== true && file.__img !== void 0,
            'q-uploader__file--failed': file.__status === 'failed',
            'q-uploader__file--uploaded': file.__status === 'uploaded'
          },
          style: this.noThumbnails !== true && file.__img !== void 0 ? {
            backgroundImage: 'url("' + file.__img.src + '")'
          } : null
        }, [
          h('div', {
            staticClass: 'q-uploader__file-header row flex-center no-wrap'
          }, [
            file.__status === 'failed'
              ? h(QIcon, {
                staticClass: 'q-uploader__file-status',
                props: {
                  name: this.$q.iconSet.type.negative,
                  color: 'negative'
                }
              })
              : null,

            h('div', { staticClass: 'q-uploader__file-header-content col' }, [
              h('div', { staticClass: 'q-uploader__title' }, [ file.name ]),
              h('div', {
                staticClass: 'q-uploader__subtitle row items-center no-wrap'
              }, [
                file.__sizeLabel + ' / ' + file.__progressLabel
              ])
            ]),

            file.__status === 'uploading'
              ? h(QCircularProgress, {
                props: {
                  value: file.__progress,
                  min: 0,
                  max: 1,
                  indeterminate: file.__progress === 0
                }
              })
              : h(QBtn, {
                props: {
                  round: true,
                  dense: true,
                  flat: true,
                  icon: this.$q.iconSet.uploader[file.__status === 'uploaded' ? 'done' : 'clear']
                },
                on: {
                  click: () => { this.removeFile(file); }
                }
              })
          ])
        ]))
      }
    },

    beforeDestroy () {
      this.isUploading === true && this.abort();
      this.files.length > 0 && this.__revokeImgURLs();
    },

    render (h) {
      const children = [
        h('div', {
          staticClass: 'q-uploader__header',
          class: this.colorClass
        }, this.__getHeader(h)),

        h('div', {
          staticClass: 'q-uploader__list scroll'
        }, this.__getList(h)),

        this.__getDnd(h, 'uploader')
      ];

      this.isBusy === true && children.push(
        h('div', {
          staticClass: 'q-uploader__overlay absolute-full flex flex-center'
        }, [ h(QSpinner) ])
      );

      return h('div', {
        staticClass: 'q-uploader column no-wrap',
        class: {
          'q-uploader--dark q-dark': this.isDark,
          'q-uploader--bordered': this.bordered,
          'q-uploader--square no-border-radius': this.square,
          'q-uploader--flat no-shadow': this.flat,
          'disabled q-uploader--disable': this.disable,
          'q-uploader--dnd': this.dnd
        },
        on: this.canAddFiles === true
          ? cache(this, 'drag', {
            dragover: this.__onDragOver,
            dragleave: this.__onDragLeave
          })
          : null
      }, children)
    }
  });

  function getFn (prop) {
    return typeof prop === 'function'
      ? prop
      : () => prop
  }

  var UploaderXHRMixin = {
    props: {
      url: [ Function, String ],
      method: {
        type: [ Function, String ],
        default: 'POST'
      },
      fieldName: {
        type: [ Function, String ],
        default: file => file.name
      },
      headers: [ Function, Array ],
      formFields: [ Function, Array ],
      withCredentials: [ Function, Boolean ],
      sendRaw: [ Function, Boolean ],

      batch: [ Function, Boolean ],
      factory: Function
    },

    data () {
      return {
        xhrs: [],
        promises: [],
        workingThreads: 0
      }
    },

    computed: {
      xhrProps () {
        return {
          url: getFn(this.url),
          method: getFn(this.method),
          headers: getFn(this.headers),
          formFields: getFn(this.formFields),
          fieldName: getFn(this.fieldName),
          withCredentials: getFn(this.withCredentials),
          sendRaw: getFn(this.sendRaw),
          batch: getFn(this.batch)
        }
      },

      isUploading () {
        return this.workingThreads > 0
      },

      isBusy () {
        return this.promises.length > 0
      }
    },

    methods: {
      abort () {
        this.xhrs.forEach(x => { x.abort(); });

        if (this.promises.length > 0) {
          this.abortPromises = true;
        }
      },

      upload () {
        if (this.canUpload === false) {
          return
        }

        const queue = this.queuedFiles.slice(0);
        this.queuedFiles = [];

        if (this.xhrProps.batch(queue)) {
          this.__runFactory(queue);
        }
        else {
          queue.forEach(file => {
            this.__runFactory([ file ]);
          });
        }
      },

      __runFactory (files) {
        this.workingThreads++;

        if (typeof this.factory !== 'function') {
          this.__uploadFiles(files, {});
          return
        }

        const res = this.factory(files);

        if (!res) {
          this.$emit(
            'factory-failed',
            new Error('QUploader: factory() does not return properly'),
            files
          );
          this.workingThreads--;
        }
        else if (typeof res.catch === 'function' && typeof res.then === 'function') {
          this.promises.push(res);

          const failed = err => {
            if (this._isBeingDestroyed !== true && this._isDestroyed !== true) {
              this.promises = this.promises.filter(p => p !== res);

              if (this.promises.length === 0) {
                this.abortPromises = false;
              }

              this.queuedFiles = this.queuedFiles.concat(files);
              files.forEach(f => { this.__updateFile(f, 'failed'); });

              this.$emit('factory-failed', err, files);
              this.workingThreads--;
            }
          };

          res.then(factory => {
            if (this.abortPromises === true) {
              failed(new Error('Aborted'));
            }
            else if (this._isBeingDestroyed !== true && this._isDestroyed !== true) {
              this.promises = this.promises.filter(p => p !== res);
              this.__uploadFiles(files, factory);
            }
          }).catch(failed);
        }
        else {
          this.__uploadFiles(files, res || {});
        }
      },

      __uploadFiles (files, factory) {
        const
          form = new FormData(),
          xhr = new XMLHttpRequest();

        const getProp = (name, arg) => {
          return factory[name] !== void 0
            ? getFn(factory[name])(arg)
            : this.xhrProps[name](arg)
        };

        const url = getProp('url', files);

        if (!url) {
          console.error('q-uploader: invalid or no URL specified');
          this.workingThreads--;
          return
        }

        const fields = getProp('formFields', files);
        fields !== void 0 && fields.forEach(field => {
          form.append(field.name, field.value);
        });

        let
          uploadIndex = 0,
          uploadIndexSize = 0,
          uploadedSize = 0,
          maxUploadSize = 0,
          aborted;

        xhr.upload.addEventListener('progress', e => {
          if (aborted === true) { return }

          const loaded = Math.min(maxUploadSize, e.loaded);

          this.uploadedSize += loaded - uploadedSize;
          uploadedSize = loaded;

          let size = uploadedSize - uploadIndexSize;
          for (let i = uploadIndex; size > 0 && i < files.length; i++) {
            const
              file = files[i],
              uploaded = size > file.size;

            if (uploaded) {
              size -= file.size;
              uploadIndex++;
              uploadIndexSize += file.size;
              this.__updateFile(file, 'uploading', file.size);
            }
            else {
              this.__updateFile(file, 'uploading', size);
              return
            }
          }
        }, false);

        xhr.onreadystatechange = () => {
          if (xhr.readyState < 4) {
            return
          }

          if (xhr.status && xhr.status < 400) {
            this.uploadedFiles = this.uploadedFiles.concat(files);
            files.forEach(f => { this.__updateFile(f, 'uploaded'); });
            this.$emit('uploaded', { files, xhr });
          }
          else {
            aborted = true;
            this.uploadedSize -= uploadedSize;
            this.queuedFiles = this.queuedFiles.concat(files);
            files.forEach(f => { this.__updateFile(f, 'failed'); });
            this.$emit('failed', { files, xhr });
          }

          this.workingThreads--;
          this.xhrs = this.xhrs.filter(x => x !== xhr);
        };

        xhr.open(
          getProp('method', files),
          url
        );

        if (getProp('withCredentials', files) === true) {
          xhr.withCredentials = true;
        }

        const headers = getProp('headers', files);
        headers !== void 0 && headers.forEach(head => {
          xhr.setRequestHeader(head.name, head.value);
        });

        const sendRaw = getProp('sendRaw', files);

        files.forEach(file => {
          this.__updateFile(file, 'uploading', 0);
          if (sendRaw !== true) {
            form.append(getProp('fieldName', file), file, file.name);
          }
          file.xhr = xhr;
          file.__abort = () => { xhr.abort(); };
          maxUploadSize += file.size;
        });

        this.$emit('uploading', { files, xhr });
        this.xhrs.push(xhr);

        if (sendRaw === true) {
          xhr.send(new Blob(files));
        }
        else {
          xhr.send(form);
        }
      }
    }
  };

  var QUploader = Vue.extend({
    name: 'QUploader',
    mixins: [ QUploaderBase, UploaderXHRMixin ]
  });

  var QUploaderAddTrigger = Vue.extend({
    name: 'QUploaderAddTrigger',

    inject: {
      __qUploaderGetInput: {
        default () {
          console.error('QUploaderAddTrigger needs to be child of QUploader');
        }
      }
    },

    render (h) {
      return this.__qUploaderGetInput(h)
    }
  });

  var QVideo = Vue.extend({
    name: 'QVideo',

    mixins: [ RatioMixin, ListenersMixin ],

    props: {
      src: {
        type: String,
        required: true
      },

      title: String,

      fetchpriority: {
        type: String,
        default: 'auto'
      },
      loading: {
        type: String,
        default: 'eager'
      },
      referrerpolicy: {
        type: String,
        default: 'strict-origin-when-cross-origin'
      }
    },

    computed: {
      iframeData () {
        return {
          attrs: {
            src: this.src,
            frameborder: '0',
            title: this.title,
            allowfullscreen: true,
            fetchpriority: this.fetchpriority,
            loading: this.loading,
            referrerpolicy: this.referrerpolicy
          }
        }
      },

      classes () {
        return 'q-video' +
          (this.ratio !== void 0 ? ' q-video--responsive' : '')
      }
    },

    render (h) {
      return h('div', {
        class: this.classes,
        style: this.ratioStyle,
        on: { ...this.qListeners }
      }, [
        h('iframe', this.iframeData)
      ])
    }
  });



  var components$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    QAjaxBar: QAjaxBar,
    QAvatar: QAvatar,
    QBadge: QBadge,
    QBanner: QBanner,
    QBar: QBar,
    QBreadcrumbs: QBreadcrumbs,
    QBreadcrumbsEl: QBreadcrumbsEl,
    QBtn: QBtn,
    QBtnDropdown: QBtnDropdown,
    QBtnGroup: QBtnGroup,
    QBtnToggle: QBtnToggle,
    QCard: QCard,
    QCardSection: QCardSection,
    QCardActions: QCardActions,
    QCarousel: QCarousel,
    QCarouselSlide: QCarouselSlide,
    QCarouselControl: QCarouselControl,
    QChatMessage: QChatMessage,
    QCheckbox: QCheckbox,
    QChip: QChip,
    QCircularProgress: QCircularProgress,
    QColor: QColor,
    QDate: QDate,
    QDialog: QDialog,
    QDrawer: QDrawer,
    QEditor: QEditor,
    QExpansionItem: QExpansionItem,
    QFab: QFab,
    QFabAction: QFabAction,
    QField: QField,
    QFile: QFile,
    QFooter: QFooter,
    QForm: QForm,
    QHeader: QHeader,
    QIcon: QIcon,
    QImg: QImg,
    QInfiniteScroll: QInfiniteScroll,
    QInnerLoading: QInnerLoading,
    QInput: QInput,
    QIntersection: QIntersection,
    QList: QList,
    QItem: QItem,
    QItemSection: QItemSection,
    QItemLabel: QItemLabel,
    QKnob: QKnob,
    QLayout: QLayout,
    QMarkupTable: QMarkupTable,
    QMenu: QMenu,
    QNoSsr: QNoSsr,
    QOptionGroup: QOptionGroup,
    QPage: QPage,
    QPageContainer: QPageContainer,
    QPageScroller: QPageScroller,
    QPageSticky: QPageSticky,
    QPagination: QPagination,
    QParallax: QParallax,
    QPopupEdit: QPopupEdit,
    QPopupProxy: QPopupProxy,
    QLinearProgress: QLinearProgress,
    QPullToRefresh: QPullToRefresh,
    QRadio: QRadio,
    QRange: QRange,
    QRating: QRating,
    QResizeObserver: QResizeObserver,
    QResponsive: QResponsive,
    QScrollArea: QScrollArea,
    QScrollObserver: QScrollObserver,
    QSelect: QSelect,
    QSeparator: QSeparator,
    QSkeleton: QSkeleton,
    QSlideItem: QSlideItem,
    QSlideTransition: QSlideTransition,
    QSlider: QSlider,
    QSpace: QSpace,
    QSpinner: QSpinner,
    QSpinnerAudio: QSpinnerAudio,
    QSpinnerBall: QSpinnerBall,
    QSpinnerBars: QSpinnerBars,
    QSpinnerBox: QSpinnerBox,
    QSpinnerClock: QSpinnerClock,
    QSpinnerComment: QSpinnerComment,
    QSpinnerCube: QSpinnerCube,
    QSpinnerDots: QSpinnerDots,
    QSpinnerFacebook: QSpinnerFacebook,
    QSpinnerGears: QSpinnerGears,
    QSpinnerGrid: QSpinnerGrid,
    QSpinnerHearts: QSpinnerHearts,
    QSpinnerHourglass: QSpinnerHourglass,
    QSpinnerInfinity: QSpinnerInfinity,
    QSpinnerIos: QSpinnerIos,
    QSpinnerOrbit: QSpinnerOrbit,
    QSpinnerOval: QSpinnerOval,
    QSpinnerPie: QSpinnerPie,
    QSpinnerPuff: QSpinnerPuff,
    QSpinnerRadio: QSpinnerRadio,
    QSpinnerRings: QSpinnerRings,
    QSpinnerTail: QSpinnerTail,
    QSplitter: QSplitter,
    QStep: QStep,
    QStepper: QStepper,
    QStepperNavigation: QStepperNavigation,
    QTabPanels: QTabPanels,
    QTabPanel: QTabPanel,
    QTable: QTable,
    QTh: QTh,
    QTr: QTr,
    QTd: QTd,
    QTabs: QTabs,
    QTab: QTab,
    QRouteTab: QRouteTab,
    QTime: QTime,
    QTimeline: QTimeline,
    QTimelineEntry: QTimelineEntry,
    QToggle: QToggle,
    QToolbar: QToolbar,
    QToolbarTitle: QToolbarTitle,
    QTooltip: QTooltip,
    QTree: QTree,
    QUploader: QUploader,
    QUploaderBase: QUploaderBase,
    QUploaderAddTrigger: QUploaderAddTrigger,
    QVideo: QVideo,
    QVirtualScroll: QVirtualScroll
  });

  /*
   * depth
   *   < 0  --> close all chain
   *   0    --> disabled
   *   > 0  --> close chain up to N parent
   */

  function getDepth (value) {
    if (value === false) {
      return 0
    }
    if (value === true || value === void 0) {
      return 1
    }

    const depth = parseInt(value, 10);
    return isNaN(depth) ? 0 : depth
  }

  function destroy$4 (el) {
    const ctx = el.__qclosepopup;
    if (ctx !== void 0) {
      el.removeEventListener('click', ctx.handler);
      el.removeEventListener('keyup', ctx.handlerKey);
      delete el.__qclosepopup;
    }
  }

  var ClosePopup = {
    name: 'close-popup',

    bind (el, { value }, vnode) {
      if (el.__qclosepopup !== void 0) {
        destroy$4(el);
        el.__qclosepopup_destroyed = true;
      }

      const ctx = {
        depth: getDepth(value),

        handler (evt) {
          // allow @click to be emitted
          ctx.depth !== 0 && setTimeout(() => {
            closePortals(vnode.componentInstance || vnode.context, evt, ctx.depth);
          });
        },

        handlerKey (evt) {
          isKeyCode(evt, 13) === true && ctx.handler(evt);
        }
      };

      el.__qclosepopup = ctx;

      el.addEventListener('click', ctx.handler);
      el.addEventListener('keyup', ctx.handlerKey);
    },

    update (el, { value, oldValue }) {
      if (el.__qclosepopup !== void 0 && value !== oldValue) {
        el.__qclosepopup.depth = getDepth(value);
      }
    },

    unbind (el) {
      if (el.__qclosepopup_destroyed === void 0) {
        destroy$4(el);
      }
      else {
        delete el.__qclosepopup_destroyed;
      }
    }
  };

  function destroy$5 (el) {
    const ctx = el.__qgoback;
    if (ctx !== void 0) {
      el.removeEventListener('click', ctx.goBack);
      el.removeEventListener('keyup', ctx.goBackKey);
      delete el.__qgoback;
    }
  }

  var GoBack = {
    name: 'go-back',

    bind (el, { value, modifiers }, vnode) {
      if (el.__qgoback !== void 0) {
        destroy$5(el);
        el.__qgoback_destroyed = true;
      }

      const ctx = {
        value,

        position: window.history.length - 1,
        single: modifiers.single,

        goBack () {
          const router = vnode.context.$router;

          if (ctx.single === true) {
            router.go(-1);
          }
          else if (client.is.nativeMobile === true) {
            router.go(ctx.position - window.history.length);
          }
          else {
            router.replace(ctx.value);
          }
        },

        goBackKey (e) {
          // if ENTER key
          isKeyCode(e, 13) === true && ctx.goBack();
        }
      };

      el.__qgoback = ctx;

      el.addEventListener('click', ctx.goBack);
      el.addEventListener('keyup', ctx.goBackKey);
    },

    update (el, { value, oldValue }) {
      const ctx = el.__qgoback;

      if (ctx !== void 0 && value !== oldValue) {
        ctx.value = value;
      }
    },

    unbind (el) {
      if (el.__qgoback_destroyed === void 0) {
        destroy$5(el);
      }
      else {
        delete el.__qgoback_destroyed;
      }
    }
  };

  let id = 0;
  let offsetBase = void 0;

  function getAbsolutePosition (el, resize) {
    if (offsetBase === void 0) {
      offsetBase = document.createElement('div');
      offsetBase.style.cssText = 'position: absolute; left: 0; top: 0';
      document.body.appendChild(offsetBase);
    }

    const boundingRect = el.getBoundingClientRect();
    const baseRect = offsetBase.getBoundingClientRect();
    const { marginLeft, marginRight, marginTop, marginBottom } = window.getComputedStyle(el);
    const marginH = parseInt(marginLeft, 10) + parseInt(marginRight, 10);
    const marginV = parseInt(marginTop, 10) + parseInt(marginBottom, 10);

    return {
      left: boundingRect.left - baseRect.left,
      top: boundingRect.top - baseRect.top,
      width: boundingRect.right - boundingRect.left,
      height: boundingRect.bottom - boundingRect.top,
      widthM: boundingRect.right - boundingRect.left + (resize === true ? 0 : marginH),
      heightM: boundingRect.bottom - boundingRect.top + (resize === true ? 0 : marginV),
      marginH: resize === true ? marginH : 0,
      marginV: resize === true ? marginV : 0
    }
  }

  function getAbsoluteSize (el) {
    return {
      width: el.scrollWidth,
      height: el.scrollHeight
    }
  }

  // firefox rulez
  const styleEdges = [ 'Top', 'Right', 'Bottom', 'Left' ];
  const styleBorderRadiuses = [ 'borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius' ];
  const reStyleSkipKey = /-block|-inline|block-|inline-/;
  const reStyleSkipRule = /(-block|-inline|block-|inline-).*:/;

  function getComputedStyle$1 (el, props) {
    const style = window.getComputedStyle(el);
    const fixed = {};
    for (let i = 0; i < props.length; i++) {
      const prop = props[i];

      if (style[prop] === '') {
        if (prop === 'cssText') {
          const styleLen = style.length;
          let val = '';

          for (let i = 0; i < styleLen; i++) {
            if (reStyleSkipKey.test(style[i]) !== true) {
              val += style[i] + ': ' + style[style[i]] + '; ';
            }
          }

          fixed[prop] = val;
        }
        else if ([ 'borderWidth', 'borderStyle', 'borderColor' ].indexOf(prop) > -1) {
          const suffix = prop.replace('border', '');
          let val = '';
          for (let j = 0; j < styleEdges.length; j++) {
            const subProp = 'border' + styleEdges[j] + suffix;
            val += style[subProp] + ' ';
          }
          fixed[prop] = val;
        }
        else if (prop === 'borderRadius') {
          let val1 = '';
          let val2 = '';
          for (let j = 0; j < styleBorderRadiuses.length; j++) {
            const val = style[styleBorderRadiuses[j]].split(' ');
            val1 += val[0] + ' ';
            val2 += (val[1] === void 0 ? val[0] : val[1]) + ' ';
          }
          fixed[prop] = val1 + '/ ' + val2;
        }
        else {
          fixed[prop] = style[prop];
        }
      }
      else {
        if (prop === 'cssText') {
          fixed[prop] = style[prop]
            .split(';')
            .filter(val => reStyleSkipRule.test(val) !== true)
            .join(';');
        }
        else {
          fixed[prop] = style[prop];
        }
      }
    }

    return fixed
  }

  const zIndexPositions = ['absolute', 'fixed', 'relative', 'sticky'];

  function getMaxZIndex (elStart) {
    let el = elStart;
    let maxIndex = 0;

    while (el !== null && el !== document) {
      const { position, zIndex } = window.getComputedStyle(el);
      const zIndexNum = Number(zIndex);

      if (
        zIndexNum > maxIndex &&
        (el === elStart || zIndexPositions.includes(position) === true)
      ) {
        maxIndex = zIndexNum;
      }

      el = el.parentNode;
    }

    return maxIndex
  }

  function normalizeElements (opts) {
    return {
      from: opts.from,
      to: opts.to !== void 0
        ? opts.to
        : opts.from
    }
  }

  function normalizeOptions (options) {
    if (typeof options === 'number') {
      options = {
        duration: options
      };
    }
    else if (typeof options === 'function') {
      options = {
        onEnd: options
      };
    }

    return {
      ...options,

      waitFor: options.waitFor === void 0 ? 0 : options.waitFor,

      duration: isNaN(options.duration) === true ? 300 : parseInt(options.duration, 10),
      easing: typeof options.easing === 'string' && options.easing.length > 0 ? options.easing : 'ease-in-out',
      delay: isNaN(options.delay) === true ? 0 : parseInt(options.delay, 10),
      fill: typeof options.fill === 'string' && options.fill.length > 0 ? options.fill : 'none',

      resize: options.resize === true,
      useCSS: options.useCSS === true,
      hideFromClone: options.hideFromClone === true,
      keepToClone: options.keepToClone === true,

      tween: options.tween === true,
      tweenFromOpacity: isNaN(options.tweenFromOpacity) === true ? 0.6 : parseFloat(options.tweenFromOpacity),
      tweenToOpacity: isNaN(options.tweenToOpacity) === true ? 0.5 : parseFloat(options.tweenToOpacity)
    }
  }

  function isValidElement (element) {
    return element &&
      element.ownerDocument === document &&
      element.parentNode !== null
  }

  function morph (_options) {
    let cancel = () => false;
    let cancelStatus = false;
    let endElementTo = true;

    const elements = normalizeElements(_options);
    const options = normalizeOptions(_options);

    const elFrom = getElement(elements.from);
    if (isValidElement(elFrom) !== true) {
      // we return a cancel function that return false, meaning the cancel function failed
      return cancel
    }
    // we clean other morphs running on this element
    typeof elFrom.qMorphCancel === 'function' && elFrom.qMorphCancel();

    let animationFromClone = void 0;
    let animationFromTween = void 0;
    let animationToClone = void 0;
    let animationTo = void 0;

    const elFromParent = elFrom.parentNode;
    const elFromNext = elFrom.nextElementSibling;

    // we get the dimensions and characteristics
    // of the parent of the initial element before changes
    const elFromPosition = getAbsolutePosition(elFrom, options.resize);
    const {
      width: elFromParentWidthBefore,
      height: elFromParentHeightBefore
    } = getAbsoluteSize(elFromParent);
    const {
      borderWidth: elFromBorderWidth,
      borderStyle: elFromBorderStyle,
      borderColor: elFromBorderColor,
      borderRadius: elFromBorderRadius,
      backgroundColor: elFromBackground,
      transform: elFromTransform,
      position: elFromPositioningType,
      cssText: elFromCssText
    } = getComputedStyle$1(elFrom, [ 'borderWidth', 'borderStyle', 'borderColor', 'borderRadius', 'backgroundColor', 'transform', 'position', 'cssText' ]);
    const elFromClassSaved = elFrom.classList.toString();
    const elFromStyleSaved = elFrom.style.cssText;

    // we make a clone of the initial element and
    // use it to display until the final element is ready
    // and to change the occupied space during animation
    const elFromClone = elFrom.cloneNode(true);
    const elFromTween = options.tween === true ? elFrom.cloneNode(true) : void 0;

    if (elFromTween !== void 0) {
      elFromTween.className = elFromTween.classList.toString().split(' ').filter(c => /^bg-/.test(c) === false).join(' ');
    }

    // if the initial element is not going to be removed do not show the placeholder
    options.hideFromClone === true && elFromClone.classList.add('q-morph--internal');

    // prevent interaction with placeholder
    elFromClone.setAttribute('aria-hidden', 'true');
    elFromClone.style.transition = 'none';
    elFromClone.style.animation = 'none';
    elFromClone.style.pointerEvents = 'none';
    elFromParent.insertBefore(elFromClone, elFromNext);

    // we mark the element with its cleanup function
    elFrom.qMorphCancel = () => {
      cancelStatus = true;

      // we clean the clone of the initial element
      elFromClone.remove();
      elFromTween !== void 0 && elFromTween.remove();

      options.hideFromClone === true && elFromClone.classList.remove('q-morph--internal');

      // we remove the cleanup function from the element
      elFrom.qMorphCancel = void 0;
    };

    // will be called after Vue catches up with the changes done by _options.onToggle() function
    const calculateFinalState = () => {
      const elTo = getElement(elements.to);
      if (cancelStatus === true || isValidElement(elTo) !== true) {
        typeof elFrom.qMorphCancel === 'function' && elFrom.qMorphCancel();

        return
      }
      // we clean other morphs running on this element
      elFrom !== elTo && typeof elTo.qMorphCancel === 'function' && elTo.qMorphCancel();

      // we hide the final element and the clone of the initial element
      // we don't hide the final element if we want both it and the animated one visible
      options.keepToClone !== true && elTo.classList.add('q-morph--internal');
      elFromClone.classList.add('q-morph--internal');

      // we get the dimensions of the parent of the initial element after changes
      // the difference is how much we should animate the clone
      const {
        width: elFromParentWidthAfter,
        height: elFromParentHeightAfter
      } = getAbsoluteSize(elFromParent);

      // we get the dimensions of the parent of the final element before changes
      const {
        width: elToParentWidthBefore,
        height: elToParentHeightBefore
      } = getAbsoluteSize(elTo.parentNode);

      // then we show the clone of the initial element if we don't want it hidden
      options.hideFromClone !== true && elFromClone.classList.remove('q-morph--internal');

      // we mark the element with its cleanup function
      elTo.qMorphCancel = () => {
        cancelStatus = true;

        // we clean the clone of the initial element
        elFromClone.remove();
        elFromTween !== void 0 && elFromTween.remove();

        options.hideFromClone === true && elFromClone.classList.remove('q-morph--internal');

        // we show the final element
        options.keepToClone !== true && elTo.classList.remove('q-morph--internal');

        // we remove the cleanup function from the elements
        elFrom.qMorphCancel = void 0;
        elTo.qMorphCancel = void 0;
      };

      // will be called after waitFor (give time to render the final element)
      const animate = () => {
        if (cancelStatus === true) {
          typeof elTo.qMorphCancel === 'function' && elTo.qMorphCancel();

          return
        }

        // now the animation starts, so we only need the clone
        // of the initial element as a spacer
        // we also hide it to calculate the dimensions of the
        // parent of the final element after the changes
        if (options.hideFromClone !== true) {
          elFromClone.classList.add('q-morph--internal');
          elFromClone.innerHTML = '';
          elFromClone.style.left = 0;
          elFromClone.style.right = 'unset';
          elFromClone.style.top = 0;
          elFromClone.style.bottom = 'unset';
          elFromClone.style.transform = 'none';
        }

        // we show the final element
        if (options.keepToClone !== true) {
          elTo.classList.remove('q-morph--internal');
        }

        // we get the dimensions of the parent of the final element after changes
        // the difference is how much we should animate the clone
        const elToParent = elTo.parentNode;
        const {
          width: elToParentWidthAfter,
          height: elToParentHeightAfter
        } = getAbsoluteSize(elToParent);

        const elToClone = elTo.cloneNode(options.keepToClone);
        elToClone.setAttribute('aria-hidden', 'true');
        if (options.keepToClone !== true) {
          elToClone.style.left = 0;
          elToClone.style.right = 'unset';
          elToClone.style.top = 0;
          elToClone.style.bottom = 'unset';
          elToClone.style.transform = 'none';
          elToClone.style.pointerEvents = 'none';
        }
        elToClone.classList.add('q-morph--internal');

        // if elFrom is the same as elTo the next element is elFromClone
        const elToNext = elTo === elFrom && elFromParent === elToParent ? elFromClone : elTo.nextElementSibling;
        elToParent.insertBefore(elToClone, elToNext);

        const {
          borderWidth: elToBorderWidth,
          borderStyle: elToBorderStyle,
          borderColor: elToBorderColor,
          borderRadius: elToBorderRadius,
          backgroundColor: elToBackground,
          transform: elToTransform,
          position: elToPositioningType,
          cssText: elToCssText
        } = getComputedStyle$1(elTo, [ 'borderWidth', 'borderStyle', 'borderColor', 'borderRadius', 'backgroundColor', 'transform', 'position', 'cssText' ]);
        const elToClassSaved = elTo.classList.toString();
        const elToStyleSaved = elTo.style.cssText;

        // we set the computed styles on the element (to be able to remove classes)
        elTo.style.cssText = elToCssText;
        elTo.style.transform = 'none';
        elTo.style.animation = 'none';
        elTo.style.transition = 'none';
        // we strip the background classes (background color can no longer be animated if !important is used)
        elTo.className = elToClassSaved.split(' ').filter(c => /^bg-/.test(c) === false).join(' ');

        const elToPosition = getAbsolutePosition(elTo, options.resize);

        const deltaX = elFromPosition.left - elToPosition.left;
        const deltaY = elFromPosition.top - elToPosition.top;
        const scaleX = elFromPosition.width / (elToPosition.width > 0 ? elToPosition.width : 10);
        const scaleY = elFromPosition.height / (elToPosition.height > 0 ? elToPosition.height : 100);

        const elFromParentWidthDiff = elFromParentWidthBefore - elFromParentWidthAfter;
        const elFromParentHeightDiff = elFromParentHeightBefore - elFromParentHeightAfter;
        const elToParentWidthDiff = elToParentWidthAfter - elToParentWidthBefore;
        const elToParentHeightDiff = elToParentHeightAfter - elToParentHeightBefore;

        const elFromCloneWidth = Math.max(elFromPosition.widthM, elFromParentWidthDiff);
        const elFromCloneHeight = Math.max(elFromPosition.heightM, elFromParentHeightDiff);
        const elToCloneWidth = Math.max(elToPosition.widthM, elToParentWidthDiff);
        const elToCloneHeight = Math.max(elToPosition.heightM, elToParentHeightDiff);

        const elSharedSize = elFrom === elTo &&
          [ 'absolute', 'fixed' ].includes(elToPositioningType) === false &&
          [ 'absolute', 'fixed' ].includes(elFromPositioningType) === false;

        // if the final element has fixed position or if a parent
        // has fixed position we need to animate it as fixed
        let elToNeedsFixedPosition = elToPositioningType === 'fixed';
        let parent = elToParent;
        while (elToNeedsFixedPosition !== true && parent !== document) {
          elToNeedsFixedPosition = window.getComputedStyle(parent).position === 'fixed';
          parent = parent.parentNode;
        }

        // we show the spacer for the initial element
        if (options.hideFromClone !== true) {
          elFromClone.style.display = 'block';
          elFromClone.style.flex = '0 0 auto';
          elFromClone.style.opacity = 0;
          elFromClone.style.minWidth = 'unset';
          elFromClone.style.maxWidth = 'unset';
          elFromClone.style.minHeight = 'unset';
          elFromClone.style.maxHeight = 'unset';
          elFromClone.classList.remove('q-morph--internal');
        }

        // we show the spacer for the final element
        if (options.keepToClone !== true) {
          elToClone.style.display = 'block';
          elToClone.style.flex = '0 0 auto';
          elToClone.style.opacity = 0;
          elToClone.style.minWidth = 'unset';
          elToClone.style.maxWidth = 'unset';
          elToClone.style.minHeight = 'unset';
          elToClone.style.maxHeight = 'unset';
        }
        elToClone.classList.remove('q-morph--internal');

        // we apply classes specified by user
        if (typeof options.classes === 'string') {
          elTo.className += ' ' + options.classes;
        }

        // we apply styles specified by user
        if (typeof options.style === 'string') {
          elTo.style.cssText += ' ' + options.style;
        }
        else if (isObject(options.style) === true) {
          for (const prop in options.style) {
            elTo.style[prop] = options.style[prop];
          }
        }

        const elFromZIndex = getMaxZIndex(elFromClone);
        const elToZIndex = getMaxZIndex(elTo);

        // we position the morphing element
        // if we use fixed position for the final element we need to adjust for scroll
        const documentScroll = elToNeedsFixedPosition === true
          ? document.documentElement
          : { scrollLeft: 0, scrollTop: 0 };
        elTo.style.position = elToNeedsFixedPosition === true ? 'fixed' : 'absolute';
        elTo.style.left = `${elToPosition.left - documentScroll.scrollLeft}px`;
        elTo.style.right = 'unset';
        elTo.style.top = `${elToPosition.top - documentScroll.scrollTop}px`;
        elTo.style.margin = 0;

        if (options.resize === true) {
          elTo.style.minWidth = 'unset';
          elTo.style.maxWidth = 'unset';
          elTo.style.minHeight = 'unset';
          elTo.style.maxHeight = 'unset';
          elTo.style.overflow = 'hidden';
          elTo.style.overflowX = 'hidden';
          elTo.style.overflowY = 'hidden';
        }

        document.body.appendChild(elTo);

        if (elFromTween !== void 0) {
          elFromTween.style.cssText = elFromCssText;
          elFromTween.style.transform = 'none';
          elFromTween.style.animation = 'none';
          elFromTween.style.transition = 'none';

          elFromTween.style.position = elTo.style.position;
          elFromTween.style.left = `${elFromPosition.left - documentScroll.scrollLeft}px`;
          elFromTween.style.right = 'unset';
          elFromTween.style.top = `${elFromPosition.top - documentScroll.scrollTop}px`;
          elFromTween.style.margin = 0;
          elFromTween.style.pointerEvents = 'none';

          if (options.resize === true) {
            elFromTween.style.minWidth = 'unset';
            elFromTween.style.maxWidth = 'unset';
            elFromTween.style.minHeight = 'unset';
            elFromTween.style.maxHeight = 'unset';
            elFromTween.style.overflow = 'hidden';
            elFromTween.style.overflowX = 'hidden';
            elFromTween.style.overflowY = 'hidden';
          }

          document.body.appendChild(elFromTween);
        }

        const commonCleanup = aborted => {
          // we put the element back in it's place
          // and restore the styles and classes
          if (elFrom === elTo && endElementTo !== true) {
            elTo.style.cssText = elFromStyleSaved;
            elTo.className = elFromClassSaved;
          }
          else {
            elTo.style.cssText = elToStyleSaved;
            elTo.className = elToClassSaved;
          }
          elToClone.parentNode === elToParent && elToParent.insertBefore(elTo, elToClone);

          // we clean the spacers
          elFromClone.remove();
          elToClone.remove();
          elFromTween !== void 0 && elFromTween.remove();

          // cancel will be no longer available
          cancel = () => false;

          elFrom.qMorphCancel = void 0;
          elTo.qMorphCancel = void 0;

          // we are ready
          if (typeof options.onEnd === 'function') {
            options.onEnd(endElementTo === true ? 'to' : 'from', aborted === true);
          }
        };

        if (options.useCSS !== true && typeof elTo.animate === 'function') {
          const resizeFrom = options.resize === true
            ? {
              transform: `translate(${deltaX}px, ${deltaY}px)`,
              width: `${elFromCloneWidth}px`,
              height: `${elFromCloneHeight}px`
            }
            : {
              transform: `translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`
            };
          const resizeTo = options.resize === true
            ? {
              width: `${elToCloneWidth}px`,
              height: `${elToCloneHeight}px`
            }
            : {};
          const resizeFromTween = options.resize === true
            ? {
              width: `${elFromCloneWidth}px`,
              height: `${elFromCloneHeight}px`
            }
            : {};
          const resizeToTween = options.resize === true
            ? {
              transform: `translate(${-1 * deltaX}px, ${-1 * deltaY}px)`,
              width: `${elToCloneWidth}px`,
              height: `${elToCloneHeight}px`
            }
            : {
              transform: `translate(${-1 * deltaX}px, ${-1 * deltaY}px) scale(${1 / scaleX}, ${1 / scaleY})`
            };
          const tweenFrom = elFromTween !== void 0
            ? { opacity: options.tweenToOpacity }
            : { backgroundColor: elFromBackground };
          const tweenTo = elFromTween !== void 0
            ? { opacity: 1 }
            : { backgroundColor: elToBackground };
          animationTo = elTo.animate([
            {
              margin: 0,
              borderWidth: elFromBorderWidth,
              borderStyle: elFromBorderStyle,
              borderColor: elFromBorderColor,
              borderRadius: elFromBorderRadius,
              zIndex: elFromZIndex,
              transformOrigin: '0 0',
              ...resizeFrom,
              ...tweenFrom
            },
            {
              margin: 0,
              borderWidth: elToBorderWidth,
              borderStyle: elToBorderStyle,
              borderColor: elToBorderColor,
              borderRadius: elToBorderRadius,
              zIndex: elToZIndex,
              transformOrigin: '0 0',
              transform: elToTransform,
              ...resizeTo,
              ...tweenTo
            }
          ], {
            duration: options.duration,
            easing: options.easing,
            fill: options.fill,
            delay: options.delay
          });

          animationFromTween = elFromTween === void 0 ? void 0 : elFromTween.animate([
            {
              opacity: options.tweenFromOpacity,
              margin: 0,
              borderWidth: elFromBorderWidth,
              borderStyle: elFromBorderStyle,
              borderColor: elFromBorderColor,
              borderRadius: elFromBorderRadius,
              zIndex: elFromZIndex,
              transformOrigin: '0 0',
              transform: elFromTransform,
              ...resizeFromTween
            },
            {
              opacity: 0,
              margin: 0,
              borderWidth: elToBorderWidth,
              borderStyle: elToBorderStyle,
              borderColor: elToBorderColor,
              borderRadius: elToBorderRadius,
              zIndex: elToZIndex,
              transformOrigin: '0 0',
              ...resizeToTween
            }
          ], {
            duration: options.duration,
            easing: options.easing,
            fill: options.fill,
            delay: options.delay
          });

          animationFromClone = options.hideFromClone === true || elSharedSize === true ? void 0 : elFromClone.animate([
            {
              margin: `${elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0}px ${elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0}px`,
              width: `${elFromCloneWidth + elFromPosition.marginH}px`,
              height: `${elFromCloneHeight + elFromPosition.marginV}px`
            },
            {
              margin: 0,
              width: 0,
              height: 0
            }
          ], {
            duration: options.duration,
            easing: options.easing,
            fill: options.fill,
            delay: options.delay
          });

          animationToClone = options.keepToClone === true ? void 0 : elToClone.animate([
            elSharedSize === true
              ? {
                margin: `${elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0}px ${elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0}px`,
                width: `${elFromCloneWidth + elFromPosition.marginH}px`,
                height: `${elFromCloneHeight + elFromPosition.marginV}px`
              }
              : {
                margin: 0,
                width: 0,
                height: 0
              },
            {
              margin: `${elToParentHeightDiff < 0 ? elToParentHeightDiff / 2 : 0}px ${elToParentWidthDiff < 0 ? elToParentWidthDiff / 2 : 0}px`,
              width: `${elToCloneWidth + elToPosition.marginH}px`,
              height: `${elToCloneHeight + elToPosition.marginV}px`
            }
          ], {
            duration: options.duration,
            easing: options.easing,
            fill: options.fill,
            delay: options.delay
          });

          const cleanup = abort => {
            animationFromClone !== void 0 && animationFromClone.cancel();
            animationFromTween !== void 0 && animationFromTween.cancel();
            animationToClone !== void 0 && animationToClone.cancel();
            animationTo.cancel();

            animationTo.removeEventListener('finish', cleanup);
            animationTo.removeEventListener('cancel', cleanup);

            commonCleanup(abort);

            // we clean the animations
            animationFromClone = void 0;
            animationFromTween = void 0;
            animationToClone = void 0;
            animationTo = void 0;
          };

          elFrom.qMorphCancel = () => {
            elFrom.qMorphCancel = void 0;
            cancelStatus = true;
            cleanup();
          };
          elTo.qMorphCancel = () => {
            elTo.qMorphCancel = void 0;
            cancelStatus = true;
            cleanup();
          };

          animationTo.addEventListener('finish', cleanup);
          animationTo.addEventListener('cancel', cleanup);

          cancel = abort => {
            // we are not in a morph that we can cancel
            if (cancelStatus === true || animationTo === void 0) {
              return false
            }

            if (abort === true) {
              cleanup(true);
              return true
            }

            endElementTo = endElementTo !== true;

            animationFromClone !== void 0 && animationFromClone.reverse();
            animationFromTween !== void 0 && animationFromTween.reverse();
            animationToClone !== void 0 && animationToClone.reverse();
            animationTo.reverse();

            return true
          };
        }
        else {
          const qAnimId = `q-morph-anim-${++id}`;
          const style = document.createElement('style');
          const resizeFrom = options.resize === true
            ? `
            transform: translate(${deltaX}px, ${deltaY}px);
            width: ${elFromCloneWidth}px;
            height: ${elFromCloneHeight}px;
          `
            : `transform: translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY});`;
          const resizeTo = options.resize === true
            ? `
            width: ${elToCloneWidth}px;
            height: ${elToCloneHeight}px;
          `
            : '';
          const resizeFromTween = options.resize === true
            ? `
            width: ${elFromCloneWidth}px;
            height: ${elFromCloneHeight}px;
          `
            : '';
          const resizeToTween = options.resize === true
            ? `
            transform: translate(${-1 * deltaX}px, ${-1 * deltaY}px);
            width: ${elToCloneWidth}px;
            height: ${elToCloneHeight}px;
          `
            : `transform: translate(${-1 * deltaX}px, ${-1 * deltaY}px) scale(${1 / scaleX}, ${1 / scaleY});`;
          const tweenFrom = elFromTween !== void 0
            ? `opacity: ${options.tweenToOpacity};`
            : `background-color: ${elFromBackground};`;
          const tweenTo = elFromTween !== void 0
            ? 'opacity: 1;'
            : `background-color: ${elToBackground};`;
          const keyframesFromTween = elFromTween === void 0
            ? ''
            : `
            @keyframes ${qAnimId}-from-tween {
              0% {
                opacity: ${options.tweenFromOpacity};
                margin: 0;
                border-width: ${elFromBorderWidth};
                border-style: ${elFromBorderStyle};
                border-color: ${elFromBorderColor};
                border-radius: ${elFromBorderRadius};
                z-index: ${elFromZIndex};
                transform-origin: 0 0;
                transform: ${elFromTransform};
                ${resizeFromTween}
              }

              100% {
                opacity: 0;
                margin: 0;
                border-width: ${elToBorderWidth};
                border-style: ${elToBorderStyle};
                border-color: ${elToBorderColor};
                border-radius: ${elToBorderRadius};
                z-index: ${elToZIndex};
                transform-origin: 0 0;
                ${resizeToTween}
              }
            }
          `;
          const keyframesFrom = options.hideFromClone === true || elSharedSize === true
            ? ''
            : `
            @keyframes ${qAnimId}-from {
              0% {
                margin: ${elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0}px ${elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0}px;
                width: ${elFromCloneWidth + elFromPosition.marginH}px;
                height: ${elFromCloneHeight + elFromPosition.marginV}px;
              }

              100% {
                margin: 0;
                width: 0;
                height: 0;
              }
            }
          `;
          const keyframeToStart = elSharedSize === true
            ? `
            margin: ${elFromParentHeightDiff < 0 ? elFromParentHeightDiff / 2 : 0}px ${elFromParentWidthDiff < 0 ? elFromParentWidthDiff / 2 : 0}px;
            width: ${elFromCloneWidth + elFromPosition.marginH}px;
            height: ${elFromCloneHeight + elFromPosition.marginV}px;
          `
            : `
            margin: 0;
            width: 0;
            height: 0;
          `;
          const keyframesTo = options.keepToClone === true
            ? ''
            : `
            @keyframes ${qAnimId}-to {
              0% {
                ${keyframeToStart}
              }

              100% {
                margin: ${elToParentHeightDiff < 0 ? elToParentHeightDiff / 2 : 0}px ${elToParentWidthDiff < 0 ? elToParentWidthDiff / 2 : 0}px;
                width: ${elToCloneWidth + elToPosition.marginH}px;
                height: ${elToCloneHeight + elToPosition.marginV}px;
              }
            }
          `;
          style.innerHTML = `
          @keyframes ${qAnimId} {
            0% {
              margin: 0;
              border-width: ${elFromBorderWidth};
              border-style: ${elFromBorderStyle};
              border-color: ${elFromBorderColor};
              border-radius: ${elFromBorderRadius};
              background-color: ${elFromBackground};
              z-index: ${elFromZIndex};
              transform-origin: 0 0;
              ${resizeFrom}
              ${tweenFrom}
            }

            100% {
              margin: 0;
              border-width: ${elToBorderWidth};
              border-style: ${elToBorderStyle};
              border-color: ${elToBorderColor};
              border-radius: ${elToBorderRadius};
              background-color: ${elToBackground};
              z-index: ${elToZIndex};
              transform-origin: 0 0;
              transform: ${elToTransform};
              ${resizeTo}
              ${tweenTo}
            }
          }

          ${keyframesFrom}

          ${keyframesFromTween}

          ${keyframesTo}
        `;
          document.head.appendChild(style);

          let animationDirection = 'normal';

          elFromClone.style.animation = `${options.duration}ms ${options.easing} ${options.delay}ms ${animationDirection} ${options.fill} ${qAnimId}-from`;
          if (elFromTween !== void 0) {
            elFromTween.style.animation = `${options.duration}ms ${options.easing} ${options.delay}ms ${animationDirection} ${options.fill} ${qAnimId}-from-tween`;
          }
          elToClone.style.animation = `${options.duration}ms ${options.easing} ${options.delay}ms ${animationDirection} ${options.fill} ${qAnimId}-to`;
          elTo.style.animation = `${options.duration}ms ${options.easing} ${options.delay}ms ${animationDirection} ${options.fill} ${qAnimId}`;

          const cleanup = evt => {
            if (evt === Object(evt) && evt.animationName !== qAnimId) {
              return
            }

            elTo.removeEventListener('animationend', cleanup);
            elTo.removeEventListener('animationcancel', cleanup);

            commonCleanup();

            // we clean the animations
            style.remove();
          };

          elFrom.qMorphCancel = () => {
            elFrom.qMorphCancel = void 0;
            cancelStatus = true;
            cleanup();
          };
          elTo.qMorphCancel = () => {
            elTo.qMorphCancel = void 0;
            cancelStatus = true;
            cleanup();
          };

          elTo.addEventListener('animationend', cleanup);
          elTo.addEventListener('animationcancel', cleanup);

          cancel = abort => {
            // we are not in a morph that we can cancel
            if (cancelStatus === true || !elTo || !elFromClone || !elToClone) {
              return false
            }

            if (abort === true) {
              cleanup();

              return true
            }

            endElementTo = endElementTo !== true;

            animationDirection = animationDirection === 'normal' ? 'reverse' : 'normal';

            elFromClone.style.animationDirection = animationDirection;
            elFromTween.style.animationDirection = animationDirection;
            elToClone.style.animationDirection = animationDirection;
            elTo.style.animationDirection = animationDirection;

            return true
          };
        }
      };

      if (
        options.waitFor > 0 ||
        options.waitFor === 'transitionend' ||
        (options.waitFor === Object(options.waitFor) && typeof options.waitFor.then === 'function')
      ) {
        const delayPromise = options.waitFor > 0
          ? new Promise(resolve => setTimeout(resolve, options.waitFor))
          : (
            options.waitFor === 'transitionend'
              ? new Promise(resolve => {
                const timer = setTimeout(() => {
                  endFn();
                }, 400);

                const endFn = ev => {
                  clearTimeout(timer);

                  if (elTo) {
                    elTo.removeEventListener('transitionend', endFn);
                    elTo.removeEventListener('transitioncancel', endFn);
                  }

                  resolve();
                };

                elTo.addEventListener('transitionend', endFn);
                elTo.addEventListener('transitioncancel', endFn);
              })
              : options.waitFor
          );

        delayPromise
          .then(animate)
          .catch(() => {
            typeof elTo.qMorphCancel === 'function' && elTo.qMorphCancel();
          });
      }
      else {
        animate();
      }
    };

    typeof _options.onToggle === 'function' && _options.onToggle();
    requestAnimationFrame(calculateFinalState);

    // we return the cancel function
    // returns:
    //   false if the cancel cannot be performed (the morph ended already or has not started)
    //   true else
    return abort => cancel(abort)
  }

  const morphGroups = {};
  const props = [
    'duration', 'delay', 'easing', 'fill',
    'classes', 'style', 'duration', 'resize',
    'useCSS', 'hideFromClone', 'keepToClone', 'tween',
    'tweenFromOpacity', 'tweenToOpacity',
    'waitFor', 'onEnd'
  ];
  const mods = [
    'resize', 'useCSS', 'hideFromClone', 'keepToClone', 'tween'
  ];

  function changeClass (ctx, action) {
    if (ctx.clsAction !== action) {
      ctx.clsAction = action;
      ctx.el.classList[action]('q-morph--invisible');
    }
  }

  function trigger (group) {
    if (group.animating === true || group.queue.length < 2) {
      return
    }

    const [ from, to ] = group.queue;

    group.animating = true;
    from.animating = true;
    to.animating = true;

    changeClass(from, 'remove');
    changeClass(to, 'remove');

    const cancelFn = morph({
      from: from.el,
      to: to.el,
      onToggle () {
        changeClass(from, 'add');
        changeClass(to, 'remove');
      },
      ...to.opts,
      onEnd (dir, aborted) {
        to.opts.onEnd !== void 0 && to.opts.onEnd(dir, aborted);

        if (aborted === true) {
          return
        }

        from.animating = false;
        to.animating = false;

        group.animating = false;
        group.cancel = void 0;
        group.queue.shift();

        trigger(group);
      }
    });

    group.cancel = () => {
      cancelFn(true); // abort
      group.cancel = void 0;
    };
  }

  function updateModifiers$1 (mod, ctx) {
    const opts = ctx.opts;

    mods.forEach(name => {
      opts[name] = mod[name] === true;
    });
  }

  function insertArgs (arg, ctx) {
    const opts = typeof arg === 'string' && arg.length > 0
      ? arg.split(':') : [];

    ctx.name = opts[0];
    ctx.group = opts[1];

    Object.assign(ctx.opts, {
      duration: isNaN(opts[2]) === true
        ? 300
        : parseFloat(opts[2]),
      waitFor: opts[3]
    });
  }

  function updateArgs (arg, ctx) {
    if (arg.group !== void 0) {
      ctx.group = arg.group;
    }
    if (arg.name !== void 0) {
      ctx.name = arg.name;
    }

    const opts = ctx.opts;

    props.forEach(name => {
      if (arg[name] !== void 0) {
        opts[name] = arg[name];
      }
    });
  }

  function updateModel (name, ctx) {
    if (ctx.name === name) {
      const group = morphGroups[ctx.group];

      // if group is not registered
      if (group === void 0) {
        morphGroups[ctx.group] = {
          name: ctx.group,
          model: name,
          queue: [ ctx ],
          animating: false
        };

        changeClass(ctx, 'remove');
      }
      // if model changed
      else if (group.model !== name) {
        group.model = name;
        group.queue.push(ctx);

        if (group.animating === false && group.queue.length === 2) {
          trigger(group);
        }
      }

      return
    }

    if (ctx.animating === false) {
      changeClass(ctx, 'add');
    }
  }

  function updateValue (ctx, value) {
    let model;

    if (Object(value) === value) {
      model = '' + value.model;
      updateArgs(value, ctx);
      updateModifiers$1(value, ctx);
    }
    else {
      model = '' + value;
    }

    if (model !== ctx.model) {
      ctx.model = model;
      updateModel(model, ctx);
    }
    else if (ctx.animating === false && ctx.clsAction !== void 0) {
      // ensure HMR
      ctx.el.classList[ctx.clsAction]('q-morph--invisible');
    }
  }

  function destroy$6 (el) {
    const ctx = el.__qmorph;

    if (ctx !== void 0) {
      const group = morphGroups[ctx.group];

      if (group !== void 0) {
        const index = group.queue.indexOf(ctx);

        if (index !== -1) {
          group.queue = group.queue.filter(item => item !== ctx);

          if (group.queue.length === 0) {
            group.cancel !== void 0 && group.cancel();
            delete morphGroups[ctx.group];
          }
        }
      }

      if (ctx.clsAction === 'add') {
        el.classList.remove('q-morph--invisible');
      }

      delete el.__qmorph;
    }
  }

  var Morph = {
    name: 'morph',

    inserted (el, binding) {
      if (el.__qmorph !== void 0) {
        destroy$6(el);
        el.__qmorph_destroyed = true;
      }

      const ctx = {
        el,
        animating: false,
        opts: {}
      };

      updateModifiers$1(binding.modifiers, ctx);
      insertArgs(binding.arg, ctx);
      updateValue(ctx, binding.value);

      el.__qmorph = ctx;
    },

    update (el, binding) {
      const ctx = el.__qmorph;
      ctx !== void 0 && updateValue(ctx, binding.value);
    },

    unbind (el) {
      if (el.__qmorph_destroyed === void 0) {
        destroy$6(el);
      }
      else {
        delete el.__qmorph_destroyed;
      }
    }
  };

  const defaultCfg$1 = {
    childList: true,
    subtree: true,
    attributes: true,
    characterData: true,
    attributeOldValue: true,
    characterDataOldValue: true
  };

  function update$1 (el, ctx, value) {
    ctx.handler = value;
    ctx.observer !== void 0 && ctx.observer.disconnect();

    ctx.observer = new MutationObserver(list => {
      if (typeof ctx.handler === 'function') {
        const res = ctx.handler(list);
        if (res === false || ctx.once === true) {
          destroy$7(el);
        }
      }
    });

    ctx.observer.observe(el, ctx.opts);
  }

  function destroy$7 (el) {
    const ctx = el.__qmutation;

    if (ctx !== void 0) {
      ctx.observer !== void 0 && ctx.observer.disconnect();
      delete el.__qmutation;
    }
  }

  var Mutation = {
    name: 'mutation',

    inserted (el, { modifiers: { once, ...mod }, value }) {
      if (el.__qmutation !== void 0) {
        destroy$7(el);
        el.__qmutation_destroyed = true;
      }

      const ctx = {
        once,
        opts: Object.keys(mod).length === 0
          ? defaultCfg$1
          : mod
      };

      update$1(el, ctx, value);

      el.__qmutation = ctx;
    },

    update (el, { oldValue, value }) {
      const ctx = el.__qmutation;
      if (ctx !== void 0 && oldValue !== value) {
        update$1(el, ctx, value);
      }
    },

    unbind (el) {
      if (el.__qmutation_destroyed === void 0) {
        destroy$7(el);
      }
      else {
        delete el.__qmutation_destroyed;
      }
    }
  };

  function update$2 (ctx, { value, oldValue }) {
    if (typeof value !== 'function') {
      ctx.scrollTarget.removeEventListener('scroll', ctx.scroll, listenOpts.passive);
      return
    }

    ctx.handler = value;
    if (typeof oldValue !== 'function') {
      ctx.scrollTarget.addEventListener('scroll', ctx.scroll, listenOpts.passive);
      ctx.scroll();
    }
  }

  function destroy$8 (el) {
    const ctx = el.__qscrollfire;
    if (ctx !== void 0) {
      ctx.scrollTarget.removeEventListener('scroll', ctx.scroll, listenOpts.passive);
      ctx.scroll.cancel();
      delete el.__qscrollfire;
    }
  }

  var ScrollFire = {
    name: 'scroll-fire',

    inserted (el, binding) {
      if (el.__qscrollfire !== void 0) {
        destroy$8(el);
        el.__qscrollfire_destroyed = true;
      }

      const ctx = {
        scrollTarget: getScrollTarget(el),
        scroll: debounce(() => {
          let containerBottom, elBottom;

          if (ctx.scrollTarget === window) {
            elBottom = el.getBoundingClientRect().bottom;
            containerBottom = window.innerHeight;
          }
          else {
            elBottom = offset(el).top + height(el);
            containerBottom = offset(ctx.scrollTarget).top + height(ctx.scrollTarget);
          }

          if (elBottom > 0 && elBottom < containerBottom) {
            ctx.scrollTarget.removeEventListener('scroll', ctx.scroll, listenOpts.passive);
            ctx.handler(el);
          }
        }, 25)
      };

      update$2(ctx, binding);

      el.__qscrollfire = ctx;
    },

    update (el, binding) {
      if (el.__qscrollfire !== void 0 && binding.value !== binding.oldValue) {
        update$2(el.__qscrollfire, binding);
      }
    },

    unbind (el) {
      if (el.__qscrollfire_destroyed === void 0) {
        destroy$8(el);
      }
      else {
        delete el.__qscrollfire_destroyed;
      }
    }
  };

  function update$3 (ctx, { value, oldValue }) {
    if (typeof value !== 'function') {
      ctx.scrollTarget.removeEventListener('scroll', ctx.scroll, listenOpts.passive);
      return
    }

    ctx.handler = value;
    if (typeof oldValue !== 'function') {
      ctx.scrollTarget.addEventListener('scroll', ctx.scroll, listenOpts.passive);
    }
  }

  function destroy$9 (el) {
    const ctx = el.__qscroll;
    if (ctx !== void 0) {
      ctx.scrollTarget.removeEventListener('scroll', ctx.scroll, listenOpts.passive);
      delete el.__qscroll;
    }
  }

  var Scroll = {
    name: 'scroll',

    inserted (el, binding) {
      if (el.__qscroll !== void 0) {
        destroy$9(el);
        el.__qscroll_destroyed = true;
      }

      const ctx = {
        scrollTarget: getScrollTarget(el),
        scroll () {
          ctx.handler(
            getVerticalScrollPosition(ctx.scrollTarget),
            getHorizontalScrollPosition(ctx.scrollTarget)
          );
        }
      };

      update$3(ctx, binding);

      el.__qscroll = ctx;
    },

    update (el, binding) {
      if (el.__qscroll !== void 0 && binding.oldValue !== binding.value) {
        update$3(el.__qscroll, binding);
      }
    },

    unbind (el) {
      if (el.__qscroll_destroyed === void 0) {
        destroy$9(el);
      }
      else {
        delete el.__qscroll_destroyed;
      }
    }
  };

  function destroy$a (el) {
    const ctx = el.__qtouchhold;
    if (ctx !== void 0) {
      cleanEvt(ctx, 'main');
      cleanEvt(ctx, 'temp');

      clearTimeout(ctx.timer);
      ctx.styleCleanup !== void 0 && ctx.styleCleanup();

      delete el.__qtouchhold;
    }
  }

  var TouchHold = {
    name: 'touch-hold',

    bind (el, binding) {
      if (el.__qtouchhold !== void 0) {
        destroy$a(el);
        el.__qtouchhold_destroyed = true;
      }

      const { modifiers } = binding;

      // early return, we don't need to do anything
      if (modifiers.mouse !== true && client.has.touch !== true) {
        return
      }

      const ctx = {
        handler: binding.value,
        noop,

        mouseStart (evt) {
          if (typeof ctx.handler === 'function' && leftClick(evt) === true) {
            addEvt(ctx, 'temp', [
              [ document, 'mousemove', 'move', 'passiveCapture' ],
              [ document, 'click', 'end', 'notPassiveCapture' ]
            ]);
            ctx.start(evt, true);
          }
        },

        touchStart (evt) {
          if (evt.target !== void 0 && typeof ctx.handler === 'function') {
            const target = evt.target;
            addEvt(ctx, 'temp', [
              [ target, 'touchmove', 'move', 'passiveCapture' ],
              [ target, 'touchcancel', 'end', 'notPassiveCapture' ],
              [ target, 'touchend', 'end', 'notPassiveCapture' ]
            ]);
            ctx.start(evt);
          }
        },

        start (evt, mouseEvent) {
          ctx.origin = position(evt);

          const startTime = Date.now();

          if (client.is.mobile === true) {
            document.body.classList.add('non-selectable');
            clearSelection();

            ctx.styleCleanup = withDelay => {
              ctx.styleCleanup = void 0;

              const remove = () => {
                document.body.classList.remove('non-selectable');
              };

              if (withDelay === true) {
                clearSelection();
                setTimeout(remove, 10);
              }
              else { remove(); }
            };
          }

          ctx.triggered = false;
          ctx.sensitivity = mouseEvent === true
            ? ctx.mouseSensitivity
            : ctx.touchSensitivity;

          ctx.timer = setTimeout(() => {
            clearSelection();
            ctx.triggered = true;

            ctx.handler({
              evt,
              touch: mouseEvent !== true,
              mouse: mouseEvent === true,
              position: ctx.origin,
              duration: Date.now() - startTime
            });
          }, ctx.duration);
        },

        move (evt) {
          const { top, left } = position(evt);
          if (
            Math.abs(left - ctx.origin.left) >= ctx.sensitivity ||
            Math.abs(top - ctx.origin.top) >= ctx.sensitivity
          ) {
            clearTimeout(ctx.timer);
          }
        },

        end (evt) {
          cleanEvt(ctx, 'temp');

          // delay needed otherwise selection still occurs
          ctx.styleCleanup !== void 0 && ctx.styleCleanup(ctx.triggered);

          if (ctx.triggered === true) {
            evt !== void 0 && stopAndPrevent(evt);
          }
          else {
            clearTimeout(ctx.timer);
          }
        }
      };

      // duration in ms, touch in pixels, mouse in pixels
      const data = [600, 5, 7];

      if (typeof binding.arg === 'string' && binding.arg.length > 0) {
        binding.arg.split(':').forEach((val, index) => {
          const v = parseInt(val, 10);
          v && (data[index] = v);
        });
      }

      [ ctx.duration, ctx.touchSensitivity, ctx.mouseSensitivity ] = data;

      el.__qtouchhold = ctx;

      modifiers.mouse === true && addEvt(ctx, 'main', [
        [ el, 'mousedown', 'mouseStart', `passive${modifiers.mouseCapture === true ? 'Capture' : ''}` ]
      ]);

      client.has.touch === true && addEvt(ctx, 'main', [
        [ el, 'touchstart', 'touchStart', `passive${modifiers.capture === true ? 'Capture' : ''}` ],
        [ el, 'touchend', 'noop', 'notPassiveCapture' ]
      ]);
    },

    update (el, binding) {
      const ctx = el.__qtouchhold;
      if (ctx !== void 0 && binding.oldValue !== binding.value) {
        typeof binding.value !== 'function' && ctx.end();
        ctx.handler = binding.value;
      }
    },

    unbind (el) {
      if (el.__qtouchhold_destroyed === void 0) {
        destroy$a(el);
      }
      else {
        delete el.__qtouchhold_destroyed;
      }
    }
  };

  const
    keyCodes$2 = {
      esc: 27,
      tab: 9,
      enter: 13,
      space: 32,
      up: 38,
      left: 37,
      right: 39,
      down: 40,
      'delete': [8, 46]
    },
    keyRegex = new RegExp(`^([\\d+]+|${Object.keys(keyCodes$2).join('|')})$`, 'i');

  function shouldEnd (evt, origin) {
    const { top, left } = position(evt);

    return Math.abs(left - origin.left) >= 7 ||
      Math.abs(top - origin.top) >= 7
  }

  function destroy$b (el) {
    const ctx = el.__qtouchrepeat;
    if (ctx !== void 0) {
      clearTimeout(ctx.timer);

      cleanEvt(ctx, 'main');
      cleanEvt(ctx, 'temp');

      ctx.styleCleanup !== void 0 && ctx.styleCleanup();

      delete el.__qtouchrepeat;
    }
  }

  var TouchRepeat = {
    name: 'touch-repeat',

    bind (el, { modifiers, value, arg }) {
      if (el.__qtouchrepeat !== void 0) {
        destroy$b(el);
        el.__qtouchrepeat_destroyed = true;
      }

      const keyboard = Object.keys(modifiers).reduce((acc, key) => {
        if (keyRegex.test(key) === true) {
          const keyCode = isNaN(parseInt(key, 10)) ? keyCodes$2[key.toLowerCase()] : parseInt(key, 10);
          keyCode >= 0 && acc.push(keyCode);
        }
        return acc
      }, []);

      // early return, we don't need to do anything
      if (
        modifiers.mouse !== true &&
        client.has.touch !== true &&
        keyboard.length === 0
      ) {
        return
      }

      const durations = typeof arg === 'string' && arg.length > 0
        ? arg.split(':').map(val => parseInt(val, 10))
        : [0, 600, 300];

      const durationsLast = durations.length - 1;

      const ctx = {
        keyboard,
        handler: value,

        noop,

        mouseStart (evt) {
          if (ctx.event === void 0 && typeof ctx.handler === 'function' && leftClick(evt) === true) {
            addEvt(ctx, 'temp', [
              [ document, 'mousemove', 'move', 'passiveCapture' ],
              [ document, 'click', 'end', 'notPassiveCapture' ]
            ]);
            ctx.start(evt, true);
          }
        },

        keyboardStart (evt) {
          if (typeof ctx.handler === 'function' && isKeyCode(evt, keyboard) === true) {
            if (durations[0] === 0 || ctx.event !== void 0) {
              stopAndPrevent(evt);
              el.focus();
              if (ctx.event !== void 0) {
                return
              }
            }

            addEvt(ctx, 'temp', [
              [ document, 'keyup', 'end', 'notPassiveCapture' ],
              [ document, 'click', 'end', 'notPassiveCapture' ]
            ]);
            ctx.start(evt, false, true);
          }
        },

        touchStart (evt) {
          if (evt.target !== void 0 && typeof ctx.handler === 'function') {
            const target = evt.target;
            addEvt(ctx, 'temp', [
              [ target, 'touchmove', 'move', 'passiveCapture' ],
              [ target, 'touchcancel', 'end', 'notPassiveCapture' ],
              [ target, 'touchend', 'end', 'notPassiveCapture' ]
            ]);
            ctx.start(evt);
          }
        },

        start (evt, mouseEvent, keyboardEvent) {
          if (keyboardEvent !== true) {
            ctx.origin = position(evt);
          }

          function styleCleanup (withDelay) {
            ctx.styleCleanup = void 0;

            document.documentElement.style.cursor = '';

            const remove = () => {
              document.body.classList.remove('non-selectable');
            };

            if (withDelay === true) {
              clearSelection();
              setTimeout(remove, 10);
            }
            else { remove(); }
          }

          if (client.is.mobile === true) {
            document.body.classList.add('non-selectable');
            clearSelection();
            ctx.styleCleanup = styleCleanup;
          }

          ctx.event = {
            touch: mouseEvent !== true && keyboardEvent !== true,
            mouse: mouseEvent === true,
            keyboard: keyboardEvent === true,
            startTime: Date.now(),
            repeatCount: 0
          };

          const fn = () => {
            if (ctx.event === void 0) {
              return
            }

            if (ctx.event.repeatCount === 0) {
              ctx.event.evt = evt;

              if (keyboardEvent === true) {
                ctx.event.keyCode = evt.keyCode;
              }
              else {
                ctx.event.position = position(evt);
              }

              if (client.is.mobile !== true) {
                document.documentElement.style.cursor = 'pointer';
                document.body.classList.add('non-selectable');
                clearSelection();
                ctx.styleCleanup = styleCleanup;
              }
            }

            ctx.event.duration = Date.now() - ctx.event.startTime;
            ctx.event.repeatCount += 1;

            ctx.handler(ctx.event);

            const index = durationsLast < ctx.event.repeatCount
              ? durationsLast
              : ctx.event.repeatCount;

            ctx.timer = setTimeout(fn, durations[index]);
          };

          if (durations[0] === 0) {
            fn();
          }
          else {
            ctx.timer = setTimeout(fn, durations[0]);
          }
        },

        move (evt) {
          if (ctx.event !== void 0 && shouldEnd(evt, ctx.origin) === true) {
            clearTimeout(ctx.timer);
          }
        },

        end (evt) {
          if (ctx.event === void 0) {
            return
          }

          ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);
          evt !== void 0 && ctx.event.repeatCount > 0 && stopAndPrevent(evt);

          cleanEvt(ctx, 'temp');
          clearTimeout(ctx.timer);

          ctx.event = void 0;
        }
      };

      el.__qtouchrepeat = ctx;

      modifiers.mouse === true && addEvt(ctx, 'main', [
        [ el, 'mousedown', 'mouseStart', `passive${modifiers.mouseCapture === true ? 'Capture' : ''}` ]
      ]);

      client.has.touch === true && addEvt(ctx, 'main', [
        [ el, 'touchstart', 'touchStart', `passive${modifiers.capture === true ? 'Capture' : ''}` ],
        [ el, 'touchend', 'noop', 'notPassiveCapture' ]
      ]);

      keyboard.length > 0 && addEvt(ctx, 'main', [
        [ el, 'keydown', 'keyboardStart', `notPassive${modifiers.keyCapture === true ? 'Capture' : ''}` ]
      ]);
    },

    update (el, { oldValue, value }) {
      const ctx = el.__qtouchrepeat;
      if (ctx !== void 0 && oldValue !== value) {
        typeof value !== 'function' && ctx.end();
        ctx.handler = value;
      }
    },

    unbind (el) {
      if (el.__qtouchrepeat_destroyed === void 0) {
        destroy$b(el);
      }
      else {
        delete el.__qtouchrepeat_destroyed;
      }
    }
  };



  var directives = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ClosePopup: ClosePopup,
    GoBack: GoBack,
    Intersection: Intersection,
    Morph: Morph,
    Mutation: Mutation,
    Ripple: Ripple,
    ScrollFire: ScrollFire,
    Scroll: Scroll,
    TouchHold: TouchHold,
    TouchPan: TouchPan,
    TouchRepeat: TouchRepeat,
    TouchSwipe: TouchSwipe
  });

  let metaValue;

  function getProp () {
    if (Platform.is.winphone) {
      return 'msapplication-navbutton-color'
    }
    if (Platform.is.safari) {
      return 'apple-mobile-web-app-status-bar-style'
    }
    // Chrome, Firefox OS, Opera, Vivaldi
    return 'theme-color'
  }

  function getMetaTag (v) {
    const els = document.getElementsByTagName('META');
    for (const i in els) {
      if (els[i].name === v) {
        return els[i]
      }
    }
  }

  function setColor (hexColor) {
    if (metaValue === void 0) {
      // cache it
      metaValue = getProp();
    }

    let metaTag = getMetaTag(metaValue);
    const newTag = metaTag === void 0;

    if (newTag) {
      metaTag = document.createElement('meta');
      metaTag.setAttribute('name', metaValue);
    }

    metaTag.setAttribute('content', hexColor);

    if (newTag) {
      document.head.appendChild(metaTag);
    }
  }

  var AddressbarColor = {
    install ({ $q, cfg }) {
      this.set = isSSR === false && Platform.is.mobile === true && (
        Platform.is.nativeMobile === true ||
        Platform.is.winphone === true || Platform.is.safari === true ||
        Platform.is.webkit === true || Platform.is.vivaldi === true
      )
        ? hexColor => {
          const val = hexColor || getBrand('primary');

          if (Platform.is.nativeMobile === true && window.StatusBar) {
            window.StatusBar.backgroundColorByHexString(val);
          }
          else {
            setColor(val);
          }
        }
        : noop;

      $q.addressbarColor = this;

      cfg.addressbarColor && this.set(cfg.addressbarColor);
    }
  };

  const prefixes = {};

  // needed for consistency across browsers,
  // including IE11 which does not return anything
  function promisify (target, fn) {
    try {
      const res = target[fn]();
      return res === void 0
        ? Promise.resolve()
        : res
    }
    catch (err) {
      return Promise.reject(err)
    }
  }

  function checkActive (plugin) {
    plugin.activeEl = document.fullscreenElement ||
      document.mozFullScreenElement ||
      document.webkitFullscreenElement ||
      document.msFullscreenElement ||
      null;

    plugin.isActive = plugin.activeEl !== null;
  }

  var AppFullscreen = {
    isCapable: false,
    isActive: false,
    activeEl: null,

    request (target) {
      if (this.isCapable === true) {
        const el = target || document.documentElement;

        if (el !== this.activeEl) {
          const q = client.is.ie === true && this.activeEl !== null && el.contains(this.activeEl)
            ? this.exit()
            : Promise.resolve();

          return q
            .then(() => promisify(el, prefixes.request))
            .catch(error => (
              this.activeEl !== null
                ? this.exit().then(() => promisify(el, prefixes.request))
                : Promise.reject(error)
            ))
            .then(res => {
              checkActive(this);
              return res
            })
        }
      }

      return this.__getErr()
    },

    exit () {
      return this.isCapable === true && this.isActive === true
        ? promisify(document, prefixes.exit).then(res => {
          checkActive(this);
          return this.isActive ? this.exit() : res
        })
        : this.__getErr()
    },

    toggle (target) {
      const el = target || document.documentElement;

      return this.activeEl === el
        ? this.exit()
        : this.request(el)
    },

    install ({ $q }) {
      $q.fullscreen = this;

      this.__getErr = () => Promise.resolve();

      if (isSSR === true) { return }

      prefixes.request = [
        'requestFullscreen',
        'msRequestFullscreen', 'mozRequestFullScreen', 'webkitRequestFullscreen'
      ].find(request => document.documentElement[request] !== void 0);

      this.isCapable = prefixes.request !== void 0;

      if (this.isCapable === false) {
        // it means the browser does NOT support it
        this.__getErr = () => Promise.reject('Not capable');
        return
      }

      prefixes.exit = [
        'exitFullscreen',
        'msExitFullscreen', 'mozCancelFullScreen', 'webkitExitFullscreen'
      ].find(exit => document[exit]);

      checkActive(this)

      ;[
        'onfullscreenchange',
        'onmsfullscreenchange', 'onwebkitfullscreenchange'
      ].forEach(evt => {
        document[evt] = () => {
          checkActive(this);
        };
      });

      Vue.util.defineReactive(this, 'isActive', this.isActive);
      Vue.util.defineReactive(this, 'activeEl', this.activeEl);
    }
  };

  var AppVisibility = {
    appVisible: false,

    install ({ $q }) {
      if (isSSR === true) {
        this.appVisible = $q.appVisible = true;
        return
      }

      let prop, evt;

      if (typeof document.hidden !== 'undefined') { // Opera 12.10 and Firefox 18 and later support
        prop = 'hidden';
        evt = 'visibilitychange';
      }
      else if (typeof document.msHidden !== 'undefined') {
        prop = 'msHidden';
        evt = 'msvisibilitychange';
      }
      else if (typeof document.webkitHidden !== 'undefined') {
        prop = 'webkitHidden';
        evt = 'webkitvisibilitychange';
      }

      const update = () => {
        this.appVisible = $q.appVisible = !document[prop];
      };

      update();

      if (evt && typeof document[prop] !== 'undefined') {
        Vue.util.defineReactive($q, 'appVisible', this.appVisible);
        document.addEventListener(evt, update, false);
      }
    }
  };

  var BottomSheet = Vue.extend({
    name: 'BottomSheetPlugin',

    mixins: [ DarkMixin, AttrsMixin ],

    inheritAttrs: false,

    props: {
      title: String,
      message: String,
      actions: Array,

      grid: Boolean,

      cardClass: [String, Array, Object],
      cardStyle: [String, Array, Object]
    },

    computed: {
      dialogProps () {
        return {
          ...this.qAttrs,
          position: 'bottom'
        }
      }
    },

    methods: {
      show () {
        this.$refs.dialog.show();
      },

      hide () {
        this.$refs.dialog.hide();
      },

      onOk (action) {
        this.$emit('ok', action);
        this.hide();
      },

      __getGrid (h) {
        return this.actions.map(action => {
          const img = action.avatar || action.img;

          return action.label === void 0
            ? h(QSeparator, {
              staticClass: 'col-all',
              props: { dark: this.isDark }
            })
            : h('div', {
              staticClass: 'q-bottom-sheet__item q-hoverable q-focusable cursor-pointer relative-position',
              class: action.classes,
              attrs: { tabindex: 0 },
              on: {
                click: () => this.onOk(action),
                keyup: e => {
                  e.keyCode === 13 && this.onOk(action);
                }
              }
            }, [
              h('div', { staticClass: 'q-focus-helper' }),

              action.icon
                ? h(QIcon, { props: { name: action.icon, color: action.color } })
                : (
                  img
                    ? h('img', {
                      attrs: { src: img },
                      staticClass: action.avatar ? 'q-bottom-sheet__avatar' : null
                    })
                    : h('div', { staticClass: 'q-bottom-sheet__empty-icon' })
                ),

              h('div', [ action.label ])
            ])
        })
      },

      __getList (h) {
        return this.actions.map(action => {
          const img = action.avatar || action.img;

          return action.label === void 0
            ? h(QSeparator, { props: { spaced: true, dark: this.isDark } })
            : h(QItem, {
              staticClass: 'q-bottom-sheet__item',
              class: action.classes,
              props: {
                tabindex: 0,
                clickable: true,
                dark: this.isDark
              },
              on: {
                click: () => this.onOk(action),
                keyup: e => {
                  e.keyCode === 13 && this.onOk(action);
                }
              }
            }, [
              h(QItemSection, { props: { avatar: true } }, [
                action.icon
                  ? h(QIcon, { props: { name: action.icon, color: action.color } })
                  : (
                    img
                      ? h('img', {
                        attrs: { src: img },
                        staticClass: action.avatar ? 'q-bottom-sheet__avatar' : null
                      })
                      : null
                  )
              ]),
              h(QItemSection, [ action.label ])
            ])
        })
      }
    },

    render (h) {
      const child = [];

      this.title && child.push(
        h(QCardSection, {
          staticClass: 'q-dialog__title'
        }, [ this.title ])
      );

      this.message && child.push(
        h(QCardSection, {
          staticClass: 'q-dialog__message'
        }, [ this.message ])
      );

      child.push(
        this.grid === true
          ? h('div', {
            staticClass: 'row items-stretch justify-start'
          }, this.__getGrid(h))
          : h('div', this.__getList(h))
      );

      return h(QDialog, {
        ref: 'dialog',
        props: this.dialogProps,
        on: cache(this, 'hide', {
          hide: () => {
            this.$emit('hide');
          }
        })
      }, [
        h(QCard, {
          staticClass: `q-bottom-sheet q-bottom-sheet--${this.grid === true ? 'grid' : 'list'}` +
            (this.isDark === true ? ' q-bottom-sheet--dark q-dark' : ''),
          style: this.cardStyle,
          class: this.cardClass
        }, child)
      ])
    }
  });

  const ssrAPI = {
    onOk: () => ssrAPI,
    okCancel: () => ssrAPI,
    hide: () => ssrAPI,
    update: () => ssrAPI
  };

  function merge (target, source) {
    for (const key in source) {
      if (key !== 'spinner' && Object(source[key]) === source[key]) {
        target[key] = Object(target[key]) !== target[key]
          ? {}
          : { ...target[key] };

        merge(target[key], source[key]);
      }
      else {
        target[key] = source[key];
      }
    }
  }

  let appRoot;

  function getDialogParent (parent, root) {
    if (parent !== void 0) { return parent }
    if (root !== void 0) { return root }

    if (appRoot === void 0) {
      const elRoot = document.getElementById('q-app');

      if (elRoot && elRoot.__vue__) {
        appRoot = elRoot.__vue__.$root;
      }
    }

    return appRoot
  }

  function globalDialog (DefaultComponent) {
    return ({ className, class: klass, style, component, root, parent, ...props }) => {
      if (isSSR === true) { return ssrAPI }

      klass !== void 0 && (props.cardClass = klass);
      style !== void 0 && (props.cardStyle = style);

      const isCustom = component !== void 0;
      let DialogComponent, attrs;

      if (isCustom === true) {
        DialogComponent = component;
      }
      else {
        DialogComponent = DefaultComponent;
        attrs = props;
      }

      const
        okFns = [],
        cancelFns = [],
        API = {
          onOk (fn) {
            okFns.push(fn);
            return API
          },
          onCancel (fn) {
            cancelFns.push(fn);
            return API
          },
          onDismiss (fn) {
            okFns.push(fn);
            cancelFns.push(fn);
            return API
          },
          hide () {
            vm.$refs.dialog.hide();
            return API
          },
          update ({ className, class: klass, style, component, root, parent, ...cfg }) {
            if (vm !== null) {
              klass !== void 0 && (cfg.cardClass = klass);
              style !== void 0 && (cfg.cardStyle = style);

              if (isCustom === true) {
                Object.assign(props, cfg);
              }
              else {
                merge(props, cfg);

                // need to change "attrs" reference to
                // actually reflect it in underlying component
                // when we force update it
                attrs = { ...props };
              }

              vm.$forceUpdate();
            }

            return API
          }
        };

      const node = document.createElement('div');
      document.body.appendChild(node);

      let emittedOK = false;

      const on = {
        ok: data => {
          emittedOK = true;
          okFns.forEach(fn => { fn(data); });
        },

        hide: () => {
          vm.$destroy();
          vm.$el.remove();
          vm = null;

          if (emittedOK !== true) {
            cancelFns.forEach(fn => { fn(); });
          }
        }
      };

      let vm = new Vue({
        name: 'QGlobalDialog',

        el: node,
        parent: getDialogParent(parent, root),

        render (h) {
          return h(DialogComponent, {
            ref: 'dialog',
            props,
            attrs,
            on
          })
        },

        mounted () {
          if (this.$refs.dialog !== void 0) {
            this.$refs.dialog.show();
          }
          else {
            on['hook:mounted'] = () => {
              this.$refs.dialog !== void 0 && this.$refs.dialog.show();
            };
          }
        }
      });

      return API
    }
  }

  var BottomSheet$1 = {
    install ({ $q }) {
      this.create = $q.bottomSheet = globalDialog(BottomSheet);
    }
  };

  function encode (string) {
    return encodeURIComponent(string)
  }

  function decode (string) {
    return decodeURIComponent(string)
  }

  function stringifyCookieValue (value) {
    return encode(value === Object(value) ? JSON.stringify(value) : '' + value)
  }

  function read (string) {
    if (string === '') {
      return string
    }

    if (string.indexOf('"') === 0) {
      // This is a quoted cookie as according to RFC2068, unescape...
      string = string.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
    }

    // Replace server-side written pluses with spaces.
    // If we can't decode the cookie, ignore it, it's unusable.
    // If we can't parse the cookie, ignore it, it's unusable.
    string = decode(string.replace(/\+/g, ' '));

    try {
      string = JSON.parse(string);
    }
    catch (e) {}

    return string
  }

  function getString (msOffset) {
    const time = new Date();
    time.setMilliseconds(time.getMilliseconds() + msOffset);
    return time.toUTCString()
  }

  function parseExpireString (str) {
    let timestamp = 0;

    const days = str.match(/(\d+)d/);
    const hours = str.match(/(\d+)h/);
    const minutes = str.match(/(\d+)m/);
    const seconds = str.match(/(\d+)s/);

    if (days) { timestamp += days[1] * 864e+5; }
    if (hours) { timestamp += hours[1] * 36e+5; }
    if (minutes) { timestamp += minutes[1] * 6e+4; }
    if (seconds) { timestamp += seconds[1] * 1000; }

    return timestamp === 0
      ? str
      : getString(timestamp)
  }

  function set (key, val, opts = {}, ssr) {
    let expire, expireValue;

    if (opts.expires !== void 0) {
      // if it's a Date Object
      if (Object.prototype.toString.call(opts.expires) === '[object Date]') {
        expire = opts.expires.toUTCString();
      }
      // if it's a String (eg. "15m", "1h", "13d", "1d 15m", "31s")
      // possible units: d (days), h (hours), m (minutes), s (seconds)
      else if (typeof opts.expires === 'string') {
        expire = parseExpireString(opts.expires);
      }
      // otherwise it must be a Number (defined in days)
      else {
        expireValue = parseFloat(opts.expires);
        expire = isNaN(expireValue) === false
          ? getString(expireValue * 864e+5)
          : opts.expires;
      }
    }

    const keyValue = `${encode(key)}=${stringifyCookieValue(val)}`;

    const cookie = [
      keyValue,
      expire !== void 0 ? '; Expires=' + expire : '', // use expires attribute, max-age is not supported by IE
      opts.path ? '; Path=' + opts.path : '',
      opts.domain ? '; Domain=' + opts.domain : '',
      opts.sameSite ? '; SameSite=' + opts.sameSite : '',
      opts.httpOnly ? '; HttpOnly' : '',
      opts.secure ? '; Secure' : '',
      opts.other ? '; ' + opts.other : ''
    ].join('');

    if (ssr) {
      if (ssr.req.qCookies) {
        ssr.req.qCookies.push(cookie);
      }
      else {
        ssr.req.qCookies = [ cookie ];
      }

      ssr.res.setHeader('Set-Cookie', ssr.req.qCookies);

      // make temporary update so future get()
      // within same SSR timeframe would return the set value

      let all = ssr.req.headers.cookie || '';

      if (expire !== void 0 && expireValue < 0) {
        const val = get(key, ssr);
        if (val !== void 0) {
          all = all
            .replace(`${key}=${val}; `, '')
            .replace(`; ${key}=${val}`, '')
            .replace(`${key}=${val}`, '');
        }
      }
      else {
        all = all
          ? `${keyValue}; ${all}`
          : cookie;
      }

      ssr.req.headers.cookie = all;
    }
    else {
      document.cookie = cookie;
    }
  }

  function get (key, ssr) {
    const
      cookieSource = ssr ? ssr.req.headers : document,
      cookies = cookieSource.cookie ? cookieSource.cookie.split('; ') : [],
      l = cookies.length;
    let
      result = key ? null : {},
      i = 0,
      parts,
      name,
      cookie;

    for (; i < l; i++) {
      parts = cookies[i].split('=');
      name = decode(parts.shift());
      cookie = parts.join('=');

      if (!key) {
        result[name] = cookie;
      }
      else if (key === name) {
        result = read(cookie);
        break
      }
    }

    return result
  }

  function remove (key, options, ssr) {
    set(
      key,
      '',
      { expires: -1, ...options },
      ssr
    );
  }

  function has (key, ssr) {
    return get(key, ssr) !== null
  }

  function getObject (ssr) {
    return {
      get: key => get(key, ssr),
      set: (key, val, opts) => set(key, val, opts, ssr),
      has: key => has(key, ssr),
      remove: (key, options) => remove(key, options, ssr),
      getAll: () => get(null, ssr)
    }
  }

  var Cookies = {
    parseSSR (ssrContext) {
      return ssrContext !== void 0
        ? getObject(ssrContext)
        : this
    },

    install ({ $q, queues }) {
      if (isSSR === true) {
        queues.server.push((q, ctx) => {
          q.cookies = getObject(ctx.ssr);
        });
      }
      else {
        Object.assign(this, getObject());
        $q.cookies = this;
      }
    }
  };

  var DialogPlugin = Vue.extend({
    name: 'DialogPlugin',

    mixins: [ DarkMixin, AttrsMixin ],

    inheritAttrs: false,

    props: {
      title: String,
      message: String,
      prompt: Object,
      options: Object,
      progress: [ Boolean, Object ],

      html: Boolean,

      ok: {
        type: [ String, Object, Boolean ],
        default: true
      },
      cancel: [ String, Object, Boolean ],
      focus: {
        type: String,
        default: 'ok',
        validator: v => ['ok', 'cancel', 'none'].includes(v)
      },

      stackButtons: Boolean,
      color: String,

      cardClass: [ String, Array, Object ],
      cardStyle: [ String, Array, Object ]
    },

    computed: {
      classes () {
        return 'q-dialog-plugin' +
          (this.isDark === true ? ' q-dialog-plugin--dark q-dark' : '') +
          (this.progress !== false ? ' q-dialog-plugin--progress' : '')
      },

      spinner () {
        if (this.progress !== false) {
          return isObject(this.progress) === true
            ? {
              component: this.progress.spinner || QSpinner,
              props: { color: this.progress.color || this.vmColor }
            }
            : {
              component: QSpinner,
              props: { color: this.vmColor }
            }
        }
      },

      hasForm () {
        return this.prompt !== void 0 || this.options !== void 0
      },

      okLabel () {
        return isObject(this.ok) === true
          ? this.$q.lang.label.ok
          : (
            this.ok === true
              ? this.$q.lang.label.ok
              : this.ok
          )
      },

      cancelLabel () {
        return isObject(this.cancel) === true
          ? this.$q.lang.label.cancel
          : (
            this.cancel === true
              ? this.$q.lang.label.cancel
              : this.cancel
          )
      },

      vmColor () {
        return this.color || (this.isDark === true ? 'amber' : 'primary')
      },

      okDisabled () {
        if (this.prompt !== void 0) {
          return this.prompt.isValid !== void 0 &&
            this.prompt.isValid(this.prompt.model) !== true
        }
        if (this.options !== void 0) {
          return this.options.isValid !== void 0 &&
            this.options.isValid(this.options.model) !== true
        }
      },

      okProps () {
        return {
          color: this.vmColor,
          label: this.okLabel,
          ripple: false,
          disable: this.okDisabled,
          ...(isObject(this.ok) === true ? this.ok : { flat: true })
        }
      },

      cancelProps () {
        return {
          color: this.vmColor,
          label: this.cancelLabel,
          ripple: false,
          ...(isObject(this.cancel) === true ? this.cancel : { flat: true })
        }
      }
    },

    methods: {
      show () {
        this.$refs.dialog.show();
      },

      hide () {
        this.$refs.dialog.hide();
      },

      getPrompt (h) {
        return [
          h(QInput, {
            props: {
              value: this.prompt.model,
              type: this.prompt.type,

              label: this.prompt.label,
              stackLabel: this.prompt.stackLabel,

              outlined: this.prompt.outlined,
              filled: this.prompt.filled,
              standout: this.prompt.standout,
              rounded: this.prompt.rounded,
              square: this.prompt.square,

              counter: this.prompt.counter,
              maxlength: this.prompt.maxlength,
              prefix: this.prompt.prefix,
              suffix: this.prompt.suffix,

              color: this.vmColor,
              dense: true,
              autofocus: true,
              dark: this.isDark
            },
            attrs: this.prompt.attrs,
            on: cache(this, 'prompt', {
              input: v => { this.prompt.model = v; },
              keyup: evt => {
                // if ENTER key
                if (
                  this.okDisabled !== true &&
                  this.prompt.type !== 'textarea' &&
                  isKeyCode(evt, 13) === true
                ) {
                  this.onOk();
                }
              }
            })
          })
        ]
      },

      getOptions (h) {
        return [
          h(QOptionGroup, {
            props: {
              value: this.options.model,
              type: this.options.type,
              color: this.vmColor,
              inline: this.options.inline,
              options: this.options.items,
              dark: this.isDark
            },
            on: cache(this, 'opts', {
              input: v => { this.options.model = v; }
            })
          })
        ]
      },

      getButtons (h) {
        const child = [];

        this.cancel && child.push(h(QBtn, {
          props: this.cancelProps,
          attrs: { 'data-autofocus': this.focus === 'cancel' && this.hasForm !== true },
          on: cache(this, 'cancel', { click: this.onCancel })
        }));

        this.ok && child.push(h(QBtn, {
          props: this.okProps,
          attrs: { 'data-autofocus': this.focus === 'ok' && this.hasForm !== true },
          on: cache(this, 'ok', { click: this.onOk })
        }));

        if (child.length > 0) {
          return h(QCardActions, {
            staticClass: this.stackButtons === true ? 'items-end' : null,
            props: {
              vertical: this.stackButtons,
              align: 'right'
            }
          }, child)
        }
      },

      onOk () {
        this.$emit('ok', cloneDeep(this.getData()));
        this.hide();
      },

      onCancel () {
        this.hide();
      },

      getData () {
        return this.prompt !== void 0
          ? this.prompt.model
          : (this.options !== void 0 ? this.options.model : void 0)
      },

      getSection (h, staticClass, text) {
        return this.html === true
          ? h(QCardSection, {
            staticClass,
            domProps: { innerHTML: text }
          })
          : h(QCardSection, { staticClass }, [ text ])
      }
    },

    render (h) {
      const child = [];

      this.title && child.push(
        this.getSection(h, 'q-dialog__title', this.title)
      );

      this.progress !== false && child.push(
        h(QCardSection, { staticClass: 'q-dialog__progress' }, [
          h(this.spinner.component, {
            props: this.spinner.props
          })
        ])
      );

      this.message && child.push(
        this.getSection(h, 'q-dialog__message', this.message)
      );

      if (this.prompt !== void 0) {
        child.push(
          h(
            QCardSection,
            { staticClass: 'scroll q-dialog-plugin__form' },
            this.getPrompt(h)
          )
        );
      }
      else if (this.options !== void 0) {
        child.push(
          h(QSeparator, { props: { dark: this.isDark } }),
          h(
            QCardSection,
            { staticClass: 'scroll q-dialog-plugin__form' },
            this.getOptions(h)
          ),
          h(QSeparator, { props: { dark: this.isDark } })
        );
      }

      if (this.ok || this.cancel) {
        child.push(this.getButtons(h));
      }

      return h(QDialog, {
        ref: 'dialog',

        props: {
          ...this.qAttrs,
          value: this.value
        },

        on: cache(this, 'hide', {
          hide: () => {
            this.$emit('hide');
          }
        })
      }, [
        h(QCard, {
          staticClass: this.classes,
          style: this.cardStyle,
          class: this.cardClass,
          props: { dark: this.isDark }
        }, child)
      ])
    }
  });

  var Dialog = {
    install ({ $q }) {
      this.create = $q.dialog = globalDialog(DialogPlugin);
    }
  };

  var LoadingBar = {
    isActive: false,
    start: noop,
    stop: noop,
    increment: noop,
    setDefaults: noop,

    install ({ $q, cfg }) {
      $q.loadingBar = this;

      if (isSSR === true) {
        return
      }

      const props = cfg.loadingBar !== void 0
        ? { ...cfg.loadingBar }
        : {};
      const on = {
        start: () => {
          this.isActive = true;
        },

        stop: () => {
          this.isActive = false;
        }
      };

      const bar = new Vue({
        name: 'LoadingBar',

        // hide App from Vue devtools
        devtools: { hide: true },

        beforeCreate () {
          // prevent error in Vue devtools
          this._routerRoot === void 0 && (this._routerRoot = {});
        },

        render: h => h(QAjaxBar, {
          ref: 'bar',
          props,
          on
        })
      }).$mount().$refs.bar;

      Object.assign(this, {
        start: bar.start,
        stop: bar.stop,
        increment: bar.increment,
        setDefaults: opts => {
          isObject(opts) === true && Object.assign(props, opts);
          bar.$parent.$forceUpdate();
        }
      });

      Vue.util.defineReactive(this, 'isActive', this.isActive);
      Vue.util.defineReactive(bar, 'isActive', this.isActive);
      bar.setDefaults = this.setDefaults;

      document.body.appendChild(bar.$parent.$el);
    }
  };

  let
    vm,
    uid$3 = 0,
    timeout,
    props$1 = {};
  const
    originalDefaults = {
      delay: 0,
      message: false,
      spinnerSize: 80,
      spinnerColor: 'white',
      messageColor: 'white',
      backgroundColor: 'black',
      spinner: QSpinner,
      customClass: ''
    },
    defaults = { ...originalDefaults };

  const Loading = {
    isActive: false,

    show (opts) {
      if (isSSR === true) { return }

      props$1 = isObject(opts) === true && opts.ignoreDefaults === true
        ? { ...originalDefaults, ...opts }
        : { ...defaults, ...opts };

      props$1.customClass += ` text-${props$1.backgroundColor}`;

      this.isActive = true;

      if (vm !== void 0) {
        props$1.uid = uid$3;
        vm.$forceUpdate();
        return
      }

      props$1.uid = ++uid$3;
      clearTimeout(timeout);

      timeout = setTimeout(() => {
        timeout = void 0;

        const node = document.createElement('div');
        document.body.appendChild(node);

        vm = new Vue({
          name: 'QLoading',

          // hide App from Vue devtools
          devtools: { hide: true },

          beforeCreate () {
            // prevent error in Vue devtools
            this._routerRoot === void 0 && (this._routerRoot = {});
          },

          el: node,

          mounted () {
            preventScroll(true);
          },

          render: (h) => {
            return h('transition', {
              props: {
                name: 'q-transition--fade',
                appear: true
              },
              on: cache(this, 'tr', {
                'after-leave': () => {
                  // might be called to finalize
                  // previous leave, even if it was cancelled
                  if (this.isActive !== true && vm !== void 0) {
                    preventScroll(false);
                    vm.$destroy();
                    vm.$el.remove();
                    vm = void 0;
                  }
                }
              })
            }, [
              this.isActive === true ? h('div', {
                staticClass: 'q-loading fullscreen column flex-center z-max',
                key: props$1.uid,
                class: props$1.customClass.trim()
              }, [
                h(props$1.spinner, {
                  props: {
                    color: props$1.spinnerColor,
                    size: props$1.spinnerSize
                  }
                }),

                (props$1.message && h('div', {
                  class: `text-${props$1.messageColor}`,
                  domProps: {
                    [props$1.sanitize === true ? 'textContent' : 'innerHTML']: props$1.message
                  }
                })) || void 0
              ]) : null
            ])
          }
        });
      }, props$1.delay);
    },

    hide () {
      if (this.isActive === true) {
        if (timeout !== void 0) {
          clearTimeout(timeout);
          timeout = void 0;
        }

        this.isActive = false;
      }
    },

    setDefaults (opts) {
      isObject(opts) === true && Object.assign(defaults, opts);
    },

    install ({ $q, cfg: { loading } }) {
      this.setDefaults(loading);
      $q.loading = this;
    }
  };

  if (isSSR === false) {
    Vue.util.defineReactive(Loading, 'isActive', Loading.isActive);
  }

  let updateId, ssrTakeover;

  function normalize (meta) {
    if (meta.title) {
      meta.title = meta.titleTemplate
        ? meta.titleTemplate(meta.title)
        : meta.title;
      delete meta.titleTemplate;
    }
  [['meta', 'content'], ['link', 'href']].forEach(type => {
      const
        metaType = meta[type[0]],
        metaProp = type[1];

      for (const name in metaType) {
        const metaLink = metaType[name];

        if (metaLink.template) {
          if (Object.keys(metaLink).length === 1) {
            delete metaType[name];
          }
          else {
            metaLink[metaProp] = metaLink.template(metaLink[metaProp] || '');
            delete metaLink.template;
          }
        }
      }
    });
  }

  function changed (old, def) {
    if (Object.keys(old).length !== Object.keys(def).length) {
      return true
    }
    for (const key in old) {
      if (old[key] !== def[key]) {
        return true
      }
    }
  }

  function bodyFilter (name) {
    return ['class', 'style'].includes(name) === false
  }

  function htmlFilter (name) {
    return ['lang', 'dir'].includes(name) === false
  }

  function diff (meta, other) {
    const add = {}, remove = {};

    if (meta === void 0) {
      return { add: other, remove }
    }

    if (meta.title !== other.title) {
      add.title = other.title;
    }
  ['meta', 'link', 'script', 'htmlAttr', 'bodyAttr'].forEach(type => {
      const old = meta[type], cur = other[type];
      remove[type] = [];

      if (old === void 0 || old === null) {
        add[type] = cur;
        return
      }

      add[type] = {};

      for (const key in old) {
        if (cur.hasOwnProperty(key) === false) {
          remove[type].push(key);
        }
      }
      for (const key in cur) {
        if (old.hasOwnProperty(key) === false) {
          add[type][key] = cur[key];
        }
        else if (changed(old[key], cur[key]) === true) {
          remove[type].push(key);
          add[type][key] = cur[key];
        }
      }
    });

    return { add, remove }
  }

  function apply$1 ({ add, remove }) {
    if (add.title) {
      document.title = add.title;
    }

    if (Object.keys(remove).length > 0) {
      ['meta', 'link', 'script'].forEach(type => {
        remove[type].forEach(name => {
          document.head.querySelector(`${type}[data-qmeta="${name}"]`).remove();
        });
      });
      remove.htmlAttr.filter(htmlFilter).forEach(name => {
        document.documentElement.removeAttribute(name);
      });
      remove.bodyAttr.filter(bodyFilter).forEach(name => {
        document.body.removeAttribute(name);
      });
    }
  ['meta', 'link', 'script'].forEach(type => {
      const metaType = add[type];

      for (const name in metaType) {
        const tag = document.createElement(type);
        for (const att in metaType[name]) {
          if (att !== 'innerHTML') {
            tag.setAttribute(att, metaType[name][att]);
          }
        }
        tag.setAttribute('data-qmeta', name);
        if (type === 'script') {
          tag.innerHTML = metaType[name].innerHTML || '';
        }
        document.head.appendChild(tag);
      }
    });
    Object.keys(add.htmlAttr).filter(htmlFilter).forEach(name => {
      document.documentElement.setAttribute(name, add.htmlAttr[name] || '');
    });
    Object.keys(add.bodyAttr).filter(bodyFilter).forEach(name => {
      document.body.setAttribute(name, add.bodyAttr[name] || '');
    });
  }

  function parseMeta (component, meta) {
    if (component._inactive === true) { return }

    // if it has meta
    if (hasMeta(component) === true) {
      extend(true, meta, component.__qMeta);

      if (component.$options.meta.stopPropagation === true) {
        return
      }
    }

    component.$children.forEach(child => {
      parseMeta(child, meta);
    });
  }

  function updateClient () {
    if (ssrTakeover === true) {
      ssrTakeover = false;
      this.$root.__currentMeta = window.__Q_META__;
    }

    const meta = {
      title: '',
      titleTemplate: null,
      meta: {},
      link: {},
      script: {},
      htmlAttr: {},
      bodyAttr: {}
    };
    parseMeta(this.$root, meta);
    normalize(meta);

    apply$1(diff(this.$root.__currentMeta, meta));
    this.$root.__currentMeta = meta;
  }

  function getAttr (seed) {
    return att => {
      const val = seed[att];
      return att + (val !== true && val !== void 0 ? `="${val}"` : '')
    }
  }

  function getHead (meta) {
    let output = '';
    if (meta.title) {
      output += `<title>${meta.title}</title>`;
    }
  ['meta', 'link', 'script'].forEach(type => {
      const metaType = meta[type];

      for (const att in metaType) {
        const attrs = Object.keys(metaType[att])
          .filter(att => att !== 'innerHTML')
          .map(getAttr(metaType[att]));

        output += `<${type} ${attrs.join(' ')} data-qmeta="${att}">`;
        if (type === 'script') {
          output += `${metaType[att].innerHTML || ''}</script>`;
        }
      }
    });
    return output
  }

  function getServerMeta (app, html, ctx) {
    const meta = {
      title: '',
      titleTemplate: null,
      meta: {},
      link: {},
      htmlAttr: {},
      bodyAttr: {},
      noscript: {}
    };

    parseMeta(app, meta);
    normalize(meta);

    const nonce = ctx !== void 0 && ctx.nonce !== void 0
      ? ` nonce="${ctx.nonce}"`
      : '';

    const tokens = {
      '%%Q_HTML_ATTRS%%': Object.keys(meta.htmlAttr)
        .filter(htmlFilter)
        .map(getAttr(meta.htmlAttr))
        .join(' '),
      '%%Q_HEAD_TAGS%%': getHead(meta),
      '%%Q_BODY_ATTRS%%': Object.keys(meta.bodyAttr)
        .filter(bodyFilter)
        .map(getAttr(meta.bodyAttr))
        .join(' '),
      '%%Q_BODY_TAGS%%': Object.keys(meta.noscript)
        .map(name => `<noscript data-qmeta="${name}">${meta.noscript[name]}</noscript>`)
        .join('') +
        `<script${nonce}>window.__Q_META__=${delete meta.noscript && JSON.stringify(meta)}</script>`
    };

    Object.keys(tokens).forEach(key => {
      html = html.replace(key, tokens[key]);
    });

    return html
  }

  function beforeCreate () {
    if (typeof this.$options.meta === 'function') {
      if (this.$options.computed === void 0) {
        this.$options.computed = {};
      }
      this.$options.computed.__qMeta = this.$options.meta;
    }
    else if (hasMeta(this) === true) {
      this.__qMeta = this.$options.meta;
    }
  }

  // needs to be really fast
  function hasMeta (vm) {
    return vm.$options.meta !== void 0 &&
      vm.$options.meta !== null
  }

  function triggerMeta () {
    hasMeta(this) === true && this.__qMetaUpdate();
  }

  var Meta = {
    install ({ queues }) {
      if (isSSR === true) {
        Vue.prototype.$getMetaHTML = app => {
          return (html, ctx) => getServerMeta(app, html, ctx)
        };

        Vue.mixin({ beforeCreate });

        queues.server.push((_, ctx) => {
          ctx.ssr.Q_HTML_ATTRS += ' %%Q_HTML_ATTRS%%';
          Object.assign(ctx.ssr, {
            Q_HEAD_TAGS: '%%Q_HEAD_TAGS%%',
            Q_BODY_ATTRS: '%%Q_BODY_ATTRS%%',
            Q_BODY_TAGS: '%%Q_BODY_TAGS%%'
          });
        });
      }
      else {
        ssrTakeover = fromSSR;

        Vue.mixin({
          beforeCreate,
          created () {
            if (hasMeta(this) === true) {
              this.__qMetaUnwatch = this.$watch('__qMeta', this.__qMetaUpdate);
            }
          },
          activated: triggerMeta,
          deactivated: triggerMeta,
          beforeMount: triggerMeta,
          destroyed () {
            if (hasMeta(this) === true) {
              this.__qMetaUnwatch();
              this.__qMetaUpdate();
            }
          },
          methods: {
            __qMetaUpdate () {
              clearTimeout(updateId);
              updateId = setTimeout(updateClient.bind(this), 50);
            }
          }
        });
      }
    }
  };

  let uid$4 = 0, vm$1;

  const defaults$1 = {};
  const groups = {};
  const notificationsList = {};
  const positionClass$1 = {};
  const emptyRE = /^\s*$/;

  const positionList = [
    'top-left', 'top-right',
    'bottom-left', 'bottom-right',
    'top', 'bottom', 'left', 'right', 'center'
  ];

  const badgePositions = [
    'top-left', 'top-right',
    'bottom-left', 'bottom-right'
  ];

  const notifTypes = {
    positive: {
      icon: $q => $q.iconSet.type.positive,
      color: 'positive'
    },

    negative: {
      icon: $q => $q.iconSet.type.negative,
      color: 'negative'
    },

    warning: {
      icon: $q => $q.iconSet.type.warning,
      color: 'warning',
      textColor: 'dark'
    },

    info: {
      icon: $q => $q.iconSet.type.info,
      color: 'info'
    },

    ongoing: {
      group: false,
      timeout: 0,
      spinner: true,
      color: 'grey-8'
    }
  };

  function addNotification (config, vm, originalApi) {
    if (!config) {
      return logError('parameter required')
    }

    let Api;
    const notif = { textColor: 'white' };

    if (config.ignoreDefaults !== true) {
      Object.assign(notif, defaults$1);
    }

    if (isObject(config) === false) {
      if (notif.type) {
        Object.assign(notif, notifTypes[notif.type]);
      }

      config = { message: config };
    }

    Object.assign(notif, notifTypes[config.type || notif.type], config);

    if (typeof notif.icon === 'function') {
      notif.icon = notif.icon(vm.$q);
    }

    if (!notif.spinner) {
      notif.spinner = false;
    }
    else if (notif.spinner === true) {
      notif.spinner = QSpinner;
    }

    notif.meta = {
      hasMedia: Boolean(notif.spinner !== false || notif.icon || notif.avatar),
      hasText: hasContent(notif.message) || hasContent(notif.caption)
    };

    if (notif.position) {
      if (positionList.includes(notif.position) === false) {
        return logError('wrong position', config)
      }
    }
    else {
      notif.position = 'bottom';
    }

    if (notif.timeout === void 0) {
      notif.timeout = 5000;
    }
    else {
      const t = parseInt(notif.timeout, 10);
      if (isNaN(t) || t < 0) {
        return logError('wrong timeout', config)
      }
      notif.timeout = t;
    }

    if (notif.timeout === 0) {
      notif.progress = false;
    }
    else if (notif.progress === true) {
      notif.meta.progressClass = 'q-notification__progress' + (
        notif.progressClass
          ? ` ${notif.progressClass}`
          : ''
      );

      notif.meta.progressStyle = {
        animationDuration: `${notif.timeout + 1000}ms`
      };
    }

    const actions = (
      Array.isArray(config.actions) === true
        ? config.actions
        : []
    ).concat(
      config.ignoreDefaults !== true && Array.isArray(defaults$1.actions) === true
        ? defaults$1.actions
        : []
    ).concat(
      notifTypes[config.type] !== void 0 && Array.isArray(notifTypes[config.type].actions) === true
        ? notifTypes[config.type].actions
        : []
    );

    const { closeBtn } = notif;
    closeBtn && actions.push({
      label: typeof closeBtn === 'string'
        ? closeBtn
        : vm.$q.lang.label.close
    });

    notif.actions = actions.map(({ handler, noDismiss, style, class: klass, attrs, ...props }) => ({
      staticClass: klass,
      style,
      props: { flat: true, ...props },
      attrs,
      on: {
        click: typeof handler === 'function'
          ? () => {
            handler();
            noDismiss !== true && dismiss();
          }
          : () => { dismiss(); }
      }
    }));

    if (notif.multiLine === void 0) {
      notif.multiLine = notif.actions.length > 1;
    }

    Object.assign(notif.meta, {
      staticClass: 'q-notification row items-stretch' +
        ` q-notification--${notif.multiLine === true ? 'multi-line' : 'standard'}` +
        (notif.color !== void 0 ? ` bg-${notif.color}` : '') +
        (notif.textColor !== void 0 ? ` text-${notif.textColor}` : '') +
        (notif.classes !== void 0 ? ` ${notif.classes}` : ''),

      wrapperClass: 'q-notification__wrapper col relative-position border-radius-inherit ' +
        (notif.multiLine === true ? 'column no-wrap justify-center' : 'row items-center'),

      contentClass: 'q-notification__content row items-center' +
        (notif.multiLine === true ? '' : ' col'),

      leftClass: notif.meta.hasText === true ? 'additional' : 'single',

      attrs: {
        role: 'alert',
        ...notif.attrs
      }
    });

    if (notif.group === false) {
      notif.group = void 0;
      notif.meta.group = void 0;
    }
    else {
      if (notif.group === void 0 || notif.group === true) {
        // do not replace notifications with different buttons
        notif.group = [
          notif.message,
          notif.caption,
          notif.multiline
        ].concat(
          notif.actions.map(({ props }) => `${props.label}*${props.icon}`)
        ).join('|');
      }

      notif.meta.group = notif.group + '|' + notif.position;
    }

    if (notif.actions.length === 0) {
      notif.actions = void 0;
    }
    else {
      notif.meta.actionsClass = 'q-notification__actions row items-center ' +
        (notif.multiLine === true ? 'justify-end' : 'col-auto') +
        (notif.meta.hasMedia === true ? ' q-notification__actions--with-media' : '');
    }

    if (originalApi !== void 0) {
      // reset timeout if any
      clearTimeout(originalApi.notif.meta.timer);

      // retain uid
      notif.meta.uid = originalApi.notif.meta.uid;

      // replace notif
      const index = notificationsList[notif.position].indexOf(originalApi.notif);
      notificationsList[notif.position][index] = notif;
    }
    else {
      const original = groups[notif.meta.group];

      // woohoo, it's a new notification
      if (original === void 0) {
        notif.meta.uid = uid$4++;
        notif.meta.badge = 1;

        if (['left', 'right', 'center'].indexOf(notif.position) !== -1) {
          notificationsList[notif.position].splice(
            Math.floor(notificationsList[notif.position].length / 2),
            0,
            notif
          );
        }
        else {
          const action = notif.position.indexOf('top') > -1 ? 'unshift' : 'push';
          notificationsList[notif.position][action](notif);
        }

        if (notif.group !== void 0) {
          groups[notif.meta.group] = notif;
        }
      }
      // ok, so it's NOT a new one
      else {
        // reset timeout if any
        clearTimeout(original.meta.timer);

        if (notif.badgePosition !== void 0) {
          if (badgePositions.includes(notif.badgePosition) === false) {
            return logError('wrong badgePosition', config)
          }
        }
        else {
          notif.badgePosition = `top-${notif.position.indexOf('left') > -1 ? 'right' : 'left'}`;
        }

        notif.meta.uid = original.meta.uid;
        notif.meta.badge = original.meta.badge + 1;
        notif.meta.badgeClass = `q-notification__badge q-notification__badge--${notif.badgePosition}` +
          (notif.badgeColor !== void 0 ? ` bg-${notif.badgeColor}` : '') +
          (notif.badgeTextColor !== void 0 ? ` text-${notif.badgeTextColor}` : '') +
          (notif.badgeClass ? ` ${notif.badgeClass}` : '');

        const index = notificationsList[notif.position].indexOf(original);
        notificationsList[notif.position][index] = groups[notif.meta.group] = notif;
      }
    }

    const dismiss = () => {
      removeNotification(notif, vm);
      Api = void 0;
    };

    vm.$forceUpdate();

    if (notif.timeout > 0) {
      notif.meta.timer = setTimeout(() => {
        dismiss();
      }, notif.timeout + /* show duration */ 1000);
    }

    // only non-groupable can be updated
    if (notif.group !== void 0) {
      return props => {
        if (props !== void 0) {
          logError('trying to update a grouped one which is forbidden', config);
        }
        else {
          dismiss();
        }
      }
    }

    Api = {
      dismiss,
      config,
      notif
    };

    if (originalApi !== void 0) {
      Object.assign(originalApi, Api);
      return
    }

    return props => {
      // if notification wasn't previously dismissed
      if (Api !== void 0) {
        // if no params, then we must dismiss the notification
        if (props === void 0) {
          Api.dismiss();
        }
        // otherwise we're updating it
        else {
          const newNotif = Object.assign({}, Api.config, props, {
            group: false,
            position: notif.position
          });

          addNotification(newNotif, vm, Api);
        }
      }
    }
  }

  function removeNotification (notif, vm) {
    clearTimeout(notif.meta.timer);

    const index = notificationsList[notif.position].indexOf(notif);
    if (index !== -1) {
      if (notif.group !== void 0) {
        delete groups[notif.meta.group];
      }

      const el = vm.$refs['' + notif.meta.uid];

      if (el) {
        const { width, height } = getComputedStyle(el);

        el.style.left = `${el.offsetLeft}px`;
        el.style.width = width;
        el.style.height = height;
      }

      notificationsList[notif.position].splice(index, 1);

      vm.$forceUpdate();

      if (typeof notif.onDismiss === 'function') {
        notif.onDismiss();
      }
    }
  }

  function hasContent (str) {
    return str !== void 0 &&
      str !== null &&
      emptyRE.test(str) !== true
  }

  function logError (error, config) {
    console.error(`Notify: ${error}`, config);
    return false
  }

  const Notifications = {
    name: 'QNotifications',

    // hide App from Vue devtools
    devtools: { hide: true },

    beforeCreate () {
      // prevent error in Vue devtools
      this._routerRoot === void 0 && (this._routerRoot = {});
    },

    render (h) {
      return h('div', { staticClass: 'q-notifications' }, positionList.map(pos => {
        return h('transition-group', {
          key: pos,
          staticClass: positionClass$1[pos],
          tag: 'div',
          props: {
            name: `q-notification--${pos}`,
            mode: 'out-in'
          }
        }, notificationsList[pos].map(notif => {
          const { meta } = notif;
          const mainChild = [];

          if (meta.hasMedia === true) {
            if (notif.spinner !== false) {
              mainChild.push(
                h(notif.spinner, {
                  staticClass: 'q-notification__spinner q-notification__spinner--' + meta.leftClass,
                  props: { color: notif.spinnerColor, size: notif.spinnerSize }
                })
              );
            }
            else if (notif.icon) {
              mainChild.push(
                h(QIcon, {
                  staticClass: 'q-notification__icon q-notification__icon--' + meta.leftClass,
                  attrs: { role: 'img' },
                  props: { name: notif.icon, color: notif.iconColor, size: notif.iconSize }
                })
              );
            }
            else if (notif.avatar) {
              mainChild.push(
                h(QAvatar, { staticClass: 'q-notification__avatar q-notification__avatar--' + meta.leftClass }, [
                  h('img', { attrs: { src: notif.avatar, 'aria-hidden': 'true' } })
                ])
              );
            }
          }

          if (meta.hasText === true) {
            let msgChild;
            const msgData = { staticClass: 'q-notification__message col' };

            if (notif.html === true) {
              msgData.domProps = {
                innerHTML: notif.caption
                  ? `<div>${notif.message}</div><div class="q-notification__caption">${notif.caption}</div>`
                  : notif.message
              };
            }
            else {
              const msgNode = [ notif.message ];
              msgChild = notif.caption
                ? [
                  h('div', msgNode),
                  h('div', { staticClass: 'q-notification__caption' }, [notif.caption])
                ]
                : msgNode;
            }

            mainChild.push(
              h('div', msgData, msgChild)
            );
          }

          const child = [
            h('div', { staticClass: meta.contentClass }, mainChild)
          ];

          notif.progress === true && child.push(
            h('div', {
              key: `${meta.uid}|p|${meta.badge}`,
              staticClass: meta.progressClass,
              style: meta.progressStyle
            })
          );

          notif.actions !== void 0 && child.push(
            h('div', {
              staticClass: meta.actionsClass
            }, notif.actions.map(action => h(QBtn, { ...action })))
          );

          meta.badge > 1 && child.push(
            h('div', {
              key: `${meta.uid}|${meta.badge}`,
              staticClass: meta.badgeClass,
              style: notif.badgeStyle
            }, [ meta.badge ])
          );

          return h('div', {
            ref: '' + meta.uid,
            key: meta.uid,
            staticClass: meta.staticClass,
            attrs: meta.attrs
          }, [
            h('div', { staticClass: meta.wrapperClass }, child)
          ])
        }))
      }))
    },

    mounted () {
      if (this.$q.fullscreen !== void 0 && this.$q.fullscreen.isCapable === true) {
        const append = () => {
          const newParent = getBodyFullscreenElement(this.$q.fullscreen.activeEl);

          if (this.$el.parentElement !== newParent) {
            newParent.appendChild(this.$el);
          }
        };

        this.unwatchFullscreen = this.$watch('$q.fullscreen.activeEl', debounce(append, 50));

        if (this.$q.fullscreen.isActive === true) {
          append();
        }
      }
    },

    beforeDestroy () {
      this.unwatchFullscreen !== void 0 && this.unwatchFullscreen();
    }
  };

  var Notify = {
    setDefaults (opts) {
      if (isSSR !== true && isObject(opts) === true) {
        Object.assign(defaults$1, opts);
      }
    },

    registerType (typeName, typeOpts) {
      if (isSSR !== true && isObject(typeOpts) === true) {
        notifTypes[typeName] = typeOpts;
      }
    },

    install ({ $q }) {
      $q.notify = this.create = isSSR === true
        ? noop
        : opts => addNotification(opts, vm$1);

      $q.notify.setDefaults = this.setDefaults;
      $q.notify.registerType = this.registerType;

      if ($q.config.notify !== void 0) {
        this.setDefaults($q.config.notify);
      }

      if (isSSR !== true) {
        positionList.forEach(pos => {
          notificationsList[pos] = [];

          const
            vert = ['left', 'center', 'right'].includes(pos) === true ? 'center' : (pos.indexOf('top') > -1 ? 'top' : 'bottom'),
            align = pos.indexOf('left') > -1 ? 'start' : (pos.indexOf('right') > -1 ? 'end' : 'center'),
            classes = ['left', 'right'].includes(pos) ? `items-${pos === 'left' ? 'start' : 'end'} justify-center` : (pos === 'center' ? 'flex-center' : `items-${align}`);

          positionClass$1[pos] = `q-notifications__list q-notifications__list--${vert} fixed column no-wrap ${classes}`;
        });

        const node = document.createElement('div');
        document.body.appendChild(node);

        vm$1 = new Vue(Notifications);
        vm$1.$mount(node);
      }
    }
  };

  function encode$1 (value) {
    if (isDate(value) === true) {
      return '__q_date|' + value.toUTCString()
    }
    if (isRegexp(value) === true) {
      return '__q_expr|' + value.source
    }
    if (typeof value === 'number') {
      return '__q_numb|' + value
    }
    if (typeof value === 'boolean') {
      return '__q_bool|' + (value ? '1' : '0')
    }
    if (typeof value === 'string') {
      return '__q_strn|' + value
    }
    if (typeof value === 'function') {
      return '__q_strn|' + value.toString()
    }
    if (value === Object(value)) {
      return '__q_objt|' + JSON.stringify(value)
    }

    // hmm, we don't know what to do with it,
    // so just return it as is
    return value
  }

  function decode$1 (value) {
    const length = value.length;
    if (length < 9) {
      // then it wasn't encoded by us
      return value
    }

    const type = value.substr(0, 8);
    const source = value.substring(9);

    switch (type) {
      case '__q_date':
        return new Date(source)

      case '__q_expr':
        return new RegExp(source)

      case '__q_numb':
        return Number(source)

      case '__q_bool':
        return Boolean(source === '1')

      case '__q_strn':
        return '' + source

      case '__q_objt':
        return JSON.parse(source)

      default:
        // hmm, we reached here, we don't know the type,
        // then it means it wasn't encoded by us, so just
        // return whatever value it is
        return value
    }
  }

  function getEmptyStorage () {
    const getVal = () => null;

    return {
      has: () => false,
      getLength: () => 0,
      getItem: getVal,
      getIndex: getVal,
      getKey: getVal,
      getAll: () => {},
      getAllKeys: () => [],
      set: noop,
      remove: noop,
      clear: noop,
      isEmpty: () => true
    }
  }

  function getStorage (type) {
    const
      webStorage = window[type + 'Storage'],
      get = key => {
        const item = webStorage.getItem(key);
        return item
          ? decode$1(item)
          : null
      };

    return {
      has: key => webStorage.getItem(key) !== null,
      getLength: () => webStorage.length,
      getItem: get,
      getIndex: index => {
        return index < webStorage.length
          ? get(webStorage.key(index))
          : null
      },
      getKey: index => {
        return index < webStorage.length
          ? webStorage.key(index)
          : null
      },
      getAll: () => {
        let key;
        const result = {}, len = webStorage.length;

        for (let i = 0; i < len; i++) {
          key = webStorage.key(i);
          result[key] = get(key);
        }

        return result
      },
      getAllKeys: () => {
        const result = [], len = webStorage.length;

        for (let i = 0; i < len; i++) {
          result.push(webStorage.key(i));
        }

        return result
      },
      set: (key, value) => { webStorage.setItem(key, encode$1(value)); },
      remove: key => { webStorage.removeItem(key); },
      clear: () => { webStorage.clear(); },
      isEmpty: () => webStorage.length === 0
    }
  }

  var LocalStorage = {
    install ({ $q }) {
      const storage = isSSR === true || client.has.webStorage === false
        ? getEmptyStorage()
        : getStorage('local');

      $q.localStorage = storage;
      Object.assign(this, storage);
    }
  };

  var SessionStorage = {
    install ({ $q }) {
      const storage = isSSR === true || client.has.webStorage === false
        ? getEmptyStorage()
        : getStorage('session');

      $q.sessionStorage = storage;
      Object.assign(this, storage);
    }
  };



  var plugins = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AddressbarColor: AddressbarColor,
    AppFullscreen: AppFullscreen,
    AppVisibility: AppVisibility,
    BottomSheet: BottomSheet$1,
    Cookies: Cookies,
    Dark: Dark,
    Dialog: Dialog,
    LoadingBar: LoadingBar,
    Loading: Loading,
    Meta: Meta,
    Notify: Notify,
    Platform: Platform,
    Screen: Screen,
    LocalStorage: LocalStorage,
    SessionStorage: SessionStorage
  });

  function fallback (text) {
    const area = document.createElement('textarea');
    area.value = text;
    area.contentEditable = true;
    area.style.position = 'fixed'; // avoid scrolling to bottom

    document.body.appendChild(area);
    area.focus();
    area.select();

    const res = document.execCommand('copy');

    area.remove();
    return res
  }

  function copyToClipboard (text) {
    return navigator.clipboard !== void 0
      ? navigator.clipboard.writeText(text)
      : new Promise((resolve, reject) => {
        const res = fallback(text);
        if (res) {
          resolve(true);
        }
        else {
          reject(res);
        }
      })
  }

  function clean (link) {
    // allow time for iOS
    setTimeout(() => {
      window.URL.revokeObjectURL(link.href);
    }, 10000);
    link.remove();
  }

  function exportFile (fileName, rawData, mimeType) {
    const blob = new Blob([ rawData ], { type: mimeType || 'text/plain' });

    // IE11 has its own stuff...
    if (window.navigator.msSaveOrOpenBlob) {
      return window.navigator.msSaveOrOpenBlob(blob, fileName)
    }

    const link = document.createElement('a');

    link.download = fileName;
    link.href = window.URL.createObjectURL(blob);

    link.classList.add('hidden');
    link.style.position = 'fixed'; // avoid scrolling to bottom
    document.body.appendChild(link);

    try {
      link.click();
      clean(link);
      return true
    }
    catch (err) {
      clean(link);
      return err
    }
  }

  function parseFeatures (winFeatures) {
    const cfg = Object.assign({ noopener: true }, winFeatures);
    const feat = [];
    Object.keys(cfg).forEach(key => {
      if (cfg[key] === true) {
        feat.push(key);
      }
    });
    return feat.join(',')
  }

  function openWindow (url, reject, windowFeatures) {
    let open = window.open;

    if (Platform.is.cordova === true) {
      if (cordova !== void 0 && cordova.InAppBrowser !== void 0 && cordova.InAppBrowser.open !== void 0) {
        open = cordova.InAppBrowser.open;
      }
      else if (navigator !== void 0 && navigator.app !== void 0) {
        return navigator.app.loadUrl(url, {
          openExternal: true
        })
      }
    }
    else if (Vue.prototype.$q.electron !== void 0) {
      return Vue.prototype.$q.electron.shell.openExternal(url)
    }

    const win = open(url, '_blank', parseFeatures(windowFeatures));

    if (win) {
      Platform.is.desktop && win.focus();
      return win
    }
    else {
      reject && reject();
    }
  }

  var openUrl = (url, reject, windowFeatures) => {
    if (
      Platform.is.ios === true &&
      window.SafariViewController !== void 0
    ) {
      window.SafariViewController.isAvailable(available => {
        if (available) {
          window.SafariViewController.show(
            { url },
            noop,
            reject
          );
        }
        else {
          openWindow(url, reject, windowFeatures);
        }
      });
      return
    }

    return openWindow(url, reject, windowFeatures)
  };



  var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    clone: cloneDeep,
    colors: colors,
    copyToClipboard: copyToClipboard,
    date: date,
    debounce: debounce,
    dom: dom,
    event: event,
    exportFile: exportFile,
    extend: extend,
    format: format,
    frameDebounce: frameDebounce,
    noop: noop,
    openURL: openUrl,
    morph: morph,
    patterns: patterns,
    scroll: scroll,
    throttle: throttle,
    uid: uid$2
  });

  Vue.use({ install }, {
    components: components$1,
    directives,
    plugins,
    config: window.quasarConfig || {}
  });

  var index_umd = {
    version,
    lang: Plugin,
    iconSet,
    components: components$1,
    directives,
    plugins,
    utils,
    ...components$1,
    ...directives,
    ...plugins,
    ...utils
  };

  return index_umd;

})));
